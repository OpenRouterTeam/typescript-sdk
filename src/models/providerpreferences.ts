/*
 * Code generated by Speakeasy (https://speakeasy.com). DO NOT EDIT.
 * @generated-id: 3a47295d7b91
 */

import * as z from "zod/v4";
import { remap as remap$ } from "../lib/primitives.js";
import * as openEnums from "../types/enums.js";
import { ClosedEnum, OpenEnum } from "../types/enums.js";
import {
  DataCollection,
  DataCollection$outboundSchema,
} from "./datacollection.js";
import {
  PreferredMaxLatency,
  PreferredMaxLatency$Outbound,
  PreferredMaxLatency$outboundSchema,
} from "./preferredmaxlatency.js";
import {
  PreferredMinThroughput,
  PreferredMinThroughput$Outbound,
  PreferredMinThroughput$outboundSchema,
} from "./preferredminthroughput.js";
import { ProviderName, ProviderName$outboundSchema } from "./providername.js";
import { ProviderSort, ProviderSort$outboundSchema } from "./providersort.js";
import { Quantization, Quantization$outboundSchema } from "./quantization.js";

export type ProviderPreferencesOrder = ProviderName | string;

export type ProviderPreferencesOnly = ProviderName | string;

export type ProviderPreferencesIgnore = ProviderName | string;

export const SortEnum = {
  Price: "price",
  Throughput: "throughput",
  Latency: "latency",
} as const;
export type SortEnum = OpenEnum<typeof SortEnum>;

export const ProviderSortConfigEnum = {
  Price: "price",
  Throughput: "throughput",
  Latency: "latency",
} as const;
export type ProviderSortConfigEnum = ClosedEnum<typeof ProviderSortConfigEnum>;

export const ProviderPreferencesPartition = {
  Model: "model",
  None: "none",
} as const;
export type ProviderPreferencesPartition = OpenEnum<
  typeof ProviderPreferencesPartition
>;

export type ProviderPreferencesProviderSortConfig = {
  by?: ProviderSort | null | undefined;
  partition?: ProviderPreferencesPartition | null | undefined;
};

export type ProviderSortConfigUnion =
  | ProviderPreferencesProviderSortConfig
  | ProviderSortConfigEnum;

export const ProviderPreferencesProviderSort = {
  Price: "price",
  Throughput: "throughput",
  Latency: "latency",
} as const;
export type ProviderPreferencesProviderSort = OpenEnum<
  typeof ProviderPreferencesProviderSort
>;

/**
 * The sorting strategy to use for this request, if "order" is not specified. When set, no load balancing is performed.
 */
export type ProviderPreferencesSortUnion =
  | ProviderPreferencesProviderSort
  | ProviderPreferencesProviderSortConfig
  | ProviderSortConfigEnum
  | SortEnum;

/**
 * The object specifying the maximum price you want to pay for this request. USD price per million tokens, for prompt and completion.
 */
export type ProviderPreferencesMaxPrice = {
  /**
   * Price per million prompt tokens
   */
  prompt?: string | undefined;
  completion?: string | undefined;
  image?: string | undefined;
  audio?: string | undefined;
  request?: string | undefined;
};

/**
 * Provider routing preferences for the request.
 */
export type ProviderPreferences = {
  /**
   * Whether to allow backup providers to serve requests
   *
   * @remarks
   * - true: (default) when the primary provider (or your custom providers in "order") is unavailable, use the next best provider.
   * - false: use only the primary/custom provider, and return the upstream error if it's unavailable.
   */
  allowFallbacks?: boolean | null | undefined;
  /**
   * Whether to filter providers to only those that support the parameters you've provided. If this setting is omitted or set to false, then providers will receive only the parameters they support, and ignore the rest.
   */
  requireParameters?: boolean | null | undefined;
  /**
   * Data collection setting. If no available model provider meets the requirement, your request will return an error.
   *
   * @remarks
   * - allow: (default) allow providers which store user data non-transiently and may train on it
   *
   * - deny: use only providers which do not collect user data.
   */
  dataCollection?: DataCollection | null | undefined;
  /**
   * Whether to restrict routing to only ZDR (Zero Data Retention) endpoints. When true, only endpoints that do not retain prompts will be used.
   */
  zdr?: boolean | null | undefined;
  /**
   * Whether to restrict routing to only models that allow text distillation. When true, only models where the author has allowed distillation will be used.
   */
  enforceDistillableText?: boolean | null | undefined;
  /**
   * An ordered list of provider slugs. The router will attempt to use the first provider in the subset of this list that supports your requested model, and fall back to the next if it is unavailable. If no providers are available, the request will fail with an error message.
   */
  order?: Array<ProviderName | string> | null | undefined;
  /**
   * List of provider slugs to allow. If provided, this list is merged with your account-wide allowed provider settings for this request.
   */
  only?: Array<ProviderName | string> | null | undefined;
  /**
   * List of provider slugs to ignore. If provided, this list is merged with your account-wide ignored provider settings for this request.
   */
  ignore?: Array<ProviderName | string> | null | undefined;
  /**
   * A list of quantization levels to filter the provider by.
   */
  quantizations?: Array<Quantization> | null | undefined;
  sort?:
    | ProviderPreferencesProviderSort
    | ProviderPreferencesProviderSortConfig
    | ProviderSortConfigEnum
    | SortEnum
    | null
    | undefined;
  /**
   * The object specifying the maximum price you want to pay for this request. USD price per million tokens, for prompt and completion.
   */
  maxPrice?: ProviderPreferencesMaxPrice | undefined;
  /**
   * Preferred minimum throughput (in tokens per second). Can be a number (applies to p50) or an object with percentile-specific cutoffs. Endpoints below the threshold(s) may still be used, but are deprioritized in routing. When using fallback models, this may cause a fallback model to be used instead of the primary model if it meets the threshold.
   */
  preferredMinThroughput?: PreferredMinThroughput | null | undefined;
  /**
   * Preferred maximum latency (in seconds). Can be a number (applies to p50) or an object with percentile-specific cutoffs. Endpoints above the threshold(s) may still be used, but are deprioritized in routing. When using fallback models, this may cause a fallback model to be used instead of the primary model if it meets the threshold.
   */
  preferredMaxLatency?: PreferredMaxLatency | null | undefined;
};

/** @internal */
export type ProviderPreferencesOrder$Outbound = string | string;

/** @internal */
export const ProviderPreferencesOrder$outboundSchema: z.ZodType<
  ProviderPreferencesOrder$Outbound,
  ProviderPreferencesOrder
> = z.union([ProviderName$outboundSchema, z.string()]);

export function providerPreferencesOrderToJSON(
  providerPreferencesOrder: ProviderPreferencesOrder,
): string {
  return JSON.stringify(
    ProviderPreferencesOrder$outboundSchema.parse(providerPreferencesOrder),
  );
}

/** @internal */
export type ProviderPreferencesOnly$Outbound = string | string;

/** @internal */
export const ProviderPreferencesOnly$outboundSchema: z.ZodType<
  ProviderPreferencesOnly$Outbound,
  ProviderPreferencesOnly
> = z.union([ProviderName$outboundSchema, z.string()]);

export function providerPreferencesOnlyToJSON(
  providerPreferencesOnly: ProviderPreferencesOnly,
): string {
  return JSON.stringify(
    ProviderPreferencesOnly$outboundSchema.parse(providerPreferencesOnly),
  );
}

/** @internal */
export type ProviderPreferencesIgnore$Outbound = string | string;

/** @internal */
export const ProviderPreferencesIgnore$outboundSchema: z.ZodType<
  ProviderPreferencesIgnore$Outbound,
  ProviderPreferencesIgnore
> = z.union([ProviderName$outboundSchema, z.string()]);

export function providerPreferencesIgnoreToJSON(
  providerPreferencesIgnore: ProviderPreferencesIgnore,
): string {
  return JSON.stringify(
    ProviderPreferencesIgnore$outboundSchema.parse(providerPreferencesIgnore),
  );
}

/** @internal */
export const SortEnum$outboundSchema: z.ZodType<string, SortEnum> = openEnums
  .outboundSchema(SortEnum);

/** @internal */
export const ProviderSortConfigEnum$outboundSchema: z.ZodEnum<
  typeof ProviderSortConfigEnum
> = z.enum(ProviderSortConfigEnum);

/** @internal */
export const ProviderPreferencesPartition$outboundSchema: z.ZodType<
  string,
  ProviderPreferencesPartition
> = openEnums.outboundSchema(ProviderPreferencesPartition);

/** @internal */
export type ProviderPreferencesProviderSortConfig$Outbound = {
  by?: string | null | undefined;
  partition?: string | null | undefined;
};

/** @internal */
export const ProviderPreferencesProviderSortConfig$outboundSchema: z.ZodType<
  ProviderPreferencesProviderSortConfig$Outbound,
  ProviderPreferencesProviderSortConfig
> = z.object({
  by: z.nullable(ProviderSort$outboundSchema).optional(),
  partition: z.nullable(ProviderPreferencesPartition$outboundSchema).optional(),
});

export function providerPreferencesProviderSortConfigToJSON(
  providerPreferencesProviderSortConfig: ProviderPreferencesProviderSortConfig,
): string {
  return JSON.stringify(
    ProviderPreferencesProviderSortConfig$outboundSchema.parse(
      providerPreferencesProviderSortConfig,
    ),
  );
}

/** @internal */
export type ProviderSortConfigUnion$Outbound =
  | ProviderPreferencesProviderSortConfig$Outbound
  | string;

/** @internal */
export const ProviderSortConfigUnion$outboundSchema: z.ZodType<
  ProviderSortConfigUnion$Outbound,
  ProviderSortConfigUnion
> = z.union([
  z.lazy(() => ProviderPreferencesProviderSortConfig$outboundSchema),
  ProviderSortConfigEnum$outboundSchema,
]);

export function providerSortConfigUnionToJSON(
  providerSortConfigUnion: ProviderSortConfigUnion,
): string {
  return JSON.stringify(
    ProviderSortConfigUnion$outboundSchema.parse(providerSortConfigUnion),
  );
}

/** @internal */
export const ProviderPreferencesProviderSort$outboundSchema: z.ZodType<
  string,
  ProviderPreferencesProviderSort
> = openEnums.outboundSchema(ProviderPreferencesProviderSort);

/** @internal */
export type ProviderPreferencesSortUnion$Outbound =
  | string
  | ProviderPreferencesProviderSortConfig$Outbound
  | string
  | string;

/** @internal */
export const ProviderPreferencesSortUnion$outboundSchema: z.ZodType<
  ProviderPreferencesSortUnion$Outbound,
  ProviderPreferencesSortUnion
> = z.union([
  ProviderPreferencesProviderSort$outboundSchema,
  z.union([
    z.lazy(() => ProviderPreferencesProviderSortConfig$outboundSchema),
    ProviderSortConfigEnum$outboundSchema,
  ]),
  SortEnum$outboundSchema,
]);

export function providerPreferencesSortUnionToJSON(
  providerPreferencesSortUnion: ProviderPreferencesSortUnion,
): string {
  return JSON.stringify(
    ProviderPreferencesSortUnion$outboundSchema.parse(
      providerPreferencesSortUnion,
    ),
  );
}

/** @internal */
export type ProviderPreferencesMaxPrice$Outbound = {
  prompt?: string | undefined;
  completion?: string | undefined;
  image?: string | undefined;
  audio?: string | undefined;
  request?: string | undefined;
};

/** @internal */
export const ProviderPreferencesMaxPrice$outboundSchema: z.ZodType<
  ProviderPreferencesMaxPrice$Outbound,
  ProviderPreferencesMaxPrice
> = z.object({
  prompt: z.string().optional(),
  completion: z.string().optional(),
  image: z.string().optional(),
  audio: z.string().optional(),
  request: z.string().optional(),
});

export function providerPreferencesMaxPriceToJSON(
  providerPreferencesMaxPrice: ProviderPreferencesMaxPrice,
): string {
  return JSON.stringify(
    ProviderPreferencesMaxPrice$outboundSchema.parse(
      providerPreferencesMaxPrice,
    ),
  );
}

/** @internal */
export type ProviderPreferences$Outbound = {
  allow_fallbacks?: boolean | null | undefined;
  require_parameters?: boolean | null | undefined;
  data_collection?: string | null | undefined;
  zdr?: boolean | null | undefined;
  enforce_distillable_text?: boolean | null | undefined;
  order?: Array<string | string> | null | undefined;
  only?: Array<string | string> | null | undefined;
  ignore?: Array<string | string> | null | undefined;
  quantizations?: Array<string> | null | undefined;
  sort?:
    | string
    | ProviderPreferencesProviderSortConfig$Outbound
    | string
    | string
    | null
    | undefined;
  max_price?: ProviderPreferencesMaxPrice$Outbound | undefined;
  preferred_min_throughput?: PreferredMinThroughput$Outbound | null | undefined;
  preferred_max_latency?: PreferredMaxLatency$Outbound | null | undefined;
};

/** @internal */
export const ProviderPreferences$outboundSchema: z.ZodType<
  ProviderPreferences$Outbound,
  ProviderPreferences
> = z.object({
  allowFallbacks: z.nullable(z.boolean()).optional(),
  requireParameters: z.nullable(z.boolean()).optional(),
  dataCollection: z.nullable(DataCollection$outboundSchema).optional(),
  zdr: z.nullable(z.boolean()).optional(),
  enforceDistillableText: z.nullable(z.boolean()).optional(),
  order: z.nullable(z.array(z.union([ProviderName$outboundSchema, z.string()])))
    .optional(),
  only: z.nullable(z.array(z.union([ProviderName$outboundSchema, z.string()])))
    .optional(),
  ignore: z.nullable(
    z.array(z.union([ProviderName$outboundSchema, z.string()])),
  ).optional(),
  quantizations: z.nullable(z.array(Quantization$outboundSchema)).optional(),
  sort: z.nullable(
    z.union([
      ProviderPreferencesProviderSort$outboundSchema,
      z.union([
        z.lazy(() => ProviderPreferencesProviderSortConfig$outboundSchema),
        ProviderSortConfigEnum$outboundSchema,
      ]),
      SortEnum$outboundSchema,
    ]),
  ).optional(),
  maxPrice: z.lazy(() => ProviderPreferencesMaxPrice$outboundSchema).optional(),
  preferredMinThroughput: z.nullable(PreferredMinThroughput$outboundSchema)
    .optional(),
  preferredMaxLatency: z.nullable(PreferredMaxLatency$outboundSchema)
    .optional(),
}).transform((v) => {
  return remap$(v, {
    allowFallbacks: "allow_fallbacks",
    requireParameters: "require_parameters",
    dataCollection: "data_collection",
    enforceDistillableText: "enforce_distillable_text",
    maxPrice: "max_price",
    preferredMinThroughput: "preferred_min_throughput",
    preferredMaxLatency: "preferred_max_latency",
  });
});

export function providerPreferencesToJSON(
  providerPreferences: ProviderPreferences,
): string {
  return JSON.stringify(
    ProviderPreferences$outboundSchema.parse(providerPreferences),
  );
}
