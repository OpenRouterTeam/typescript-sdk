/*
 * Code generated by Speakeasy (https://speakeasy.com). DO NOT EDIT.
 */

import * as z from "zod";
import { remap as remap$ } from "../../lib/primitives.js";
import { safeParse } from "../../lib/schemas.js";
import { ClosedEnum } from "../../types/enums.js";
import { Result as SafeParseResult } from "../../types/fp.js";
import { SDKValidationError } from "../errors/sdkvalidationerror.js";

export type Input =
  | string
  | Array<string>
  | Array<number>
  | Array<Array<number>>;

/**
 * Data collection setting. If no available model provider meets the requirement, your request will return an error.
 *
 * @remarks
 * - allow: (default) allow providers which store user data non-transiently and may train on it
 * - deny: use only providers which do not collect user data.
 */
export const GenerateDataCollection = {
  Deny: "deny",
  Allow: "allow",
} as const;
/**
 * Data collection setting. If no available model provider meets the requirement, your request will return an error.
 *
 * @remarks
 * - allow: (default) allow providers which store user data non-transiently and may train on it
 * - deny: use only providers which do not collect user data.
 */
export type GenerateDataCollection = ClosedEnum<typeof GenerateDataCollection>;

export const GenerateOrderEnum = {
  AnyScale: "AnyScale",
  CentML: "Cent-ML",
  HuggingFace: "HuggingFace",
  Hyperbolic2: "Hyperbolic 2",
  Lepton: "Lepton",
  Lynn2: "Lynn 2",
  Lynn: "Lynn",
  Mancer: "Mancer",
  Modal: "Modal",
  OctoAI: "OctoAI",
  Recursal: "Recursal",
  Reflection: "Reflection",
  Replicate: "Replicate",
  SambaNova2: "SambaNova 2",
  SFCompute: "SF Compute",
  Together2: "Together 2",
  OneDotAI: "01.AI",
  Ai21: "AI21",
  AionLabs: "AionLabs",
  Alibaba: "Alibaba",
  AmazonBedrock: "Amazon Bedrock",
  Anthropic: "Anthropic",
  AtlasCloud: "AtlasCloud",
  Atoma: "Atoma",
  Avian: "Avian",
  Azure: "Azure",
  BaseTen: "BaseTen",
  Cerebras: "Cerebras",
  Chutes: "Chutes",
  Cloudflare: "Cloudflare",
  Cohere: "Cohere",
  CrofAI: "CrofAI",
  Crusoe: "Crusoe",
  DeepInfra: "DeepInfra",
  DeepSeek: "DeepSeek",
  Enfer: "Enfer",
  Featherless: "Featherless",
  Fireworks: "Fireworks",
  Friendli: "Friendli",
  GMICloud: "GMICloud",
  Google: "Google",
  GoogleAIStudio: "Google AI Studio",
  Groq: "Groq",
  Hyperbolic: "Hyperbolic",
  Inception: "Inception",
  InferenceNet: "InferenceNet",
  Infermatic: "Infermatic",
  Inflection: "Inflection",
  InoCloud: "InoCloud",
  Kluster: "Kluster",
  Lambda: "Lambda",
  Liquid: "Liquid",
  Mancer2: "Mancer 2",
  Meta: "Meta",
  Minimax: "Minimax",
  Mistral: "Mistral",
  MoonshotAI: "Moonshot AI",
  Morph: "Morph",
  NCompass: "NCompass",
  Nebius: "Nebius",
  NextBit: "NextBit",
  Nineteen: "Nineteen",
  Novita: "Novita",
  Nvidia: "Nvidia",
  OpenAI: "OpenAI",
  OpenInference: "OpenInference",
  Parasail: "Parasail",
  Perplexity: "Perplexity",
  Phala: "Phala",
  Relace: "Relace",
  SambaNova: "SambaNova",
  SiliconFlow: "SiliconFlow",
  Stealth: "Stealth",
  Switchpoint: "Switchpoint",
  Targon: "Targon",
  Together: "Together",
  Ubicloud: "Ubicloud",
  Venice: "Venice",
  WandB: "WandB",
  XAI: "xAI",
  ZAi: "Z.AI",
  FakeProvider: "FakeProvider",
} as const;
export type GenerateOrderEnum = ClosedEnum<typeof GenerateOrderEnum>;

export type GenerateOrderUnion = GenerateOrderEnum | string;

export const GenerateOnlyEnum = {
  AnyScale: "AnyScale",
  CentML: "Cent-ML",
  HuggingFace: "HuggingFace",
  Hyperbolic2: "Hyperbolic 2",
  Lepton: "Lepton",
  Lynn2: "Lynn 2",
  Lynn: "Lynn",
  Mancer: "Mancer",
  Modal: "Modal",
  OctoAI: "OctoAI",
  Recursal: "Recursal",
  Reflection: "Reflection",
  Replicate: "Replicate",
  SambaNova2: "SambaNova 2",
  SFCompute: "SF Compute",
  Together2: "Together 2",
  OneDotAI: "01.AI",
  Ai21: "AI21",
  AionLabs: "AionLabs",
  Alibaba: "Alibaba",
  AmazonBedrock: "Amazon Bedrock",
  Anthropic: "Anthropic",
  AtlasCloud: "AtlasCloud",
  Atoma: "Atoma",
  Avian: "Avian",
  Azure: "Azure",
  BaseTen: "BaseTen",
  Cerebras: "Cerebras",
  Chutes: "Chutes",
  Cloudflare: "Cloudflare",
  Cohere: "Cohere",
  CrofAI: "CrofAI",
  Crusoe: "Crusoe",
  DeepInfra: "DeepInfra",
  DeepSeek: "DeepSeek",
  Enfer: "Enfer",
  Featherless: "Featherless",
  Fireworks: "Fireworks",
  Friendli: "Friendli",
  GMICloud: "GMICloud",
  Google: "Google",
  GoogleAIStudio: "Google AI Studio",
  Groq: "Groq",
  Hyperbolic: "Hyperbolic",
  Inception: "Inception",
  InferenceNet: "InferenceNet",
  Infermatic: "Infermatic",
  Inflection: "Inflection",
  InoCloud: "InoCloud",
  Kluster: "Kluster",
  Lambda: "Lambda",
  Liquid: "Liquid",
  Mancer2: "Mancer 2",
  Meta: "Meta",
  Minimax: "Minimax",
  Mistral: "Mistral",
  MoonshotAI: "Moonshot AI",
  Morph: "Morph",
  NCompass: "NCompass",
  Nebius: "Nebius",
  NextBit: "NextBit",
  Nineteen: "Nineteen",
  Novita: "Novita",
  Nvidia: "Nvidia",
  OpenAI: "OpenAI",
  OpenInference: "OpenInference",
  Parasail: "Parasail",
  Perplexity: "Perplexity",
  Phala: "Phala",
  Relace: "Relace",
  SambaNova: "SambaNova",
  SiliconFlow: "SiliconFlow",
  Stealth: "Stealth",
  Switchpoint: "Switchpoint",
  Targon: "Targon",
  Together: "Together",
  Ubicloud: "Ubicloud",
  Venice: "Venice",
  WandB: "WandB",
  XAI: "xAI",
  ZAi: "Z.AI",
  FakeProvider: "FakeProvider",
} as const;
export type GenerateOnlyEnum = ClosedEnum<typeof GenerateOnlyEnum>;

export type GenerateOnlyUnion = GenerateOnlyEnum | string;

export const GenerateIgnoreEnum = {
  AnyScale: "AnyScale",
  CentML: "Cent-ML",
  HuggingFace: "HuggingFace",
  Hyperbolic2: "Hyperbolic 2",
  Lepton: "Lepton",
  Lynn2: "Lynn 2",
  Lynn: "Lynn",
  Mancer: "Mancer",
  Modal: "Modal",
  OctoAI: "OctoAI",
  Recursal: "Recursal",
  Reflection: "Reflection",
  Replicate: "Replicate",
  SambaNova2: "SambaNova 2",
  SFCompute: "SF Compute",
  Together2: "Together 2",
  OneDotAI: "01.AI",
  Ai21: "AI21",
  AionLabs: "AionLabs",
  Alibaba: "Alibaba",
  AmazonBedrock: "Amazon Bedrock",
  Anthropic: "Anthropic",
  AtlasCloud: "AtlasCloud",
  Atoma: "Atoma",
  Avian: "Avian",
  Azure: "Azure",
  BaseTen: "BaseTen",
  Cerebras: "Cerebras",
  Chutes: "Chutes",
  Cloudflare: "Cloudflare",
  Cohere: "Cohere",
  CrofAI: "CrofAI",
  Crusoe: "Crusoe",
  DeepInfra: "DeepInfra",
  DeepSeek: "DeepSeek",
  Enfer: "Enfer",
  Featherless: "Featherless",
  Fireworks: "Fireworks",
  Friendli: "Friendli",
  GMICloud: "GMICloud",
  Google: "Google",
  GoogleAIStudio: "Google AI Studio",
  Groq: "Groq",
  Hyperbolic: "Hyperbolic",
  Inception: "Inception",
  InferenceNet: "InferenceNet",
  Infermatic: "Infermatic",
  Inflection: "Inflection",
  InoCloud: "InoCloud",
  Kluster: "Kluster",
  Lambda: "Lambda",
  Liquid: "Liquid",
  Mancer2: "Mancer 2",
  Meta: "Meta",
  Minimax: "Minimax",
  Mistral: "Mistral",
  MoonshotAI: "Moonshot AI",
  Morph: "Morph",
  NCompass: "NCompass",
  Nebius: "Nebius",
  NextBit: "NextBit",
  Nineteen: "Nineteen",
  Novita: "Novita",
  Nvidia: "Nvidia",
  OpenAI: "OpenAI",
  OpenInference: "OpenInference",
  Parasail: "Parasail",
  Perplexity: "Perplexity",
  Phala: "Phala",
  Relace: "Relace",
  SambaNova: "SambaNova",
  SiliconFlow: "SiliconFlow",
  Stealth: "Stealth",
  Switchpoint: "Switchpoint",
  Targon: "Targon",
  Together: "Together",
  Ubicloud: "Ubicloud",
  Venice: "Venice",
  WandB: "WandB",
  XAI: "xAI",
  ZAi: "Z.AI",
  FakeProvider: "FakeProvider",
} as const;
export type GenerateIgnoreEnum = ClosedEnum<typeof GenerateIgnoreEnum>;

export type GenerateIgnoreUnion = GenerateIgnoreEnum | string;

export const GenerateQuantization = {
  Int4: "int4",
  Int8: "int8",
  Fp4: "fp4",
  Fp6: "fp6",
  Fp8: "fp8",
  Fp16: "fp16",
  Bf16: "bf16",
  Fp32: "fp32",
  Unknown: "unknown",
} as const;
export type GenerateQuantization = ClosedEnum<typeof GenerateQuantization>;

/**
 * The sorting strategy to use for this request, if "order" is not specified. When set, no load balancing is performed.
 */
export const GenerateSort = {
  Price: "price",
  Throughput: "throughput",
  Latency: "latency",
} as const;
/**
 * The sorting strategy to use for this request, if "order" is not specified. When set, no load balancing is performed.
 */
export type GenerateSort = ClosedEnum<typeof GenerateSort>;

export type GeneratePrompt = number | string | any;

export type GenerateCompletion = number | string | any;

export type GenerateImage = number | string | any;

export type GenerateAudio = number | string | any;

export type GenerateRequestUnion = number | string | any;

/**
 * The object specifying the maximum price you want to pay for this request. USD price per million tokens, for prompt and completion.
 */
export type GenerateMaxPrice = {
  prompt?: number | string | any | undefined;
  completion?: number | string | any | undefined;
  image?: number | string | any | undefined;
  audio?: number | string | any | undefined;
  request?: number | string | any | undefined;
};

export type GenerateExperimental = {};

export type GenerateProvider = {
  /**
   * Whether to allow backup providers to serve requests
   *
   * @remarks
   * - true: (default) when the primary provider (or your custom providers in "order") is unavailable, use the next best provider.
   * - false: use only the primary/custom provider, and return the upstream error if it's unavailable.
   */
  allowFallbacks?: boolean | null | undefined;
  /**
   * Whether to filter providers to only those that support the parameters you've provided. If this setting is omitted or set to false, then providers will receive only the parameters they support, and ignore the rest.
   */
  requireParameters?: boolean | null | undefined;
  /**
   * Data collection setting. If no available model provider meets the requirement, your request will return an error.
   *
   * @remarks
   * - allow: (default) allow providers which store user data non-transiently and may train on it
   * - deny: use only providers which do not collect user data.
   */
  dataCollection?: GenerateDataCollection | null | undefined;
  /**
   * Whether to restrict routing to only ZDR (Zero Data Retention) endpoints. When true, only endpoints that do not retain prompts will be used.
   */
  zdr?: boolean | null | undefined;
  /**
   * An ordered list of provider slugs. The router will attempt to use the first provider in the subset of this list that supports your requested model, and fall back to the next if it is unavailable. If no providers are available, the request will fail with an error message.
   */
  order?: Array<GenerateOrderEnum | string> | null | undefined;
  /**
   * List of provider slugs to allow. If provided, this list is merged with your account-wide allowed provider settings for this request.
   */
  only?: Array<GenerateOnlyEnum | string> | null | undefined;
  /**
   * List of provider slugs to ignore. If provided, this list is merged with your account-wide ignored provider settings for this request.
   */
  ignore?: Array<GenerateIgnoreEnum | string> | null | undefined;
  /**
   * A list of quantization levels to filter the provider by.
   */
  quantizations?: Array<GenerateQuantization> | null | undefined;
  /**
   * The sorting strategy to use for this request, if "order" is not specified. When set, no load balancing is performed.
   */
  sort?: GenerateSort | null | undefined;
  /**
   * The object specifying the maximum price you want to pay for this request. USD price per million tokens, for prompt and completion.
   */
  maxPrice?: GenerateMaxPrice | undefined;
  experimental?: GenerateExperimental | null | undefined;
};

export const EncodingFormatBase64 = {
  Base64: "base64",
} as const;
export type EncodingFormatBase64 = ClosedEnum<typeof EncodingFormatBase64>;

export const EncodingFormatFloat = {
  Float: "float",
} as const;
export type EncodingFormatFloat = ClosedEnum<typeof EncodingFormatFloat>;

export type EncodingFormat = EncodingFormatFloat | EncodingFormatBase64;

export type GenerateRequest = {
  input: string | Array<string> | Array<number> | Array<Array<number>>;
  model?: string | undefined;
  models?: Array<string> | undefined;
  provider?: GenerateProvider | undefined;
  encodingFormat?: EncodingFormatFloat | EncodingFormatBase64 | undefined;
  user?: string | undefined;
};

export const ObjectT = {
  List: "list",
} as const;
export type ObjectT = ClosedEnum<typeof ObjectT>;

export const ObjectEmbedding = {
  Embedding: "embedding",
} as const;
export type ObjectEmbedding = ClosedEnum<typeof ObjectEmbedding>;

export type GenerateData = {
  object: ObjectEmbedding;
  embedding: Array<number>;
  index: number;
};

export type Usage = {
  promptTokens: number;
  totalTokens: number;
  cost?: number | undefined;
};

/**
 * Embedding response
 */
export type GenerateResponse = {
  object: ObjectT;
  data: Array<GenerateData>;
  model: string;
  usage?: Usage | undefined;
};

/** @internal */
export const Input$inboundSchema: z.ZodType<Input, z.ZodTypeDef, unknown> = z
  .union([
    z.string(),
    z.array(z.string()),
    z.array(z.number()),
    z.array(z.array(z.number())),
  ]);

/** @internal */
export type Input$Outbound =
  | string
  | Array<string>
  | Array<number>
  | Array<Array<number>>;

/** @internal */
export const Input$outboundSchema: z.ZodType<
  Input$Outbound,
  z.ZodTypeDef,
  Input
> = z.union([
  z.string(),
  z.array(z.string()),
  z.array(z.number()),
  z.array(z.array(z.number())),
]);

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace Input$ {
  /** @deprecated use `Input$inboundSchema` instead. */
  export const inboundSchema = Input$inboundSchema;
  /** @deprecated use `Input$outboundSchema` instead. */
  export const outboundSchema = Input$outboundSchema;
  /** @deprecated use `Input$Outbound` instead. */
  export type Outbound = Input$Outbound;
}

export function inputToJSON(input: Input): string {
  return JSON.stringify(Input$outboundSchema.parse(input));
}

export function inputFromJSON(
  jsonString: string,
): SafeParseResult<Input, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => Input$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'Input' from JSON`,
  );
}

/** @internal */
export const GenerateDataCollection$inboundSchema: z.ZodNativeEnum<
  typeof GenerateDataCollection
> = z.nativeEnum(GenerateDataCollection);

/** @internal */
export const GenerateDataCollection$outboundSchema: z.ZodNativeEnum<
  typeof GenerateDataCollection
> = GenerateDataCollection$inboundSchema;

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace GenerateDataCollection$ {
  /** @deprecated use `GenerateDataCollection$inboundSchema` instead. */
  export const inboundSchema = GenerateDataCollection$inboundSchema;
  /** @deprecated use `GenerateDataCollection$outboundSchema` instead. */
  export const outboundSchema = GenerateDataCollection$outboundSchema;
}

/** @internal */
export const GenerateOrderEnum$inboundSchema: z.ZodNativeEnum<
  typeof GenerateOrderEnum
> = z.nativeEnum(GenerateOrderEnum);

/** @internal */
export const GenerateOrderEnum$outboundSchema: z.ZodNativeEnum<
  typeof GenerateOrderEnum
> = GenerateOrderEnum$inboundSchema;

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace GenerateOrderEnum$ {
  /** @deprecated use `GenerateOrderEnum$inboundSchema` instead. */
  export const inboundSchema = GenerateOrderEnum$inboundSchema;
  /** @deprecated use `GenerateOrderEnum$outboundSchema` instead. */
  export const outboundSchema = GenerateOrderEnum$outboundSchema;
}

/** @internal */
export const GenerateOrderUnion$inboundSchema: z.ZodType<
  GenerateOrderUnion,
  z.ZodTypeDef,
  unknown
> = z.union([GenerateOrderEnum$inboundSchema, z.string()]);

/** @internal */
export type GenerateOrderUnion$Outbound = string | string;

/** @internal */
export const GenerateOrderUnion$outboundSchema: z.ZodType<
  GenerateOrderUnion$Outbound,
  z.ZodTypeDef,
  GenerateOrderUnion
> = z.union([GenerateOrderEnum$outboundSchema, z.string()]);

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace GenerateOrderUnion$ {
  /** @deprecated use `GenerateOrderUnion$inboundSchema` instead. */
  export const inboundSchema = GenerateOrderUnion$inboundSchema;
  /** @deprecated use `GenerateOrderUnion$outboundSchema` instead. */
  export const outboundSchema = GenerateOrderUnion$outboundSchema;
  /** @deprecated use `GenerateOrderUnion$Outbound` instead. */
  export type Outbound = GenerateOrderUnion$Outbound;
}

export function generateOrderUnionToJSON(
  generateOrderUnion: GenerateOrderUnion,
): string {
  return JSON.stringify(
    GenerateOrderUnion$outboundSchema.parse(generateOrderUnion),
  );
}

export function generateOrderUnionFromJSON(
  jsonString: string,
): SafeParseResult<GenerateOrderUnion, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => GenerateOrderUnion$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'GenerateOrderUnion' from JSON`,
  );
}

/** @internal */
export const GenerateOnlyEnum$inboundSchema: z.ZodNativeEnum<
  typeof GenerateOnlyEnum
> = z.nativeEnum(GenerateOnlyEnum);

/** @internal */
export const GenerateOnlyEnum$outboundSchema: z.ZodNativeEnum<
  typeof GenerateOnlyEnum
> = GenerateOnlyEnum$inboundSchema;

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace GenerateOnlyEnum$ {
  /** @deprecated use `GenerateOnlyEnum$inboundSchema` instead. */
  export const inboundSchema = GenerateOnlyEnum$inboundSchema;
  /** @deprecated use `GenerateOnlyEnum$outboundSchema` instead. */
  export const outboundSchema = GenerateOnlyEnum$outboundSchema;
}

/** @internal */
export const GenerateOnlyUnion$inboundSchema: z.ZodType<
  GenerateOnlyUnion,
  z.ZodTypeDef,
  unknown
> = z.union([GenerateOnlyEnum$inboundSchema, z.string()]);

/** @internal */
export type GenerateOnlyUnion$Outbound = string | string;

/** @internal */
export const GenerateOnlyUnion$outboundSchema: z.ZodType<
  GenerateOnlyUnion$Outbound,
  z.ZodTypeDef,
  GenerateOnlyUnion
> = z.union([GenerateOnlyEnum$outboundSchema, z.string()]);

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace GenerateOnlyUnion$ {
  /** @deprecated use `GenerateOnlyUnion$inboundSchema` instead. */
  export const inboundSchema = GenerateOnlyUnion$inboundSchema;
  /** @deprecated use `GenerateOnlyUnion$outboundSchema` instead. */
  export const outboundSchema = GenerateOnlyUnion$outboundSchema;
  /** @deprecated use `GenerateOnlyUnion$Outbound` instead. */
  export type Outbound = GenerateOnlyUnion$Outbound;
}

export function generateOnlyUnionToJSON(
  generateOnlyUnion: GenerateOnlyUnion,
): string {
  return JSON.stringify(
    GenerateOnlyUnion$outboundSchema.parse(generateOnlyUnion),
  );
}

export function generateOnlyUnionFromJSON(
  jsonString: string,
): SafeParseResult<GenerateOnlyUnion, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => GenerateOnlyUnion$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'GenerateOnlyUnion' from JSON`,
  );
}

/** @internal */
export const GenerateIgnoreEnum$inboundSchema: z.ZodNativeEnum<
  typeof GenerateIgnoreEnum
> = z.nativeEnum(GenerateIgnoreEnum);

/** @internal */
export const GenerateIgnoreEnum$outboundSchema: z.ZodNativeEnum<
  typeof GenerateIgnoreEnum
> = GenerateIgnoreEnum$inboundSchema;

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace GenerateIgnoreEnum$ {
  /** @deprecated use `GenerateIgnoreEnum$inboundSchema` instead. */
  export const inboundSchema = GenerateIgnoreEnum$inboundSchema;
  /** @deprecated use `GenerateIgnoreEnum$outboundSchema` instead. */
  export const outboundSchema = GenerateIgnoreEnum$outboundSchema;
}

/** @internal */
export const GenerateIgnoreUnion$inboundSchema: z.ZodType<
  GenerateIgnoreUnion,
  z.ZodTypeDef,
  unknown
> = z.union([GenerateIgnoreEnum$inboundSchema, z.string()]);

/** @internal */
export type GenerateIgnoreUnion$Outbound = string | string;

/** @internal */
export const GenerateIgnoreUnion$outboundSchema: z.ZodType<
  GenerateIgnoreUnion$Outbound,
  z.ZodTypeDef,
  GenerateIgnoreUnion
> = z.union([GenerateIgnoreEnum$outboundSchema, z.string()]);

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace GenerateIgnoreUnion$ {
  /** @deprecated use `GenerateIgnoreUnion$inboundSchema` instead. */
  export const inboundSchema = GenerateIgnoreUnion$inboundSchema;
  /** @deprecated use `GenerateIgnoreUnion$outboundSchema` instead. */
  export const outboundSchema = GenerateIgnoreUnion$outboundSchema;
  /** @deprecated use `GenerateIgnoreUnion$Outbound` instead. */
  export type Outbound = GenerateIgnoreUnion$Outbound;
}

export function generateIgnoreUnionToJSON(
  generateIgnoreUnion: GenerateIgnoreUnion,
): string {
  return JSON.stringify(
    GenerateIgnoreUnion$outboundSchema.parse(generateIgnoreUnion),
  );
}

export function generateIgnoreUnionFromJSON(
  jsonString: string,
): SafeParseResult<GenerateIgnoreUnion, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => GenerateIgnoreUnion$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'GenerateIgnoreUnion' from JSON`,
  );
}

/** @internal */
export const GenerateQuantization$inboundSchema: z.ZodNativeEnum<
  typeof GenerateQuantization
> = z.nativeEnum(GenerateQuantization);

/** @internal */
export const GenerateQuantization$outboundSchema: z.ZodNativeEnum<
  typeof GenerateQuantization
> = GenerateQuantization$inboundSchema;

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace GenerateQuantization$ {
  /** @deprecated use `GenerateQuantization$inboundSchema` instead. */
  export const inboundSchema = GenerateQuantization$inboundSchema;
  /** @deprecated use `GenerateQuantization$outboundSchema` instead. */
  export const outboundSchema = GenerateQuantization$outboundSchema;
}

/** @internal */
export const GenerateSort$inboundSchema: z.ZodNativeEnum<typeof GenerateSort> =
  z.nativeEnum(GenerateSort);

/** @internal */
export const GenerateSort$outboundSchema: z.ZodNativeEnum<typeof GenerateSort> =
  GenerateSort$inboundSchema;

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace GenerateSort$ {
  /** @deprecated use `GenerateSort$inboundSchema` instead. */
  export const inboundSchema = GenerateSort$inboundSchema;
  /** @deprecated use `GenerateSort$outboundSchema` instead. */
  export const outboundSchema = GenerateSort$outboundSchema;
}

/** @internal */
export const GeneratePrompt$inboundSchema: z.ZodType<
  GeneratePrompt,
  z.ZodTypeDef,
  unknown
> = z.union([z.number(), z.string(), z.any()]);

/** @internal */
export type GeneratePrompt$Outbound = number | string | any;

/** @internal */
export const GeneratePrompt$outboundSchema: z.ZodType<
  GeneratePrompt$Outbound,
  z.ZodTypeDef,
  GeneratePrompt
> = z.union([z.number(), z.string(), z.any()]);

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace GeneratePrompt$ {
  /** @deprecated use `GeneratePrompt$inboundSchema` instead. */
  export const inboundSchema = GeneratePrompt$inboundSchema;
  /** @deprecated use `GeneratePrompt$outboundSchema` instead. */
  export const outboundSchema = GeneratePrompt$outboundSchema;
  /** @deprecated use `GeneratePrompt$Outbound` instead. */
  export type Outbound = GeneratePrompt$Outbound;
}

export function generatePromptToJSON(generatePrompt: GeneratePrompt): string {
  return JSON.stringify(GeneratePrompt$outboundSchema.parse(generatePrompt));
}

export function generatePromptFromJSON(
  jsonString: string,
): SafeParseResult<GeneratePrompt, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => GeneratePrompt$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'GeneratePrompt' from JSON`,
  );
}

/** @internal */
export const GenerateCompletion$inboundSchema: z.ZodType<
  GenerateCompletion,
  z.ZodTypeDef,
  unknown
> = z.union([z.number(), z.string(), z.any()]);

/** @internal */
export type GenerateCompletion$Outbound = number | string | any;

/** @internal */
export const GenerateCompletion$outboundSchema: z.ZodType<
  GenerateCompletion$Outbound,
  z.ZodTypeDef,
  GenerateCompletion
> = z.union([z.number(), z.string(), z.any()]);

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace GenerateCompletion$ {
  /** @deprecated use `GenerateCompletion$inboundSchema` instead. */
  export const inboundSchema = GenerateCompletion$inboundSchema;
  /** @deprecated use `GenerateCompletion$outboundSchema` instead. */
  export const outboundSchema = GenerateCompletion$outboundSchema;
  /** @deprecated use `GenerateCompletion$Outbound` instead. */
  export type Outbound = GenerateCompletion$Outbound;
}

export function generateCompletionToJSON(
  generateCompletion: GenerateCompletion,
): string {
  return JSON.stringify(
    GenerateCompletion$outboundSchema.parse(generateCompletion),
  );
}

export function generateCompletionFromJSON(
  jsonString: string,
): SafeParseResult<GenerateCompletion, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => GenerateCompletion$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'GenerateCompletion' from JSON`,
  );
}

/** @internal */
export const GenerateImage$inboundSchema: z.ZodType<
  GenerateImage,
  z.ZodTypeDef,
  unknown
> = z.union([z.number(), z.string(), z.any()]);

/** @internal */
export type GenerateImage$Outbound = number | string | any;

/** @internal */
export const GenerateImage$outboundSchema: z.ZodType<
  GenerateImage$Outbound,
  z.ZodTypeDef,
  GenerateImage
> = z.union([z.number(), z.string(), z.any()]);

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace GenerateImage$ {
  /** @deprecated use `GenerateImage$inboundSchema` instead. */
  export const inboundSchema = GenerateImage$inboundSchema;
  /** @deprecated use `GenerateImage$outboundSchema` instead. */
  export const outboundSchema = GenerateImage$outboundSchema;
  /** @deprecated use `GenerateImage$Outbound` instead. */
  export type Outbound = GenerateImage$Outbound;
}

export function generateImageToJSON(generateImage: GenerateImage): string {
  return JSON.stringify(GenerateImage$outboundSchema.parse(generateImage));
}

export function generateImageFromJSON(
  jsonString: string,
): SafeParseResult<GenerateImage, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => GenerateImage$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'GenerateImage' from JSON`,
  );
}

/** @internal */
export const GenerateAudio$inboundSchema: z.ZodType<
  GenerateAudio,
  z.ZodTypeDef,
  unknown
> = z.union([z.number(), z.string(), z.any()]);

/** @internal */
export type GenerateAudio$Outbound = number | string | any;

/** @internal */
export const GenerateAudio$outboundSchema: z.ZodType<
  GenerateAudio$Outbound,
  z.ZodTypeDef,
  GenerateAudio
> = z.union([z.number(), z.string(), z.any()]);

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace GenerateAudio$ {
  /** @deprecated use `GenerateAudio$inboundSchema` instead. */
  export const inboundSchema = GenerateAudio$inboundSchema;
  /** @deprecated use `GenerateAudio$outboundSchema` instead. */
  export const outboundSchema = GenerateAudio$outboundSchema;
  /** @deprecated use `GenerateAudio$Outbound` instead. */
  export type Outbound = GenerateAudio$Outbound;
}

export function generateAudioToJSON(generateAudio: GenerateAudio): string {
  return JSON.stringify(GenerateAudio$outboundSchema.parse(generateAudio));
}

export function generateAudioFromJSON(
  jsonString: string,
): SafeParseResult<GenerateAudio, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => GenerateAudio$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'GenerateAudio' from JSON`,
  );
}

/** @internal */
export const GenerateRequestUnion$inboundSchema: z.ZodType<
  GenerateRequestUnion,
  z.ZodTypeDef,
  unknown
> = z.union([z.number(), z.string(), z.any()]);

/** @internal */
export type GenerateRequestUnion$Outbound = number | string | any;

/** @internal */
export const GenerateRequestUnion$outboundSchema: z.ZodType<
  GenerateRequestUnion$Outbound,
  z.ZodTypeDef,
  GenerateRequestUnion
> = z.union([z.number(), z.string(), z.any()]);

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace GenerateRequestUnion$ {
  /** @deprecated use `GenerateRequestUnion$inboundSchema` instead. */
  export const inboundSchema = GenerateRequestUnion$inboundSchema;
  /** @deprecated use `GenerateRequestUnion$outboundSchema` instead. */
  export const outboundSchema = GenerateRequestUnion$outboundSchema;
  /** @deprecated use `GenerateRequestUnion$Outbound` instead. */
  export type Outbound = GenerateRequestUnion$Outbound;
}

export function generateRequestUnionToJSON(
  generateRequestUnion: GenerateRequestUnion,
): string {
  return JSON.stringify(
    GenerateRequestUnion$outboundSchema.parse(generateRequestUnion),
  );
}

export function generateRequestUnionFromJSON(
  jsonString: string,
): SafeParseResult<GenerateRequestUnion, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => GenerateRequestUnion$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'GenerateRequestUnion' from JSON`,
  );
}

/** @internal */
export const GenerateMaxPrice$inboundSchema: z.ZodType<
  GenerateMaxPrice,
  z.ZodTypeDef,
  unknown
> = z.object({
  prompt: z.union([z.number(), z.string(), z.any()]).optional(),
  completion: z.union([z.number(), z.string(), z.any()]).optional(),
  image: z.union([z.number(), z.string(), z.any()]).optional(),
  audio: z.union([z.number(), z.string(), z.any()]).optional(),
  request: z.union([z.number(), z.string(), z.any()]).optional(),
});

/** @internal */
export type GenerateMaxPrice$Outbound = {
  prompt?: number | string | any | undefined;
  completion?: number | string | any | undefined;
  image?: number | string | any | undefined;
  audio?: number | string | any | undefined;
  request?: number | string | any | undefined;
};

/** @internal */
export const GenerateMaxPrice$outboundSchema: z.ZodType<
  GenerateMaxPrice$Outbound,
  z.ZodTypeDef,
  GenerateMaxPrice
> = z.object({
  prompt: z.union([z.number(), z.string(), z.any()]).optional(),
  completion: z.union([z.number(), z.string(), z.any()]).optional(),
  image: z.union([z.number(), z.string(), z.any()]).optional(),
  audio: z.union([z.number(), z.string(), z.any()]).optional(),
  request: z.union([z.number(), z.string(), z.any()]).optional(),
});

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace GenerateMaxPrice$ {
  /** @deprecated use `GenerateMaxPrice$inboundSchema` instead. */
  export const inboundSchema = GenerateMaxPrice$inboundSchema;
  /** @deprecated use `GenerateMaxPrice$outboundSchema` instead. */
  export const outboundSchema = GenerateMaxPrice$outboundSchema;
  /** @deprecated use `GenerateMaxPrice$Outbound` instead. */
  export type Outbound = GenerateMaxPrice$Outbound;
}

export function generateMaxPriceToJSON(
  generateMaxPrice: GenerateMaxPrice,
): string {
  return JSON.stringify(
    GenerateMaxPrice$outboundSchema.parse(generateMaxPrice),
  );
}

export function generateMaxPriceFromJSON(
  jsonString: string,
): SafeParseResult<GenerateMaxPrice, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => GenerateMaxPrice$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'GenerateMaxPrice' from JSON`,
  );
}

/** @internal */
export const GenerateExperimental$inboundSchema: z.ZodType<
  GenerateExperimental,
  z.ZodTypeDef,
  unknown
> = z.object({});

/** @internal */
export type GenerateExperimental$Outbound = {};

/** @internal */
export const GenerateExperimental$outboundSchema: z.ZodType<
  GenerateExperimental$Outbound,
  z.ZodTypeDef,
  GenerateExperimental
> = z.object({});

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace GenerateExperimental$ {
  /** @deprecated use `GenerateExperimental$inboundSchema` instead. */
  export const inboundSchema = GenerateExperimental$inboundSchema;
  /** @deprecated use `GenerateExperimental$outboundSchema` instead. */
  export const outboundSchema = GenerateExperimental$outboundSchema;
  /** @deprecated use `GenerateExperimental$Outbound` instead. */
  export type Outbound = GenerateExperimental$Outbound;
}

export function generateExperimentalToJSON(
  generateExperimental: GenerateExperimental,
): string {
  return JSON.stringify(
    GenerateExperimental$outboundSchema.parse(generateExperimental),
  );
}

export function generateExperimentalFromJSON(
  jsonString: string,
): SafeParseResult<GenerateExperimental, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => GenerateExperimental$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'GenerateExperimental' from JSON`,
  );
}

/** @internal */
export const GenerateProvider$inboundSchema: z.ZodType<
  GenerateProvider,
  z.ZodTypeDef,
  unknown
> = z.object({
  allow_fallbacks: z.nullable(z.boolean()).optional(),
  require_parameters: z.nullable(z.boolean()).optional(),
  data_collection: z.nullable(GenerateDataCollection$inboundSchema).optional(),
  zdr: z.nullable(z.boolean()).optional(),
  order: z.nullable(
    z.array(z.union([GenerateOrderEnum$inboundSchema, z.string()])),
  ).optional(),
  only: z.nullable(
    z.array(z.union([GenerateOnlyEnum$inboundSchema, z.string()])),
  ).optional(),
  ignore: z.nullable(
    z.array(z.union([GenerateIgnoreEnum$inboundSchema, z.string()])),
  ).optional(),
  quantizations: z.nullable(z.array(GenerateQuantization$inboundSchema))
    .optional(),
  sort: z.nullable(GenerateSort$inboundSchema).optional(),
  max_price: z.lazy(() => GenerateMaxPrice$inboundSchema).optional(),
  experimental: z.nullable(z.lazy(() => GenerateExperimental$inboundSchema))
    .optional(),
}).transform((v) => {
  return remap$(v, {
    "allow_fallbacks": "allowFallbacks",
    "require_parameters": "requireParameters",
    "data_collection": "dataCollection",
    "max_price": "maxPrice",
  });
});

/** @internal */
export type GenerateProvider$Outbound = {
  allow_fallbacks?: boolean | null | undefined;
  require_parameters?: boolean | null | undefined;
  data_collection?: string | null | undefined;
  zdr?: boolean | null | undefined;
  order?: Array<string | string> | null | undefined;
  only?: Array<string | string> | null | undefined;
  ignore?: Array<string | string> | null | undefined;
  quantizations?: Array<string> | null | undefined;
  sort?: string | null | undefined;
  max_price?: GenerateMaxPrice$Outbound | undefined;
  experimental?: GenerateExperimental$Outbound | null | undefined;
};

/** @internal */
export const GenerateProvider$outboundSchema: z.ZodType<
  GenerateProvider$Outbound,
  z.ZodTypeDef,
  GenerateProvider
> = z.object({
  allowFallbacks: z.nullable(z.boolean()).optional(),
  requireParameters: z.nullable(z.boolean()).optional(),
  dataCollection: z.nullable(GenerateDataCollection$outboundSchema).optional(),
  zdr: z.nullable(z.boolean()).optional(),
  order: z.nullable(
    z.array(z.union([GenerateOrderEnum$outboundSchema, z.string()])),
  ).optional(),
  only: z.nullable(
    z.array(z.union([GenerateOnlyEnum$outboundSchema, z.string()])),
  ).optional(),
  ignore: z.nullable(
    z.array(z.union([GenerateIgnoreEnum$outboundSchema, z.string()])),
  ).optional(),
  quantizations: z.nullable(z.array(GenerateQuantization$outboundSchema))
    .optional(),
  sort: z.nullable(GenerateSort$outboundSchema).optional(),
  maxPrice: z.lazy(() => GenerateMaxPrice$outboundSchema).optional(),
  experimental: z.nullable(z.lazy(() => GenerateExperimental$outboundSchema))
    .optional(),
}).transform((v) => {
  return remap$(v, {
    allowFallbacks: "allow_fallbacks",
    requireParameters: "require_parameters",
    dataCollection: "data_collection",
    maxPrice: "max_price",
  });
});

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace GenerateProvider$ {
  /** @deprecated use `GenerateProvider$inboundSchema` instead. */
  export const inboundSchema = GenerateProvider$inboundSchema;
  /** @deprecated use `GenerateProvider$outboundSchema` instead. */
  export const outboundSchema = GenerateProvider$outboundSchema;
  /** @deprecated use `GenerateProvider$Outbound` instead. */
  export type Outbound = GenerateProvider$Outbound;
}

export function generateProviderToJSON(
  generateProvider: GenerateProvider,
): string {
  return JSON.stringify(
    GenerateProvider$outboundSchema.parse(generateProvider),
  );
}

export function generateProviderFromJSON(
  jsonString: string,
): SafeParseResult<GenerateProvider, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => GenerateProvider$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'GenerateProvider' from JSON`,
  );
}

/** @internal */
export const EncodingFormatBase64$inboundSchema: z.ZodNativeEnum<
  typeof EncodingFormatBase64
> = z.nativeEnum(EncodingFormatBase64);

/** @internal */
export const EncodingFormatBase64$outboundSchema: z.ZodNativeEnum<
  typeof EncodingFormatBase64
> = EncodingFormatBase64$inboundSchema;

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace EncodingFormatBase64$ {
  /** @deprecated use `EncodingFormatBase64$inboundSchema` instead. */
  export const inboundSchema = EncodingFormatBase64$inboundSchema;
  /** @deprecated use `EncodingFormatBase64$outboundSchema` instead. */
  export const outboundSchema = EncodingFormatBase64$outboundSchema;
}

/** @internal */
export const EncodingFormatFloat$inboundSchema: z.ZodNativeEnum<
  typeof EncodingFormatFloat
> = z.nativeEnum(EncodingFormatFloat);

/** @internal */
export const EncodingFormatFloat$outboundSchema: z.ZodNativeEnum<
  typeof EncodingFormatFloat
> = EncodingFormatFloat$inboundSchema;

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace EncodingFormatFloat$ {
  /** @deprecated use `EncodingFormatFloat$inboundSchema` instead. */
  export const inboundSchema = EncodingFormatFloat$inboundSchema;
  /** @deprecated use `EncodingFormatFloat$outboundSchema` instead. */
  export const outboundSchema = EncodingFormatFloat$outboundSchema;
}

/** @internal */
export const EncodingFormat$inboundSchema: z.ZodType<
  EncodingFormat,
  z.ZodTypeDef,
  unknown
> = z.union([
  EncodingFormatFloat$inboundSchema,
  EncodingFormatBase64$inboundSchema,
]);

/** @internal */
export type EncodingFormat$Outbound = string | string;

/** @internal */
export const EncodingFormat$outboundSchema: z.ZodType<
  EncodingFormat$Outbound,
  z.ZodTypeDef,
  EncodingFormat
> = z.union([
  EncodingFormatFloat$outboundSchema,
  EncodingFormatBase64$outboundSchema,
]);

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace EncodingFormat$ {
  /** @deprecated use `EncodingFormat$inboundSchema` instead. */
  export const inboundSchema = EncodingFormat$inboundSchema;
  /** @deprecated use `EncodingFormat$outboundSchema` instead. */
  export const outboundSchema = EncodingFormat$outboundSchema;
  /** @deprecated use `EncodingFormat$Outbound` instead. */
  export type Outbound = EncodingFormat$Outbound;
}

export function encodingFormatToJSON(encodingFormat: EncodingFormat): string {
  return JSON.stringify(EncodingFormat$outboundSchema.parse(encodingFormat));
}

export function encodingFormatFromJSON(
  jsonString: string,
): SafeParseResult<EncodingFormat, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => EncodingFormat$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'EncodingFormat' from JSON`,
  );
}

/** @internal */
export const GenerateRequest$inboundSchema: z.ZodType<
  GenerateRequest,
  z.ZodTypeDef,
  unknown
> = z.object({
  input: z.union([
    z.string(),
    z.array(z.string()),
    z.array(z.number()),
    z.array(z.array(z.number())),
  ]),
  model: z.string().optional(),
  models: z.array(z.string()).optional(),
  provider: z.lazy(() => GenerateProvider$inboundSchema).optional(),
  encoding_format: z.union([
    EncodingFormatFloat$inboundSchema,
    EncodingFormatBase64$inboundSchema,
  ]).optional(),
  user: z.string().optional(),
}).transform((v) => {
  return remap$(v, {
    "encoding_format": "encodingFormat",
  });
});

/** @internal */
export type GenerateRequest$Outbound = {
  input: string | Array<string> | Array<number> | Array<Array<number>>;
  model?: string | undefined;
  models?: Array<string> | undefined;
  provider?: GenerateProvider$Outbound | undefined;
  encoding_format?: string | string | undefined;
  user?: string | undefined;
};

/** @internal */
export const GenerateRequest$outboundSchema: z.ZodType<
  GenerateRequest$Outbound,
  z.ZodTypeDef,
  GenerateRequest
> = z.object({
  input: z.union([
    z.string(),
    z.array(z.string()),
    z.array(z.number()),
    z.array(z.array(z.number())),
  ]),
  model: z.string().optional(),
  models: z.array(z.string()).optional(),
  provider: z.lazy(() => GenerateProvider$outboundSchema).optional(),
  encodingFormat: z.union([
    EncodingFormatFloat$outboundSchema,
    EncodingFormatBase64$outboundSchema,
  ]).optional(),
  user: z.string().optional(),
}).transform((v) => {
  return remap$(v, {
    encodingFormat: "encoding_format",
  });
});

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace GenerateRequest$ {
  /** @deprecated use `GenerateRequest$inboundSchema` instead. */
  export const inboundSchema = GenerateRequest$inboundSchema;
  /** @deprecated use `GenerateRequest$outboundSchema` instead. */
  export const outboundSchema = GenerateRequest$outboundSchema;
  /** @deprecated use `GenerateRequest$Outbound` instead. */
  export type Outbound = GenerateRequest$Outbound;
}

export function generateRequestToJSON(
  generateRequest: GenerateRequest,
): string {
  return JSON.stringify(GenerateRequest$outboundSchema.parse(generateRequest));
}

export function generateRequestFromJSON(
  jsonString: string,
): SafeParseResult<GenerateRequest, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => GenerateRequest$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'GenerateRequest' from JSON`,
  );
}

/** @internal */
export const ObjectT$inboundSchema: z.ZodNativeEnum<typeof ObjectT> = z
  .nativeEnum(ObjectT);

/** @internal */
export const ObjectT$outboundSchema: z.ZodNativeEnum<typeof ObjectT> =
  ObjectT$inboundSchema;

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace ObjectT$ {
  /** @deprecated use `ObjectT$inboundSchema` instead. */
  export const inboundSchema = ObjectT$inboundSchema;
  /** @deprecated use `ObjectT$outboundSchema` instead. */
  export const outboundSchema = ObjectT$outboundSchema;
}

/** @internal */
export const ObjectEmbedding$inboundSchema: z.ZodNativeEnum<
  typeof ObjectEmbedding
> = z.nativeEnum(ObjectEmbedding);

/** @internal */
export const ObjectEmbedding$outboundSchema: z.ZodNativeEnum<
  typeof ObjectEmbedding
> = ObjectEmbedding$inboundSchema;

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace ObjectEmbedding$ {
  /** @deprecated use `ObjectEmbedding$inboundSchema` instead. */
  export const inboundSchema = ObjectEmbedding$inboundSchema;
  /** @deprecated use `ObjectEmbedding$outboundSchema` instead. */
  export const outboundSchema = ObjectEmbedding$outboundSchema;
}

/** @internal */
export const GenerateData$inboundSchema: z.ZodType<
  GenerateData,
  z.ZodTypeDef,
  unknown
> = z.object({
  object: ObjectEmbedding$inboundSchema,
  embedding: z.array(z.number()),
  index: z.number(),
});

/** @internal */
export type GenerateData$Outbound = {
  object: string;
  embedding: Array<number>;
  index: number;
};

/** @internal */
export const GenerateData$outboundSchema: z.ZodType<
  GenerateData$Outbound,
  z.ZodTypeDef,
  GenerateData
> = z.object({
  object: ObjectEmbedding$outboundSchema,
  embedding: z.array(z.number()),
  index: z.number(),
});

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace GenerateData$ {
  /** @deprecated use `GenerateData$inboundSchema` instead. */
  export const inboundSchema = GenerateData$inboundSchema;
  /** @deprecated use `GenerateData$outboundSchema` instead. */
  export const outboundSchema = GenerateData$outboundSchema;
  /** @deprecated use `GenerateData$Outbound` instead. */
  export type Outbound = GenerateData$Outbound;
}

export function generateDataToJSON(generateData: GenerateData): string {
  return JSON.stringify(GenerateData$outboundSchema.parse(generateData));
}

export function generateDataFromJSON(
  jsonString: string,
): SafeParseResult<GenerateData, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => GenerateData$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'GenerateData' from JSON`,
  );
}

/** @internal */
export const Usage$inboundSchema: z.ZodType<Usage, z.ZodTypeDef, unknown> = z
  .object({
    prompt_tokens: z.number(),
    total_tokens: z.number(),
    cost: z.number().optional(),
  }).transform((v) => {
    return remap$(v, {
      "prompt_tokens": "promptTokens",
      "total_tokens": "totalTokens",
    });
  });

/** @internal */
export type Usage$Outbound = {
  prompt_tokens: number;
  total_tokens: number;
  cost?: number | undefined;
};

/** @internal */
export const Usage$outboundSchema: z.ZodType<
  Usage$Outbound,
  z.ZodTypeDef,
  Usage
> = z.object({
  promptTokens: z.number(),
  totalTokens: z.number(),
  cost: z.number().optional(),
}).transform((v) => {
  return remap$(v, {
    promptTokens: "prompt_tokens",
    totalTokens: "total_tokens",
  });
});

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace Usage$ {
  /** @deprecated use `Usage$inboundSchema` instead. */
  export const inboundSchema = Usage$inboundSchema;
  /** @deprecated use `Usage$outboundSchema` instead. */
  export const outboundSchema = Usage$outboundSchema;
  /** @deprecated use `Usage$Outbound` instead. */
  export type Outbound = Usage$Outbound;
}

export function usageToJSON(usage: Usage): string {
  return JSON.stringify(Usage$outboundSchema.parse(usage));
}

export function usageFromJSON(
  jsonString: string,
): SafeParseResult<Usage, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => Usage$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'Usage' from JSON`,
  );
}

/** @internal */
export const GenerateResponse$inboundSchema: z.ZodType<
  GenerateResponse,
  z.ZodTypeDef,
  unknown
> = z.object({
  object: ObjectT$inboundSchema,
  data: z.array(z.lazy(() => GenerateData$inboundSchema)),
  model: z.string(),
  usage: z.lazy(() => Usage$inboundSchema).optional(),
});

/** @internal */
export type GenerateResponse$Outbound = {
  object: string;
  data: Array<GenerateData$Outbound>;
  model: string;
  usage?: Usage$Outbound | undefined;
};

/** @internal */
export const GenerateResponse$outboundSchema: z.ZodType<
  GenerateResponse$Outbound,
  z.ZodTypeDef,
  GenerateResponse
> = z.object({
  object: ObjectT$outboundSchema,
  data: z.array(z.lazy(() => GenerateData$outboundSchema)),
  model: z.string(),
  usage: z.lazy(() => Usage$outboundSchema).optional(),
});

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace GenerateResponse$ {
  /** @deprecated use `GenerateResponse$inboundSchema` instead. */
  export const inboundSchema = GenerateResponse$inboundSchema;
  /** @deprecated use `GenerateResponse$outboundSchema` instead. */
  export const outboundSchema = GenerateResponse$outboundSchema;
  /** @deprecated use `GenerateResponse$Outbound` instead. */
  export type Outbound = GenerateResponse$Outbound;
}

export function generateResponseToJSON(
  generateResponse: GenerateResponse,
): string {
  return JSON.stringify(
    GenerateResponse$outboundSchema.parse(generateResponse),
  );
}

export function generateResponseFromJSON(
  jsonString: string,
): SafeParseResult<GenerateResponse, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => GenerateResponse$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'GenerateResponse' from JSON`,
  );
}
