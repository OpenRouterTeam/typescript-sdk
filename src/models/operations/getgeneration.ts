/*
 * Code generated by Speakeasy (https://speakeasy.com). DO NOT EDIT.
 */

import * as z from "zod/v4";
import { remap as remap$ } from "../../lib/primitives.js";
import { safeParse } from "../../lib/schemas.js";
import { catchUnrecognizedEnum, OpenEnum } from "../../types/enums.js";
import { Result as SafeParseResult } from "../../types/fp.js";
import { SDKValidationError } from "../errors/sdkvalidationerror.js";

export type GetGenerationRequest = {
  id: string;
};

/**
 * Type of API used for the generation
 */
export const ApiType = {
  Completions: "completions",
  Embeddings: "embeddings",
} as const;
/**
 * Type of API used for the generation
 */
export type ApiType = OpenEnum<typeof ApiType>;

/**
 * Generation data
 */
export type GetGenerationData = {
  /**
   * Unique identifier for the generation
   */
  id: string;
  /**
   * Upstream provider's identifier for this generation
   */
  upstreamId: string | null;
  /**
   * Total cost of the generation in USD
   */
  totalCost: number;
  /**
   * Discount applied due to caching
   */
  cacheDiscount: number | null;
  /**
   * Cost charged by the upstream provider
   */
  upstreamInferenceCost: number | null;
  /**
   * ISO 8601 timestamp of when the generation was created
   */
  createdAt: string;
  /**
   * Model used for the generation
   */
  model: string;
  /**
   * ID of the app that made the request
   */
  appId: number | null;
  /**
   * Whether the response was streamed
   */
  streamed: boolean | null;
  /**
   * Whether the generation was cancelled
   */
  cancelled: boolean | null;
  /**
   * Name of the provider that served the request
   */
  providerName: string | null;
  /**
   * Total latency in milliseconds
   */
  latency: number | null;
  /**
   * Moderation latency in milliseconds
   */
  moderationLatency: number | null;
  /**
   * Time taken for generation in milliseconds
   */
  generationTime: number | null;
  /**
   * Reason the generation finished
   */
  finishReason: string | null;
  /**
   * Number of tokens in the prompt
   */
  tokensPrompt: number | null;
  /**
   * Number of tokens in the completion
   */
  tokensCompletion: number | null;
  /**
   * Native prompt tokens as reported by provider
   */
  nativeTokensPrompt: number | null;
  /**
   * Native completion tokens as reported by provider
   */
  nativeTokensCompletion: number | null;
  /**
   * Native completion image tokens as reported by provider
   */
  nativeTokensCompletionImages: number | null;
  /**
   * Native reasoning tokens as reported by provider
   */
  nativeTokensReasoning: number | null;
  /**
   * Native cached tokens as reported by provider
   */
  nativeTokensCached: number | null;
  /**
   * Number of media items in the prompt
   */
  numMediaPrompt: number | null;
  /**
   * Number of audio inputs in the prompt
   */
  numInputAudioPrompt: number | null;
  /**
   * Number of media items in the completion
   */
  numMediaCompletion: number | null;
  /**
   * Number of search results included
   */
  numSearchResults: number | null;
  /**
   * Origin URL of the request
   */
  origin: string;
  /**
   * Usage amount in USD
   */
  usage: number;
  /**
   * Whether this used bring-your-own-key
   */
  isByok: boolean;
  /**
   * Native finish reason as reported by provider
   */
  nativeFinishReason: string | null;
  /**
   * External user identifier
   */
  externalUser: string | null;
  /**
   * Type of API used for the generation
   */
  apiType: ApiType | null;
};

/**
 * Generation response
 */
export type GetGenerationResponse = {
  /**
   * Generation data
   */
  data: GetGenerationData;
};

/** @internal */
export type GetGenerationRequest$Outbound = {
  id: string;
};

/** @internal */
export const GetGenerationRequest$outboundSchema: z.ZodType<
  GetGenerationRequest$Outbound,
  GetGenerationRequest
> = z.object({
  id: z.string(),
});

export function getGenerationRequestToJSON(
  getGenerationRequest: GetGenerationRequest,
): string {
  return JSON.stringify(
    GetGenerationRequest$outboundSchema.parse(getGenerationRequest),
  );
}

/** @internal */
export const ApiType$inboundSchema: z.ZodType<ApiType, unknown> = z
  .union([
    z.enum(ApiType),
    z.string().transform(catchUnrecognizedEnum),
  ]);

/** @internal */
export const GetGenerationData$inboundSchema: z.ZodType<
  GetGenerationData,
  unknown
> = z.object({
  id: z.string(),
  upstream_id: z.nullable(z.string()),
  total_cost: z.number(),
  cache_discount: z.nullable(z.number()),
  upstream_inference_cost: z.nullable(z.number()),
  created_at: z.string(),
  model: z.string(),
  app_id: z.nullable(z.number()),
  streamed: z.nullable(z.boolean()),
  cancelled: z.nullable(z.boolean()),
  provider_name: z.nullable(z.string()),
  latency: z.nullable(z.number()),
  moderation_latency: z.nullable(z.number()),
  generation_time: z.nullable(z.number()),
  finish_reason: z.nullable(z.string()),
  tokens_prompt: z.nullable(z.number()),
  tokens_completion: z.nullable(z.number()),
  native_tokens_prompt: z.nullable(z.number()),
  native_tokens_completion: z.nullable(z.number()),
  native_tokens_completion_images: z.nullable(z.number()),
  native_tokens_reasoning: z.nullable(z.number()),
  native_tokens_cached: z.nullable(z.number()),
  num_media_prompt: z.nullable(z.number()),
  num_input_audio_prompt: z.nullable(z.number()),
  num_media_completion: z.nullable(z.number()),
  num_search_results: z.nullable(z.number()),
  origin: z.string(),
  usage: z.number(),
  is_byok: z.boolean(),
  native_finish_reason: z.nullable(z.string()),
  external_user: z.nullable(z.string()),
  api_type: z.nullable(ApiType$inboundSchema),
}).transform((v) => {
  return remap$(v, {
    "upstream_id": "upstreamId",
    "total_cost": "totalCost",
    "cache_discount": "cacheDiscount",
    "upstream_inference_cost": "upstreamInferenceCost",
    "created_at": "createdAt",
    "app_id": "appId",
    "provider_name": "providerName",
    "moderation_latency": "moderationLatency",
    "generation_time": "generationTime",
    "finish_reason": "finishReason",
    "tokens_prompt": "tokensPrompt",
    "tokens_completion": "tokensCompletion",
    "native_tokens_prompt": "nativeTokensPrompt",
    "native_tokens_completion": "nativeTokensCompletion",
    "native_tokens_completion_images": "nativeTokensCompletionImages",
    "native_tokens_reasoning": "nativeTokensReasoning",
    "native_tokens_cached": "nativeTokensCached",
    "num_media_prompt": "numMediaPrompt",
    "num_input_audio_prompt": "numInputAudioPrompt",
    "num_media_completion": "numMediaCompletion",
    "num_search_results": "numSearchResults",
    "is_byok": "isByok",
    "native_finish_reason": "nativeFinishReason",
    "external_user": "externalUser",
    "api_type": "apiType",
  });
});

export function getGenerationDataFromJSON(
  jsonString: string,
): SafeParseResult<GetGenerationData, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => GetGenerationData$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'GetGenerationData' from JSON`,
  );
}

/** @internal */
export const GetGenerationResponse$inboundSchema: z.ZodType<
  GetGenerationResponse,
  unknown
> = z.object({
  data: z.lazy(() => GetGenerationData$inboundSchema),
});

export function getGenerationResponseFromJSON(
  jsonString: string,
): SafeParseResult<GetGenerationResponse, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => GetGenerationResponse$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'GetGenerationResponse' from JSON`,
  );
}
