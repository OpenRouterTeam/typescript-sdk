/*
 * Code generated by Speakeasy (https://speakeasy.com). DO NOT EDIT.
 */

import * as z from "zod/v4";
import { remap as remap$ } from "../../lib/primitives.js";
import { safeParse } from "../../lib/schemas.js";
import {
  catchUnrecognizedEnum,
  OpenEnum,
  Unrecognized,
} from "../../types/enums.js";
import { Result as SafeParseResult } from "../../types/fp.js";
import { SDKValidationError } from "../errors/sdkvalidationerror.js";

export type GetParametersSecurity = {
  bearer: string;
};

export const GetParametersProvider = {
  Ai21: "AI21",
  AionLabs: "AionLabs",
  Alibaba: "Alibaba",
  AmazonBedrock: "Amazon Bedrock",
  Anthropic: "Anthropic",
  AtlasCloud: "AtlasCloud",
  Atoma: "Atoma",
  Avian: "Avian",
  Azure: "Azure",
  BaseTen: "BaseTen",
  Cerebras: "Cerebras",
  Chutes: "Chutes",
  Cirrascale: "Cirrascale",
  Clarifai: "Clarifai",
  Cloudflare: "Cloudflare",
  Cohere: "Cohere",
  CrofAI: "CrofAI",
  Crusoe: "Crusoe",
  DeepInfra: "DeepInfra",
  DeepSeek: "DeepSeek",
  Enfer: "Enfer",
  Featherless: "Featherless",
  Fireworks: "Fireworks",
  Friendli: "Friendli",
  GMICloud: "GMICloud",
  Google: "Google",
  GoogleAIStudio: "Google AI Studio",
  Groq: "Groq",
  Hyperbolic: "Hyperbolic",
  Inception: "Inception",
  InferenceNet: "InferenceNet",
  Infermatic: "Infermatic",
  Inflection: "Inflection",
  Kluster: "Kluster",
  Lambda: "Lambda",
  Liquid: "Liquid",
  Mancer2: "Mancer 2",
  Meta: "Meta",
  Minimax: "Minimax",
  ModelRun: "ModelRun",
  Mistral: "Mistral",
  Modular: "Modular",
  MoonshotAI: "Moonshot AI",
  Morph: "Morph",
  NCompass: "NCompass",
  Nebius: "Nebius",
  NextBit: "NextBit",
  Nineteen: "Nineteen",
  Novita: "Novita",
  Nvidia: "Nvidia",
  OpenAI: "OpenAI",
  OpenInference: "OpenInference",
  Parasail: "Parasail",
  Perplexity: "Perplexity",
  Phala: "Phala",
  Relace: "Relace",
  SambaNova: "SambaNova",
  SiliconFlow: "SiliconFlow",
  Stealth: "Stealth",
  Switchpoint: "Switchpoint",
  Targon: "Targon",
  Together: "Together",
  Ubicloud: "Ubicloud",
  Venice: "Venice",
  WandB: "WandB",
  XAI: "xAI",
  ZAi: "Z.AI",
  FakeProvider: "FakeProvider",
} as const;
export type GetParametersProvider = OpenEnum<typeof GetParametersProvider>;

export type GetParametersRequest = {
  author: string;
  slug: string;
  provider?: GetParametersProvider | undefined;
};

export const SupportedParameter = {
  Temperature: "temperature",
  TopP: "top_p",
  TopK: "top_k",
  MinP: "min_p",
  TopA: "top_a",
  FrequencyPenalty: "frequency_penalty",
  PresencePenalty: "presence_penalty",
  RepetitionPenalty: "repetition_penalty",
  MaxTokens: "max_tokens",
  LogitBias: "logit_bias",
  Logprobs: "logprobs",
  TopLogprobs: "top_logprobs",
  Seed: "seed",
  ResponseFormat: "response_format",
  StructuredOutputs: "structured_outputs",
  Stop: "stop",
  Tools: "tools",
  ToolChoice: "tool_choice",
  ParallelToolCalls: "parallel_tool_calls",
  IncludeReasoning: "include_reasoning",
  Reasoning: "reasoning",
  WebSearchOptions: "web_search_options",
  Verbosity: "verbosity",
} as const;
export type SupportedParameter = OpenEnum<typeof SupportedParameter>;

/**
 * Parameter analytics data
 */
export type GetParametersData = {
  /**
   * Model identifier
   */
  model: string;
  /**
   * List of parameters supported by this model
   */
  supportedParameters: Array<SupportedParameter>;
};

/**
 * Returns the parameters for the specified model
 */
export type GetParametersResponse = {
  /**
   * Parameter analytics data
   */
  data: GetParametersData;
};

/** @internal */
export type GetParametersSecurity$Outbound = {
  bearer: string;
};

/** @internal */
export const GetParametersSecurity$outboundSchema: z.ZodType<
  GetParametersSecurity$Outbound,
  GetParametersSecurity
> = z.object({
  bearer: z.string(),
});

export function getParametersSecurityToJSON(
  getParametersSecurity: GetParametersSecurity,
): string {
  return JSON.stringify(
    GetParametersSecurity$outboundSchema.parse(getParametersSecurity),
  );
}

/** @internal */
export const GetParametersProvider$outboundSchema: z.ZodType<
  GetParametersProvider,
  GetParametersProvider
> = z.union([
  z.enum(GetParametersProvider),
  z.string().and(z.custom<Unrecognized<string>>()),
]);

/** @internal */
export type GetParametersRequest$Outbound = {
  author: string;
  slug: string;
  provider?: string | undefined;
};

/** @internal */
export const GetParametersRequest$outboundSchema: z.ZodType<
  GetParametersRequest$Outbound,
  GetParametersRequest
> = z.object({
  author: z.string(),
  slug: z.string(),
  provider: GetParametersProvider$outboundSchema.optional(),
});

export function getParametersRequestToJSON(
  getParametersRequest: GetParametersRequest,
): string {
  return JSON.stringify(
    GetParametersRequest$outboundSchema.parse(getParametersRequest),
  );
}

/** @internal */
export const SupportedParameter$inboundSchema: z.ZodType<
  SupportedParameter,
  unknown
> = z
  .union([
    z.enum(SupportedParameter),
    z.string().transform(catchUnrecognizedEnum),
  ]);

/** @internal */
export const GetParametersData$inboundSchema: z.ZodType<
  GetParametersData,
  unknown
> = z.object({
  model: z.string(),
  supported_parameters: z.array(SupportedParameter$inboundSchema),
}).transform((v) => {
  return remap$(v, {
    "supported_parameters": "supportedParameters",
  });
});

export function getParametersDataFromJSON(
  jsonString: string,
): SafeParseResult<GetParametersData, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => GetParametersData$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'GetParametersData' from JSON`,
  );
}

/** @internal */
export const GetParametersResponse$inboundSchema: z.ZodType<
  GetParametersResponse,
  unknown
> = z.object({
  data: z.lazy(() => GetParametersData$inboundSchema),
});

export function getParametersResponseFromJSON(
  jsonString: string,
): SafeParseResult<GetParametersResponse, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => GetParametersResponse$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'GetParametersResponse' from JSON`,
  );
}
