/*
 * Code generated by Speakeasy (https://speakeasy.com). DO NOT EDIT.
 */

import * as z from "zod/v4";
import { remap as remap$ } from "../../lib/primitives.js";
import { safeParse } from "../../lib/schemas.js";
import * as openEnums from "../../types/enums.js";
import { ClosedEnum, OpenEnum } from "../../types/enums.js";
import { Result as SafeParseResult } from "../../types/fp.js";
import { SDKValidationError } from "../errors/sdkvalidationerror.js";
import * as models from "../index.js";

export const TypeImageURL = {
  ImageUrl: "image_url",
} as const;
export type TypeImageURL = ClosedEnum<typeof TypeImageURL>;

export type ImageUrl = {
  url: string;
};

export type ContentImageURL = {
  type: TypeImageURL;
  imageUrl: ImageUrl;
};

export const TypeText = {
  Text: "text",
} as const;
export type TypeText = ClosedEnum<typeof TypeText>;

export type ContentText = {
  type: TypeText;
  text: string;
};

export type Content = ContentText | ContentImageURL;

export type Input = {
  content: Array<ContentText | ContentImageURL>;
};

export type InputUnion =
  | string
  | Array<string>
  | Array<number>
  | Array<Array<number>>
  | Array<Input>;

export const EncodingFormat = {
  Float: "float",
  Base64: "base64",
} as const;
export type EncodingFormat = OpenEnum<typeof EncodingFormat>;

export type Order = models.ProviderName | string;

export type Only = models.ProviderName | string;

export type Ignore = models.ProviderName | string;

/**
 * The object specifying the maximum price you want to pay for this request. USD price per million tokens, for prompt and completion.
 */
export type MaxPrice = {
  /**
   * A value in string or number format that is a large number
   */
  prompt?: any | undefined;
  /**
   * A value in string or number format that is a large number
   */
  completion?: any | undefined;
  /**
   * A value in string or number format that is a large number
   */
  image?: any | undefined;
  /**
   * A value in string or number format that is a large number
   */
  audio?: any | undefined;
  /**
   * A value in string or number format that is a large number
   */
  request?: any | undefined;
};

export type CreateEmbeddingsProvider = {
  /**
   * Whether to allow backup providers to serve requests
   *
   * @remarks
   * - true: (default) when the primary provider (or your custom providers in "order") is unavailable, use the next best provider.
   * - false: use only the primary/custom provider, and return the upstream error if it's unavailable.
   */
  allowFallbacks?: boolean | null | undefined;
  /**
   * Whether to filter providers to only those that support the parameters you've provided. If this setting is omitted or set to false, then providers will receive only the parameters they support, and ignore the rest.
   */
  requireParameters?: boolean | null | undefined;
  /**
   * Data collection setting. If no available model provider meets the requirement, your request will return an error.
   *
   * @remarks
   * - allow: (default) allow providers which store user data non-transiently and may train on it
   *
   * - deny: use only providers which do not collect user data.
   */
  dataCollection?: models.DataCollection | null | undefined;
  /**
   * Whether to restrict routing to only ZDR (Zero Data Retention) endpoints. When true, only endpoints that do not retain prompts will be used.
   */
  zdr?: boolean | null | undefined;
  /**
   * Whether to restrict routing to only models that allow text distillation. When true, only models where the author has allowed distillation will be used.
   */
  enforceDistillableText?: boolean | null | undefined;
  /**
   * An ordered list of provider slugs. The router will attempt to use the first provider in the subset of this list that supports your requested model, and fall back to the next if it is unavailable. If no providers are available, the request will fail with an error message.
   */
  order?: Array<models.ProviderName | string> | null | undefined;
  /**
   * List of provider slugs to allow. If provided, this list is merged with your account-wide allowed provider settings for this request.
   */
  only?: Array<models.ProviderName | string> | null | undefined;
  /**
   * List of provider slugs to ignore. If provided, this list is merged with your account-wide ignored provider settings for this request.
   */
  ignore?: Array<models.ProviderName | string> | null | undefined;
  /**
   * A list of quantization levels to filter the provider by.
   */
  quantizations?: Array<models.Quantization> | null | undefined;
  /**
   * The sorting strategy to use for this request, if "order" is not specified. When set, no load balancing is performed.
   */
  sort?: models.ProviderSort | null | undefined;
  /**
   * The object specifying the maximum price you want to pay for this request. USD price per million tokens, for prompt and completion.
   */
  maxPrice?: MaxPrice | undefined;
};

export type CreateEmbeddingsRequest = {
  input:
    | string
    | Array<string>
    | Array<number>
    | Array<Array<number>>
    | Array<Input>;
  model: string;
  encodingFormat?: EncodingFormat | undefined;
  dimensions?: number | undefined;
  user?: string | undefined;
  provider?: CreateEmbeddingsProvider | undefined;
  inputType?: string | undefined;
};

export const ObjectT = {
  List: "list",
} as const;
export type ObjectT = ClosedEnum<typeof ObjectT>;

export const ObjectEmbedding = {
  Embedding: "embedding",
} as const;
export type ObjectEmbedding = ClosedEnum<typeof ObjectEmbedding>;

export type Embedding = Array<number> | string;

export type CreateEmbeddingsData = {
  object: ObjectEmbedding;
  embedding: Array<number> | string;
  index?: number | undefined;
};

export type Usage = {
  promptTokens: number;
  totalTokens: number;
  cost?: number | undefined;
};

/**
 * Embedding response
 */
export type CreateEmbeddingsResponseBody = {
  id?: string | undefined;
  object: ObjectT;
  data: Array<CreateEmbeddingsData>;
  model: string;
  usage?: Usage | undefined;
};

export type CreateEmbeddingsResponse = CreateEmbeddingsResponseBody | string;

/** @internal */
export const TypeImageURL$outboundSchema: z.ZodEnum<typeof TypeImageURL> = z
  .enum(TypeImageURL);

/** @internal */
export type ImageUrl$Outbound = {
  url: string;
};

/** @internal */
export const ImageUrl$outboundSchema: z.ZodType<ImageUrl$Outbound, ImageUrl> = z
  .object({
    url: z.string(),
  });

export function imageUrlToJSON(imageUrl: ImageUrl): string {
  return JSON.stringify(ImageUrl$outboundSchema.parse(imageUrl));
}

/** @internal */
export type ContentImageURL$Outbound = {
  type: string;
  image_url: ImageUrl$Outbound;
};

/** @internal */
export const ContentImageURL$outboundSchema: z.ZodType<
  ContentImageURL$Outbound,
  ContentImageURL
> = z.object({
  type: TypeImageURL$outboundSchema,
  imageUrl: z.lazy(() => ImageUrl$outboundSchema),
}).transform((v) => {
  return remap$(v, {
    imageUrl: "image_url",
  });
});

export function contentImageURLToJSON(
  contentImageURL: ContentImageURL,
): string {
  return JSON.stringify(ContentImageURL$outboundSchema.parse(contentImageURL));
}

/** @internal */
export const TypeText$outboundSchema: z.ZodEnum<typeof TypeText> = z.enum(
  TypeText,
);

/** @internal */
export type ContentText$Outbound = {
  type: string;
  text: string;
};

/** @internal */
export const ContentText$outboundSchema: z.ZodType<
  ContentText$Outbound,
  ContentText
> = z.object({
  type: TypeText$outboundSchema,
  text: z.string(),
});

export function contentTextToJSON(contentText: ContentText): string {
  return JSON.stringify(ContentText$outboundSchema.parse(contentText));
}

/** @internal */
export type Content$Outbound = ContentText$Outbound | ContentImageURL$Outbound;

/** @internal */
export const Content$outboundSchema: z.ZodType<Content$Outbound, Content> = z
  .union([
    z.lazy(() => ContentText$outboundSchema),
    z.lazy(() => ContentImageURL$outboundSchema),
  ]);

export function contentToJSON(content: Content): string {
  return JSON.stringify(Content$outboundSchema.parse(content));
}

/** @internal */
export type Input$Outbound = {
  content: Array<ContentText$Outbound | ContentImageURL$Outbound>;
};

/** @internal */
export const Input$outboundSchema: z.ZodType<Input$Outbound, Input> = z.object({
  content: z.array(
    z.union([
      z.lazy(() => ContentText$outboundSchema),
      z.lazy(() => ContentImageURL$outboundSchema),
    ]),
  ),
});

export function inputToJSON(input: Input): string {
  return JSON.stringify(Input$outboundSchema.parse(input));
}

/** @internal */
export type InputUnion$Outbound =
  | string
  | Array<string>
  | Array<number>
  | Array<Array<number>>
  | Array<Input$Outbound>;

/** @internal */
export const InputUnion$outboundSchema: z.ZodType<
  InputUnion$Outbound,
  InputUnion
> = z.union([
  z.string(),
  z.array(z.string()),
  z.array(z.number()),
  z.array(z.array(z.number())),
  z.array(z.lazy(() => Input$outboundSchema)),
]);

export function inputUnionToJSON(inputUnion: InputUnion): string {
  return JSON.stringify(InputUnion$outboundSchema.parse(inputUnion));
}

/** @internal */
export const EncodingFormat$outboundSchema: z.ZodType<string, EncodingFormat> =
  openEnums.outboundSchema(EncodingFormat);

/** @internal */
export type Order$Outbound = string | string;

/** @internal */
export const Order$outboundSchema: z.ZodType<Order$Outbound, Order> = z.union([
  models.ProviderName$outboundSchema,
  z.string(),
]);

export function orderToJSON(order: Order): string {
  return JSON.stringify(Order$outboundSchema.parse(order));
}

/** @internal */
export type Only$Outbound = string | string;

/** @internal */
export const Only$outboundSchema: z.ZodType<Only$Outbound, Only> = z.union([
  models.ProviderName$outboundSchema,
  z.string(),
]);

export function onlyToJSON(only: Only): string {
  return JSON.stringify(Only$outboundSchema.parse(only));
}

/** @internal */
export type Ignore$Outbound = string | string;

/** @internal */
export const Ignore$outboundSchema: z.ZodType<Ignore$Outbound, Ignore> = z
  .union([models.ProviderName$outboundSchema, z.string()]);

export function ignoreToJSON(ignore: Ignore): string {
  return JSON.stringify(Ignore$outboundSchema.parse(ignore));
}

/** @internal */
export type MaxPrice$Outbound = {
  prompt?: any | undefined;
  completion?: any | undefined;
  image?: any | undefined;
  audio?: any | undefined;
  request?: any | undefined;
};

/** @internal */
export const MaxPrice$outboundSchema: z.ZodType<MaxPrice$Outbound, MaxPrice> = z
  .object({
    prompt: z.any().optional(),
    completion: z.any().optional(),
    image: z.any().optional(),
    audio: z.any().optional(),
    request: z.any().optional(),
  });

export function maxPriceToJSON(maxPrice: MaxPrice): string {
  return JSON.stringify(MaxPrice$outboundSchema.parse(maxPrice));
}

/** @internal */
export type CreateEmbeddingsProvider$Outbound = {
  allow_fallbacks?: boolean | null | undefined;
  require_parameters?: boolean | null | undefined;
  data_collection?: string | null | undefined;
  zdr?: boolean | null | undefined;
  enforce_distillable_text?: boolean | null | undefined;
  order?: Array<string | string> | null | undefined;
  only?: Array<string | string> | null | undefined;
  ignore?: Array<string | string> | null | undefined;
  quantizations?: Array<string> | null | undefined;
  sort?: string | null | undefined;
  max_price?: MaxPrice$Outbound | undefined;
};

/** @internal */
export const CreateEmbeddingsProvider$outboundSchema: z.ZodType<
  CreateEmbeddingsProvider$Outbound,
  CreateEmbeddingsProvider
> = z.object({
  allowFallbacks: z.nullable(z.boolean()).optional(),
  requireParameters: z.nullable(z.boolean()).optional(),
  dataCollection: z.nullable(models.DataCollection$outboundSchema).optional(),
  zdr: z.nullable(z.boolean()).optional(),
  enforceDistillableText: z.nullable(z.boolean()).optional(),
  order: z.nullable(
    z.array(z.union([models.ProviderName$outboundSchema, z.string()])),
  ).optional(),
  only: z.nullable(
    z.array(z.union([models.ProviderName$outboundSchema, z.string()])),
  ).optional(),
  ignore: z.nullable(
    z.array(z.union([models.ProviderName$outboundSchema, z.string()])),
  ).optional(),
  quantizations: z.nullable(z.array(models.Quantization$outboundSchema))
    .optional(),
  sort: z.nullable(models.ProviderSort$outboundSchema).optional(),
  maxPrice: z.lazy(() => MaxPrice$outboundSchema).optional(),
}).transform((v) => {
  return remap$(v, {
    allowFallbacks: "allow_fallbacks",
    requireParameters: "require_parameters",
    dataCollection: "data_collection",
    enforceDistillableText: "enforce_distillable_text",
    maxPrice: "max_price",
  });
});

export function createEmbeddingsProviderToJSON(
  createEmbeddingsProvider: CreateEmbeddingsProvider,
): string {
  return JSON.stringify(
    CreateEmbeddingsProvider$outboundSchema.parse(createEmbeddingsProvider),
  );
}

/** @internal */
export type CreateEmbeddingsRequest$Outbound = {
  input:
    | string
    | Array<string>
    | Array<number>
    | Array<Array<number>>
    | Array<Input$Outbound>;
  model: string;
  encoding_format?: string | undefined;
  dimensions?: number | undefined;
  user?: string | undefined;
  provider?: CreateEmbeddingsProvider$Outbound | undefined;
  input_type?: string | undefined;
};

/** @internal */
export const CreateEmbeddingsRequest$outboundSchema: z.ZodType<
  CreateEmbeddingsRequest$Outbound,
  CreateEmbeddingsRequest
> = z.object({
  input: z.union([
    z.string(),
    z.array(z.string()),
    z.array(z.number()),
    z.array(z.array(z.number())),
    z.array(z.lazy(() => Input$outboundSchema)),
  ]),
  model: z.string(),
  encodingFormat: EncodingFormat$outboundSchema.optional(),
  dimensions: z.int().optional(),
  user: z.string().optional(),
  provider: z.lazy(() => CreateEmbeddingsProvider$outboundSchema).optional(),
  inputType: z.string().optional(),
}).transform((v) => {
  return remap$(v, {
    encodingFormat: "encoding_format",
    inputType: "input_type",
  });
});

export function createEmbeddingsRequestToJSON(
  createEmbeddingsRequest: CreateEmbeddingsRequest,
): string {
  return JSON.stringify(
    CreateEmbeddingsRequest$outboundSchema.parse(createEmbeddingsRequest),
  );
}

/** @internal */
export const ObjectT$inboundSchema: z.ZodEnum<typeof ObjectT> = z.enum(ObjectT);

/** @internal */
export const ObjectEmbedding$inboundSchema: z.ZodEnum<typeof ObjectEmbedding> =
  z.enum(ObjectEmbedding);

/** @internal */
export const Embedding$inboundSchema: z.ZodType<Embedding, unknown> = z.union([
  z.array(z.number()),
  z.string(),
]);

export function embeddingFromJSON(
  jsonString: string,
): SafeParseResult<Embedding, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => Embedding$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'Embedding' from JSON`,
  );
}

/** @internal */
export const CreateEmbeddingsData$inboundSchema: z.ZodType<
  CreateEmbeddingsData,
  unknown
> = z.object({
  object: ObjectEmbedding$inboundSchema,
  embedding: z.union([z.array(z.number()), z.string()]),
  index: z.number().optional(),
});

export function createEmbeddingsDataFromJSON(
  jsonString: string,
): SafeParseResult<CreateEmbeddingsData, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => CreateEmbeddingsData$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'CreateEmbeddingsData' from JSON`,
  );
}

/** @internal */
export const Usage$inboundSchema: z.ZodType<Usage, unknown> = z.object({
  prompt_tokens: z.number(),
  total_tokens: z.number(),
  cost: z.number().optional(),
}).transform((v) => {
  return remap$(v, {
    "prompt_tokens": "promptTokens",
    "total_tokens": "totalTokens",
  });
});

export function usageFromJSON(
  jsonString: string,
): SafeParseResult<Usage, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => Usage$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'Usage' from JSON`,
  );
}

/** @internal */
export const CreateEmbeddingsResponseBody$inboundSchema: z.ZodType<
  CreateEmbeddingsResponseBody,
  unknown
> = z.object({
  id: z.string().optional(),
  object: ObjectT$inboundSchema,
  data: z.array(z.lazy(() => CreateEmbeddingsData$inboundSchema)),
  model: z.string(),
  usage: z.lazy(() => Usage$inboundSchema).optional(),
});

export function createEmbeddingsResponseBodyFromJSON(
  jsonString: string,
): SafeParseResult<CreateEmbeddingsResponseBody, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => CreateEmbeddingsResponseBody$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'CreateEmbeddingsResponseBody' from JSON`,
  );
}

/** @internal */
export const CreateEmbeddingsResponse$inboundSchema: z.ZodType<
  CreateEmbeddingsResponse,
  unknown
> = z.union([
  z.lazy(() => CreateEmbeddingsResponseBody$inboundSchema),
  z.string(),
]);

export function createEmbeddingsResponseFromJSON(
  jsonString: string,
): SafeParseResult<CreateEmbeddingsResponse, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => CreateEmbeddingsResponse$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'CreateEmbeddingsResponse' from JSON`,
  );
}
