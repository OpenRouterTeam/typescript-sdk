/*
 * Code generated by Speakeasy (https://speakeasy.com). DO NOT EDIT.
 */

import * as z from "zod/v4";
import { remap as remap$ } from "../../lib/primitives.js";
import { safeParse } from "../../lib/schemas.js";
import * as openEnums from "../../types/enums.js";
import { ClosedEnum, OpenEnum } from "../../types/enums.js";
import { Result as SafeParseResult } from "../../types/fp.js";
import { SDKValidationError } from "../errors/sdkvalidationerror.js";
import * as models from "../index.js";

export type ImageUrl = {
  url: string;
};

export type ContentImageURL = {
  type: "image_url";
  imageUrl: ImageUrl;
};

export type ContentText = {
  type: "text";
  text: string;
};

export type Content = ContentText | ContentImageURL;

export type Input = {
  content: Array<ContentText | ContentImageURL>;
};

export type InputUnion =
  | string
  | Array<string>
  | Array<number>
  | Array<Array<number>>
  | Array<Input>;

export const EncodingFormat = {
  Float: "float",
  Base64: "base64",
} as const;
export type EncodingFormat = OpenEnum<typeof EncodingFormat>;

export type CreateEmbeddingsRequest = {
  input:
    | string
    | Array<string>
    | Array<number>
    | Array<Array<number>>
    | Array<Input>;
  model: string;
  encodingFormat?: EncodingFormat | undefined;
  dimensions?: number | undefined;
  user?: string | undefined;
  /**
   * Provider routing preferences for the request.
   */
  provider?: models.ProviderPreferences | undefined;
  inputType?: string | undefined;
};

export const ObjectT = {
  List: "list",
} as const;
export type ObjectT = ClosedEnum<typeof ObjectT>;

export const ObjectEmbedding = {
  Embedding: "embedding",
} as const;
export type ObjectEmbedding = ClosedEnum<typeof ObjectEmbedding>;

export type Embedding = Array<number> | string;

export type CreateEmbeddingsData = {
  object: ObjectEmbedding;
  embedding: Array<number> | string;
  index?: number | undefined;
};

export type Usage = {
  promptTokens: number;
  totalTokens: number;
  cost?: number | undefined;
};

/**
 * Embedding response
 */
export type CreateEmbeddingsResponseBody = {
  id?: string | undefined;
  object: ObjectT;
  data: Array<CreateEmbeddingsData>;
  model: string;
  usage?: Usage | undefined;
};

export type CreateEmbeddingsResponse = CreateEmbeddingsResponseBody | string;

/** @internal */
export type ImageUrl$Outbound = {
  url: string;
};

/** @internal */
export const ImageUrl$outboundSchema: z.ZodType<ImageUrl$Outbound, ImageUrl> = z
  .object({
    url: z.string(),
  });

export function imageUrlToJSON(imageUrl: ImageUrl): string {
  return JSON.stringify(ImageUrl$outboundSchema.parse(imageUrl));
}

/** @internal */
export type ContentImageURL$Outbound = {
  type: "image_url";
  image_url: ImageUrl$Outbound;
};

/** @internal */
export const ContentImageURL$outboundSchema: z.ZodType<
  ContentImageURL$Outbound,
  ContentImageURL
> = z.object({
  type: z.literal("image_url"),
  imageUrl: z.lazy(() => ImageUrl$outboundSchema),
}).transform((v) => {
  return remap$(v, {
    imageUrl: "image_url",
  });
});

export function contentImageURLToJSON(
  contentImageURL: ContentImageURL,
): string {
  return JSON.stringify(ContentImageURL$outboundSchema.parse(contentImageURL));
}

/** @internal */
export type ContentText$Outbound = {
  type: "text";
  text: string;
};

/** @internal */
export const ContentText$outboundSchema: z.ZodType<
  ContentText$Outbound,
  ContentText
> = z.object({
  type: z.literal("text"),
  text: z.string(),
});

export function contentTextToJSON(contentText: ContentText): string {
  return JSON.stringify(ContentText$outboundSchema.parse(contentText));
}

/** @internal */
export type Content$Outbound = ContentText$Outbound | ContentImageURL$Outbound;

/** @internal */
export const Content$outboundSchema: z.ZodType<Content$Outbound, Content> = z
  .union([
    z.lazy(() => ContentText$outboundSchema),
    z.lazy(() => ContentImageURL$outboundSchema),
  ]);

export function contentToJSON(content: Content): string {
  return JSON.stringify(Content$outboundSchema.parse(content));
}

/** @internal */
export type Input$Outbound = {
  content: Array<ContentText$Outbound | ContentImageURL$Outbound>;
};

/** @internal */
export const Input$outboundSchema: z.ZodType<Input$Outbound, Input> = z.object({
  content: z.array(
    z.union([
      z.lazy(() => ContentText$outboundSchema),
      z.lazy(() => ContentImageURL$outboundSchema),
    ]),
  ),
});

export function inputToJSON(input: Input): string {
  return JSON.stringify(Input$outboundSchema.parse(input));
}

/** @internal */
export type InputUnion$Outbound =
  | string
  | Array<string>
  | Array<number>
  | Array<Array<number>>
  | Array<Input$Outbound>;

/** @internal */
export const InputUnion$outboundSchema: z.ZodType<
  InputUnion$Outbound,
  InputUnion
> = z.union([
  z.string(),
  z.array(z.string()),
  z.array(z.number()),
  z.array(z.array(z.number())),
  z.array(z.lazy(() => Input$outboundSchema)),
]);

export function inputUnionToJSON(inputUnion: InputUnion): string {
  return JSON.stringify(InputUnion$outboundSchema.parse(inputUnion));
}

/** @internal */
export const EncodingFormat$outboundSchema: z.ZodType<string, EncodingFormat> =
  openEnums.outboundSchema(EncodingFormat);

/** @internal */
export type CreateEmbeddingsRequest$Outbound = {
  input:
    | string
    | Array<string>
    | Array<number>
    | Array<Array<number>>
    | Array<Input$Outbound>;
  model: string;
  encoding_format?: string | undefined;
  dimensions?: number | undefined;
  user?: string | undefined;
  provider?: models.ProviderPreferences$Outbound | undefined;
  input_type?: string | undefined;
};

/** @internal */
export const CreateEmbeddingsRequest$outboundSchema: z.ZodType<
  CreateEmbeddingsRequest$Outbound,
  CreateEmbeddingsRequest
> = z.object({
  input: z.union([
    z.string(),
    z.array(z.string()),
    z.array(z.number()),
    z.array(z.array(z.number())),
    z.array(z.lazy(() => Input$outboundSchema)),
  ]),
  model: z.string(),
  encodingFormat: EncodingFormat$outboundSchema.optional(),
  dimensions: z.int().optional(),
  user: z.string().optional(),
  provider: models.ProviderPreferences$outboundSchema.optional(),
  inputType: z.string().optional(),
}).transform((v) => {
  return remap$(v, {
    encodingFormat: "encoding_format",
    inputType: "input_type",
  });
});

export function createEmbeddingsRequestToJSON(
  createEmbeddingsRequest: CreateEmbeddingsRequest,
): string {
  return JSON.stringify(
    CreateEmbeddingsRequest$outboundSchema.parse(createEmbeddingsRequest),
  );
}

/** @internal */
export const ObjectT$inboundSchema: z.ZodEnum<typeof ObjectT> = z.enum(ObjectT);

/** @internal */
export const ObjectEmbedding$inboundSchema: z.ZodEnum<typeof ObjectEmbedding> =
  z.enum(ObjectEmbedding);

/** @internal */
export const Embedding$inboundSchema: z.ZodType<Embedding, unknown> = z.union([
  z.array(z.number()),
  z.string(),
]);

export function embeddingFromJSON(
  jsonString: string,
): SafeParseResult<Embedding, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => Embedding$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'Embedding' from JSON`,
  );
}

/** @internal */
export const CreateEmbeddingsData$inboundSchema: z.ZodType<
  CreateEmbeddingsData,
  unknown
> = z.object({
  object: ObjectEmbedding$inboundSchema,
  embedding: z.union([z.array(z.number()), z.string()]),
  index: z.number().optional(),
});

export function createEmbeddingsDataFromJSON(
  jsonString: string,
): SafeParseResult<CreateEmbeddingsData, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => CreateEmbeddingsData$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'CreateEmbeddingsData' from JSON`,
  );
}

/** @internal */
export const Usage$inboundSchema: z.ZodType<Usage, unknown> = z.object({
  prompt_tokens: z.number(),
  total_tokens: z.number(),
  cost: z.number().optional(),
}).transform((v) => {
  return remap$(v, {
    "prompt_tokens": "promptTokens",
    "total_tokens": "totalTokens",
  });
});

export function usageFromJSON(
  jsonString: string,
): SafeParseResult<Usage, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => Usage$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'Usage' from JSON`,
  );
}

/** @internal */
export const CreateEmbeddingsResponseBody$inboundSchema: z.ZodType<
  CreateEmbeddingsResponseBody,
  unknown
> = z.object({
  id: z.string().optional(),
  object: ObjectT$inboundSchema,
  data: z.array(z.lazy(() => CreateEmbeddingsData$inboundSchema)),
  model: z.string(),
  usage: z.lazy(() => Usage$inboundSchema).optional(),
});

export function createEmbeddingsResponseBodyFromJSON(
  jsonString: string,
): SafeParseResult<CreateEmbeddingsResponseBody, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => CreateEmbeddingsResponseBody$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'CreateEmbeddingsResponseBody' from JSON`,
  );
}

/** @internal */
export const CreateEmbeddingsResponse$inboundSchema: z.ZodType<
  CreateEmbeddingsResponse,
  unknown
> = z.union([
  z.lazy(() => CreateEmbeddingsResponseBody$inboundSchema),
  z.string(),
]);

export function createEmbeddingsResponseFromJSON(
  jsonString: string,
): SafeParseResult<CreateEmbeddingsResponse, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => CreateEmbeddingsResponse$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'CreateEmbeddingsResponse' from JSON`,
  );
}
