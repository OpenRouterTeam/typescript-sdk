/*
 * Code generated by Speakeasy (https://speakeasy.com). DO NOT EDIT.
 */

import * as z from "zod/v4";
import { remap as remap$ } from "../../lib/primitives.js";
import { safeParse } from "../../lib/schemas.js";
import {
  catchUnrecognizedEnum,
  ClosedEnum,
  OpenEnum,
  Unrecognized,
} from "../../types/enums.js";
import { Result as SafeParseResult } from "../../types/fp.js";
import { SDKValidationError } from "../errors/sdkvalidationerror.js";
import * as models from "../index.js";

export type Input =
  | string
  | Array<string>
  | Array<number>
  | Array<Array<number>>;

/**
 * Data collection setting. If no available model provider meets the requirement, your request will return an error.
 *
 * @remarks
 * - allow: (default) allow providers which store user data non-transiently and may train on it
 * - deny: use only providers which do not collect user data.
 */
export const DataCollection = {
  Deny: "deny",
  Allow: "allow",
} as const;
/**
 * Data collection setting. If no available model provider meets the requirement, your request will return an error.
 *
 * @remarks
 * - allow: (default) allow providers which store user data non-transiently and may train on it
 * - deny: use only providers which do not collect user data.
 */
export type DataCollection = OpenEnum<typeof DataCollection>;

export type Order = models.ProviderName | string;

export type Only = models.ProviderName | string;

export type Ignore = models.ProviderName | string;

/**
 * The sorting strategy to use for this request, if "order" is not specified. When set, no load balancing is performed.
 */
export const Sort = {
  Price: "price",
  Throughput: "throughput",
  Latency: "latency",
} as const;
/**
 * The sorting strategy to use for this request, if "order" is not specified. When set, no load balancing is performed.
 */
export type Sort = OpenEnum<typeof Sort>;

/**
 * The object specifying the maximum price you want to pay for this request. USD price per million tokens, for prompt and completion.
 */
export type MaxPrice = {
  /**
   * A value in string or number format that is a large number
   */
  prompt?: any | undefined;
  /**
   * A value in string or number format that is a large number
   */
  completion?: any | undefined;
  /**
   * A value in string or number format that is a large number
   */
  image?: any | undefined;
  /**
   * A value in string or number format that is a large number
   */
  audio?: any | undefined;
  /**
   * A value in string or number format that is a large number
   */
  request?: any | undefined;
};

export type Experimental = {};

export type CreateEmbeddingsProvider = {
  /**
   * Whether to allow backup providers to serve requests
   *
   * @remarks
   * - true: (default) when the primary provider (or your custom providers in "order") is unavailable, use the next best provider.
   * - false: use only the primary/custom provider, and return the upstream error if it's unavailable.
   */
  allowFallbacks?: boolean | null | undefined;
  /**
   * Whether to filter providers to only those that support the parameters you've provided. If this setting is omitted or set to false, then providers will receive only the parameters they support, and ignore the rest.
   */
  requireParameters?: boolean | null | undefined;
  /**
   * Data collection setting. If no available model provider meets the requirement, your request will return an error.
   *
   * @remarks
   * - allow: (default) allow providers which store user data non-transiently and may train on it
   * - deny: use only providers which do not collect user data.
   */
  dataCollection?: DataCollection | null | undefined;
  /**
   * Whether to restrict routing to only ZDR (Zero Data Retention) endpoints. When true, only endpoints that do not retain prompts will be used.
   */
  zdr?: boolean | null | undefined;
  /**
   * An ordered list of provider slugs. The router will attempt to use the first provider in the subset of this list that supports your requested model, and fall back to the next if it is unavailable. If no providers are available, the request will fail with an error message.
   */
  order?: Array<models.ProviderName | string> | null | undefined;
  /**
   * List of provider slugs to allow. If provided, this list is merged with your account-wide allowed provider settings for this request.
   */
  only?: Array<models.ProviderName | string> | null | undefined;
  /**
   * List of provider slugs to ignore. If provided, this list is merged with your account-wide ignored provider settings for this request.
   */
  ignore?: Array<models.ProviderName | string> | null | undefined;
  /**
   * A list of quantization levels to filter the provider by.
   */
  quantizations?: Array<models.Quantization> | null | undefined;
  /**
   * The sorting strategy to use for this request, if "order" is not specified. When set, no load balancing is performed.
   */
  sort?: Sort | null | undefined;
  /**
   * The object specifying the maximum price you want to pay for this request. USD price per million tokens, for prompt and completion.
   */
  maxPrice?: MaxPrice | undefined;
  experimental?: Experimental | null | undefined;
};

export const EncodingFormatBase64 = {
  Base64: "base64",
} as const;
export type EncodingFormatBase64 = ClosedEnum<typeof EncodingFormatBase64>;

export const EncodingFormatFloat = {
  Float: "float",
} as const;
export type EncodingFormatFloat = ClosedEnum<typeof EncodingFormatFloat>;

export type EncodingFormat = EncodingFormatFloat | EncodingFormatBase64;

export type CreateEmbeddingsRequest = {
  input: string | Array<string> | Array<number> | Array<Array<number>>;
  model: string;
  provider?: CreateEmbeddingsProvider | undefined;
  encodingFormat?: EncodingFormatFloat | EncodingFormatBase64 | undefined;
  user?: string | undefined;
};

export const ObjectT = {
  List: "list",
} as const;
export type ObjectT = ClosedEnum<typeof ObjectT>;

export const ObjectEmbedding = {
  Embedding: "embedding",
} as const;
export type ObjectEmbedding = ClosedEnum<typeof ObjectEmbedding>;

export type Embedding = Array<number> | string;

export type CreateEmbeddingsData = {
  object: ObjectEmbedding;
  embedding: Array<number> | string;
  index?: number | undefined;
};

export type Usage = {
  promptTokens: number;
  totalTokens: number;
  cost?: number | undefined;
};

/**
 * Embedding response
 */
export type CreateEmbeddingsResponseBody = {
  id?: string | undefined;
  object: ObjectT;
  data: Array<CreateEmbeddingsData>;
  model: string;
  usage?: Usage | undefined;
};

export type CreateEmbeddingsResponse = CreateEmbeddingsResponseBody | string;

/** @internal */
export const Input$inboundSchema: z.ZodType<Input, unknown> = z.union([
  z.string(),
  z.array(z.string()),
  z.array(z.number()),
  z.array(z.array(z.number())),
]);

/** @internal */
export type Input$Outbound =
  | string
  | Array<string>
  | Array<number>
  | Array<Array<number>>;

/** @internal */
export const Input$outboundSchema: z.ZodType<Input$Outbound, Input> = z.union([
  z.string(),
  z.array(z.string()),
  z.array(z.number()),
  z.array(z.array(z.number())),
]);

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace Input$ {
  /** @deprecated use `Input$inboundSchema` instead. */
  export const inboundSchema = Input$inboundSchema;
  /** @deprecated use `Input$outboundSchema` instead. */
  export const outboundSchema = Input$outboundSchema;
  /** @deprecated use `Input$Outbound` instead. */
  export type Outbound = Input$Outbound;
}

export function inputToJSON(input: Input): string {
  return JSON.stringify(Input$outboundSchema.parse(input));
}

export function inputFromJSON(
  jsonString: string,
): SafeParseResult<Input, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => Input$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'Input' from JSON`,
  );
}

/** @internal */
export const DataCollection$inboundSchema: z.ZodType<DataCollection, unknown> =
  z
    .union([
      z.enum(DataCollection),
      z.string().transform(catchUnrecognizedEnum),
    ]);

/** @internal */
export const DataCollection$outboundSchema: z.ZodType<
  DataCollection,
  DataCollection
> = z.union([
  z.enum(DataCollection),
  z.string().and(z.custom<Unrecognized<string>>()),
]);

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace DataCollection$ {
  /** @deprecated use `DataCollection$inboundSchema` instead. */
  export const inboundSchema = DataCollection$inboundSchema;
  /** @deprecated use `DataCollection$outboundSchema` instead. */
  export const outboundSchema = DataCollection$outboundSchema;
}

/** @internal */
export const Order$inboundSchema: z.ZodType<Order, unknown> = z.union([
  models.ProviderName$inboundSchema,
  z.string(),
]);

/** @internal */
export type Order$Outbound = string | string;

/** @internal */
export const Order$outboundSchema: z.ZodType<Order$Outbound, Order> = z.union([
  models.ProviderName$outboundSchema,
  z.string(),
]);

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace Order$ {
  /** @deprecated use `Order$inboundSchema` instead. */
  export const inboundSchema = Order$inboundSchema;
  /** @deprecated use `Order$outboundSchema` instead. */
  export const outboundSchema = Order$outboundSchema;
  /** @deprecated use `Order$Outbound` instead. */
  export type Outbound = Order$Outbound;
}

export function orderToJSON(order: Order): string {
  return JSON.stringify(Order$outboundSchema.parse(order));
}

export function orderFromJSON(
  jsonString: string,
): SafeParseResult<Order, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => Order$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'Order' from JSON`,
  );
}

/** @internal */
export const Only$inboundSchema: z.ZodType<Only, unknown> = z.union([
  models.ProviderName$inboundSchema,
  z.string(),
]);

/** @internal */
export type Only$Outbound = string | string;

/** @internal */
export const Only$outboundSchema: z.ZodType<Only$Outbound, Only> = z.union([
  models.ProviderName$outboundSchema,
  z.string(),
]);

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace Only$ {
  /** @deprecated use `Only$inboundSchema` instead. */
  export const inboundSchema = Only$inboundSchema;
  /** @deprecated use `Only$outboundSchema` instead. */
  export const outboundSchema = Only$outboundSchema;
  /** @deprecated use `Only$Outbound` instead. */
  export type Outbound = Only$Outbound;
}

export function onlyToJSON(only: Only): string {
  return JSON.stringify(Only$outboundSchema.parse(only));
}

export function onlyFromJSON(
  jsonString: string,
): SafeParseResult<Only, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => Only$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'Only' from JSON`,
  );
}

/** @internal */
export const Ignore$inboundSchema: z.ZodType<Ignore, unknown> = z.union([
  models.ProviderName$inboundSchema,
  z.string(),
]);

/** @internal */
export type Ignore$Outbound = string | string;

/** @internal */
export const Ignore$outboundSchema: z.ZodType<Ignore$Outbound, Ignore> = z
  .union([models.ProviderName$outboundSchema, z.string()]);

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace Ignore$ {
  /** @deprecated use `Ignore$inboundSchema` instead. */
  export const inboundSchema = Ignore$inboundSchema;
  /** @deprecated use `Ignore$outboundSchema` instead. */
  export const outboundSchema = Ignore$outboundSchema;
  /** @deprecated use `Ignore$Outbound` instead. */
  export type Outbound = Ignore$Outbound;
}

export function ignoreToJSON(ignore: Ignore): string {
  return JSON.stringify(Ignore$outboundSchema.parse(ignore));
}

export function ignoreFromJSON(
  jsonString: string,
): SafeParseResult<Ignore, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => Ignore$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'Ignore' from JSON`,
  );
}

/** @internal */
export const Sort$inboundSchema: z.ZodType<Sort, unknown> = z
  .union([
    z.enum(Sort),
    z.string().transform(catchUnrecognizedEnum),
  ]);

/** @internal */
export const Sort$outboundSchema: z.ZodType<Sort, Sort> = z.union([
  z.enum(Sort),
  z.string().and(z.custom<Unrecognized<string>>()),
]);

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace Sort$ {
  /** @deprecated use `Sort$inboundSchema` instead. */
  export const inboundSchema = Sort$inboundSchema;
  /** @deprecated use `Sort$outboundSchema` instead. */
  export const outboundSchema = Sort$outboundSchema;
}

/** @internal */
export const MaxPrice$inboundSchema: z.ZodType<MaxPrice, unknown> = z.object({
  prompt: z.any().optional(),
  completion: z.any().optional(),
  image: z.any().optional(),
  audio: z.any().optional(),
  request: z.any().optional(),
});

/** @internal */
export type MaxPrice$Outbound = {
  prompt?: any | undefined;
  completion?: any | undefined;
  image?: any | undefined;
  audio?: any | undefined;
  request?: any | undefined;
};

/** @internal */
export const MaxPrice$outboundSchema: z.ZodType<MaxPrice$Outbound, MaxPrice> = z
  .object({
    prompt: z.any().optional(),
    completion: z.any().optional(),
    image: z.any().optional(),
    audio: z.any().optional(),
    request: z.any().optional(),
  });

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace MaxPrice$ {
  /** @deprecated use `MaxPrice$inboundSchema` instead. */
  export const inboundSchema = MaxPrice$inboundSchema;
  /** @deprecated use `MaxPrice$outboundSchema` instead. */
  export const outboundSchema = MaxPrice$outboundSchema;
  /** @deprecated use `MaxPrice$Outbound` instead. */
  export type Outbound = MaxPrice$Outbound;
}

export function maxPriceToJSON(maxPrice: MaxPrice): string {
  return JSON.stringify(MaxPrice$outboundSchema.parse(maxPrice));
}

export function maxPriceFromJSON(
  jsonString: string,
): SafeParseResult<MaxPrice, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => MaxPrice$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'MaxPrice' from JSON`,
  );
}

/** @internal */
export const Experimental$inboundSchema: z.ZodType<Experimental, unknown> = z
  .object({});

/** @internal */
export type Experimental$Outbound = {};

/** @internal */
export const Experimental$outboundSchema: z.ZodType<
  Experimental$Outbound,
  Experimental
> = z.object({});

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace Experimental$ {
  /** @deprecated use `Experimental$inboundSchema` instead. */
  export const inboundSchema = Experimental$inboundSchema;
  /** @deprecated use `Experimental$outboundSchema` instead. */
  export const outboundSchema = Experimental$outboundSchema;
  /** @deprecated use `Experimental$Outbound` instead. */
  export type Outbound = Experimental$Outbound;
}

export function experimentalToJSON(experimental: Experimental): string {
  return JSON.stringify(Experimental$outboundSchema.parse(experimental));
}

export function experimentalFromJSON(
  jsonString: string,
): SafeParseResult<Experimental, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => Experimental$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'Experimental' from JSON`,
  );
}

/** @internal */
export const CreateEmbeddingsProvider$inboundSchema: z.ZodType<
  CreateEmbeddingsProvider,
  unknown
> = z.object({
  allow_fallbacks: z.nullable(z.boolean()).optional(),
  require_parameters: z.nullable(z.boolean()).optional(),
  data_collection: z.nullable(DataCollection$inboundSchema).optional(),
  zdr: z.nullable(z.boolean()).optional(),
  order: z.nullable(
    z.array(z.union([models.ProviderName$inboundSchema, z.string()])),
  ).optional(),
  only: z.nullable(
    z.array(z.union([models.ProviderName$inboundSchema, z.string()])),
  ).optional(),
  ignore: z.nullable(
    z.array(z.union([models.ProviderName$inboundSchema, z.string()])),
  ).optional(),
  quantizations: z.nullable(z.array(models.Quantization$inboundSchema))
    .optional(),
  sort: z.nullable(Sort$inboundSchema).optional(),
  max_price: z.lazy(() => MaxPrice$inboundSchema).optional(),
  experimental: z.nullable(z.lazy(() => Experimental$inboundSchema)).optional(),
}).transform((v) => {
  return remap$(v, {
    "allow_fallbacks": "allowFallbacks",
    "require_parameters": "requireParameters",
    "data_collection": "dataCollection",
    "max_price": "maxPrice",
  });
});

/** @internal */
export type CreateEmbeddingsProvider$Outbound = {
  allow_fallbacks?: boolean | null | undefined;
  require_parameters?: boolean | null | undefined;
  data_collection?: string | null | undefined;
  zdr?: boolean | null | undefined;
  order?: Array<string | string> | null | undefined;
  only?: Array<string | string> | null | undefined;
  ignore?: Array<string | string> | null | undefined;
  quantizations?: Array<string> | null | undefined;
  sort?: string | null | undefined;
  max_price?: MaxPrice$Outbound | undefined;
  experimental?: Experimental$Outbound | null | undefined;
};

/** @internal */
export const CreateEmbeddingsProvider$outboundSchema: z.ZodType<
  CreateEmbeddingsProvider$Outbound,
  CreateEmbeddingsProvider
> = z.object({
  allowFallbacks: z.nullable(z.boolean()).optional(),
  requireParameters: z.nullable(z.boolean()).optional(),
  dataCollection: z.nullable(DataCollection$outboundSchema).optional(),
  zdr: z.nullable(z.boolean()).optional(),
  order: z.nullable(
    z.array(z.union([models.ProviderName$outboundSchema, z.string()])),
  ).optional(),
  only: z.nullable(
    z.array(z.union([models.ProviderName$outboundSchema, z.string()])),
  ).optional(),
  ignore: z.nullable(
    z.array(z.union([models.ProviderName$outboundSchema, z.string()])),
  ).optional(),
  quantizations: z.nullable(z.array(models.Quantization$outboundSchema))
    .optional(),
  sort: z.nullable(Sort$outboundSchema).optional(),
  maxPrice: z.lazy(() => MaxPrice$outboundSchema).optional(),
  experimental: z.nullable(z.lazy(() => Experimental$outboundSchema))
    .optional(),
}).transform((v) => {
  return remap$(v, {
    allowFallbacks: "allow_fallbacks",
    requireParameters: "require_parameters",
    dataCollection: "data_collection",
    maxPrice: "max_price",
  });
});

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace CreateEmbeddingsProvider$ {
  /** @deprecated use `CreateEmbeddingsProvider$inboundSchema` instead. */
  export const inboundSchema = CreateEmbeddingsProvider$inboundSchema;
  /** @deprecated use `CreateEmbeddingsProvider$outboundSchema` instead. */
  export const outboundSchema = CreateEmbeddingsProvider$outboundSchema;
  /** @deprecated use `CreateEmbeddingsProvider$Outbound` instead. */
  export type Outbound = CreateEmbeddingsProvider$Outbound;
}

export function createEmbeddingsProviderToJSON(
  createEmbeddingsProvider: CreateEmbeddingsProvider,
): string {
  return JSON.stringify(
    CreateEmbeddingsProvider$outboundSchema.parse(createEmbeddingsProvider),
  );
}

export function createEmbeddingsProviderFromJSON(
  jsonString: string,
): SafeParseResult<CreateEmbeddingsProvider, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => CreateEmbeddingsProvider$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'CreateEmbeddingsProvider' from JSON`,
  );
}

/** @internal */
export const EncodingFormatBase64$inboundSchema: z.ZodEnum<
  typeof EncodingFormatBase64
> = z.enum(EncodingFormatBase64);

/** @internal */
export const EncodingFormatBase64$outboundSchema: z.ZodEnum<
  typeof EncodingFormatBase64
> = EncodingFormatBase64$inboundSchema;

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace EncodingFormatBase64$ {
  /** @deprecated use `EncodingFormatBase64$inboundSchema` instead. */
  export const inboundSchema = EncodingFormatBase64$inboundSchema;
  /** @deprecated use `EncodingFormatBase64$outboundSchema` instead. */
  export const outboundSchema = EncodingFormatBase64$outboundSchema;
}

/** @internal */
export const EncodingFormatFloat$inboundSchema: z.ZodEnum<
  typeof EncodingFormatFloat
> = z.enum(EncodingFormatFloat);

/** @internal */
export const EncodingFormatFloat$outboundSchema: z.ZodEnum<
  typeof EncodingFormatFloat
> = EncodingFormatFloat$inboundSchema;

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace EncodingFormatFloat$ {
  /** @deprecated use `EncodingFormatFloat$inboundSchema` instead. */
  export const inboundSchema = EncodingFormatFloat$inboundSchema;
  /** @deprecated use `EncodingFormatFloat$outboundSchema` instead. */
  export const outboundSchema = EncodingFormatFloat$outboundSchema;
}

/** @internal */
export const EncodingFormat$inboundSchema: z.ZodType<EncodingFormat, unknown> =
  z.union([
    EncodingFormatFloat$inboundSchema,
    EncodingFormatBase64$inboundSchema,
  ]);

/** @internal */
export type EncodingFormat$Outbound = string | string;

/** @internal */
export const EncodingFormat$outboundSchema: z.ZodType<
  EncodingFormat$Outbound,
  EncodingFormat
> = z.union([
  EncodingFormatFloat$outboundSchema,
  EncodingFormatBase64$outboundSchema,
]);

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace EncodingFormat$ {
  /** @deprecated use `EncodingFormat$inboundSchema` instead. */
  export const inboundSchema = EncodingFormat$inboundSchema;
  /** @deprecated use `EncodingFormat$outboundSchema` instead. */
  export const outboundSchema = EncodingFormat$outboundSchema;
  /** @deprecated use `EncodingFormat$Outbound` instead. */
  export type Outbound = EncodingFormat$Outbound;
}

export function encodingFormatToJSON(encodingFormat: EncodingFormat): string {
  return JSON.stringify(EncodingFormat$outboundSchema.parse(encodingFormat));
}

export function encodingFormatFromJSON(
  jsonString: string,
): SafeParseResult<EncodingFormat, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => EncodingFormat$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'EncodingFormat' from JSON`,
  );
}

/** @internal */
export const CreateEmbeddingsRequest$inboundSchema: z.ZodType<
  CreateEmbeddingsRequest,
  unknown
> = z.object({
  input: z.union([
    z.string(),
    z.array(z.string()),
    z.array(z.number()),
    z.array(z.array(z.number())),
  ]),
  model: z.string(),
  provider: z.lazy(() => CreateEmbeddingsProvider$inboundSchema).optional(),
  encoding_format: z.union([
    EncodingFormatFloat$inboundSchema,
    EncodingFormatBase64$inboundSchema,
  ]).optional(),
  user: z.string().optional(),
}).transform((v) => {
  return remap$(v, {
    "encoding_format": "encodingFormat",
  });
});

/** @internal */
export type CreateEmbeddingsRequest$Outbound = {
  input: string | Array<string> | Array<number> | Array<Array<number>>;
  model: string;
  provider?: CreateEmbeddingsProvider$Outbound | undefined;
  encoding_format?: string | string | undefined;
  user?: string | undefined;
};

/** @internal */
export const CreateEmbeddingsRequest$outboundSchema: z.ZodType<
  CreateEmbeddingsRequest$Outbound,
  CreateEmbeddingsRequest
> = z.object({
  input: z.union([
    z.string(),
    z.array(z.string()),
    z.array(z.number()),
    z.array(z.array(z.number())),
  ]),
  model: z.string(),
  provider: z.lazy(() => CreateEmbeddingsProvider$outboundSchema).optional(),
  encodingFormat: z.union([
    EncodingFormatFloat$outboundSchema,
    EncodingFormatBase64$outboundSchema,
  ]).optional(),
  user: z.string().optional(),
}).transform((v) => {
  return remap$(v, {
    encodingFormat: "encoding_format",
  });
});

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace CreateEmbeddingsRequest$ {
  /** @deprecated use `CreateEmbeddingsRequest$inboundSchema` instead. */
  export const inboundSchema = CreateEmbeddingsRequest$inboundSchema;
  /** @deprecated use `CreateEmbeddingsRequest$outboundSchema` instead. */
  export const outboundSchema = CreateEmbeddingsRequest$outboundSchema;
  /** @deprecated use `CreateEmbeddingsRequest$Outbound` instead. */
  export type Outbound = CreateEmbeddingsRequest$Outbound;
}

export function createEmbeddingsRequestToJSON(
  createEmbeddingsRequest: CreateEmbeddingsRequest,
): string {
  return JSON.stringify(
    CreateEmbeddingsRequest$outboundSchema.parse(createEmbeddingsRequest),
  );
}

export function createEmbeddingsRequestFromJSON(
  jsonString: string,
): SafeParseResult<CreateEmbeddingsRequest, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => CreateEmbeddingsRequest$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'CreateEmbeddingsRequest' from JSON`,
  );
}

/** @internal */
export const ObjectT$inboundSchema: z.ZodEnum<typeof ObjectT> = z.enum(ObjectT);

/** @internal */
export const ObjectT$outboundSchema: z.ZodEnum<typeof ObjectT> =
  ObjectT$inboundSchema;

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace ObjectT$ {
  /** @deprecated use `ObjectT$inboundSchema` instead. */
  export const inboundSchema = ObjectT$inboundSchema;
  /** @deprecated use `ObjectT$outboundSchema` instead. */
  export const outboundSchema = ObjectT$outboundSchema;
}

/** @internal */
export const ObjectEmbedding$inboundSchema: z.ZodEnum<typeof ObjectEmbedding> =
  z.enum(ObjectEmbedding);

/** @internal */
export const ObjectEmbedding$outboundSchema: z.ZodEnum<typeof ObjectEmbedding> =
  ObjectEmbedding$inboundSchema;

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace ObjectEmbedding$ {
  /** @deprecated use `ObjectEmbedding$inboundSchema` instead. */
  export const inboundSchema = ObjectEmbedding$inboundSchema;
  /** @deprecated use `ObjectEmbedding$outboundSchema` instead. */
  export const outboundSchema = ObjectEmbedding$outboundSchema;
}

/** @internal */
export const Embedding$inboundSchema: z.ZodType<Embedding, unknown> = z.union([
  z.array(z.number()),
  z.string(),
]);

/** @internal */
export type Embedding$Outbound = Array<number> | string;

/** @internal */
export const Embedding$outboundSchema: z.ZodType<
  Embedding$Outbound,
  Embedding
> = z.union([z.array(z.number()), z.string()]);

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace Embedding$ {
  /** @deprecated use `Embedding$inboundSchema` instead. */
  export const inboundSchema = Embedding$inboundSchema;
  /** @deprecated use `Embedding$outboundSchema` instead. */
  export const outboundSchema = Embedding$outboundSchema;
  /** @deprecated use `Embedding$Outbound` instead. */
  export type Outbound = Embedding$Outbound;
}

export function embeddingToJSON(embedding: Embedding): string {
  return JSON.stringify(Embedding$outboundSchema.parse(embedding));
}

export function embeddingFromJSON(
  jsonString: string,
): SafeParseResult<Embedding, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => Embedding$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'Embedding' from JSON`,
  );
}

/** @internal */
export const CreateEmbeddingsData$inboundSchema: z.ZodType<
  CreateEmbeddingsData,
  unknown
> = z.object({
  object: ObjectEmbedding$inboundSchema,
  embedding: z.union([z.array(z.number()), z.string()]),
  index: z.number().optional(),
});

/** @internal */
export type CreateEmbeddingsData$Outbound = {
  object: string;
  embedding: Array<number> | string;
  index?: number | undefined;
};

/** @internal */
export const CreateEmbeddingsData$outboundSchema: z.ZodType<
  CreateEmbeddingsData$Outbound,
  CreateEmbeddingsData
> = z.object({
  object: ObjectEmbedding$outboundSchema,
  embedding: z.union([z.array(z.number()), z.string()]),
  index: z.number().optional(),
});

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace CreateEmbeddingsData$ {
  /** @deprecated use `CreateEmbeddingsData$inboundSchema` instead. */
  export const inboundSchema = CreateEmbeddingsData$inboundSchema;
  /** @deprecated use `CreateEmbeddingsData$outboundSchema` instead. */
  export const outboundSchema = CreateEmbeddingsData$outboundSchema;
  /** @deprecated use `CreateEmbeddingsData$Outbound` instead. */
  export type Outbound = CreateEmbeddingsData$Outbound;
}

export function createEmbeddingsDataToJSON(
  createEmbeddingsData: CreateEmbeddingsData,
): string {
  return JSON.stringify(
    CreateEmbeddingsData$outboundSchema.parse(createEmbeddingsData),
  );
}

export function createEmbeddingsDataFromJSON(
  jsonString: string,
): SafeParseResult<CreateEmbeddingsData, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => CreateEmbeddingsData$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'CreateEmbeddingsData' from JSON`,
  );
}

/** @internal */
export const Usage$inboundSchema: z.ZodType<Usage, unknown> = z.object({
  prompt_tokens: z.number(),
  total_tokens: z.number(),
  cost: z.number().optional(),
}).transform((v) => {
  return remap$(v, {
    "prompt_tokens": "promptTokens",
    "total_tokens": "totalTokens",
  });
});

/** @internal */
export type Usage$Outbound = {
  prompt_tokens: number;
  total_tokens: number;
  cost?: number | undefined;
};

/** @internal */
export const Usage$outboundSchema: z.ZodType<Usage$Outbound, Usage> = z.object({
  promptTokens: z.number(),
  totalTokens: z.number(),
  cost: z.number().optional(),
}).transform((v) => {
  return remap$(v, {
    promptTokens: "prompt_tokens",
    totalTokens: "total_tokens",
  });
});

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace Usage$ {
  /** @deprecated use `Usage$inboundSchema` instead. */
  export const inboundSchema = Usage$inboundSchema;
  /** @deprecated use `Usage$outboundSchema` instead. */
  export const outboundSchema = Usage$outboundSchema;
  /** @deprecated use `Usage$Outbound` instead. */
  export type Outbound = Usage$Outbound;
}

export function usageToJSON(usage: Usage): string {
  return JSON.stringify(Usage$outboundSchema.parse(usage));
}

export function usageFromJSON(
  jsonString: string,
): SafeParseResult<Usage, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => Usage$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'Usage' from JSON`,
  );
}

/** @internal */
export const CreateEmbeddingsResponseBody$inboundSchema: z.ZodType<
  CreateEmbeddingsResponseBody,
  unknown
> = z.object({
  id: z.string().optional(),
  object: ObjectT$inboundSchema,
  data: z.array(z.lazy(() => CreateEmbeddingsData$inboundSchema)),
  model: z.string(),
  usage: z.lazy(() => Usage$inboundSchema).optional(),
});

/** @internal */
export type CreateEmbeddingsResponseBody$Outbound = {
  id?: string | undefined;
  object: string;
  data: Array<CreateEmbeddingsData$Outbound>;
  model: string;
  usage?: Usage$Outbound | undefined;
};

/** @internal */
export const CreateEmbeddingsResponseBody$outboundSchema: z.ZodType<
  CreateEmbeddingsResponseBody$Outbound,
  CreateEmbeddingsResponseBody
> = z.object({
  id: z.string().optional(),
  object: ObjectT$outboundSchema,
  data: z.array(z.lazy(() => CreateEmbeddingsData$outboundSchema)),
  model: z.string(),
  usage: z.lazy(() => Usage$outboundSchema).optional(),
});

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace CreateEmbeddingsResponseBody$ {
  /** @deprecated use `CreateEmbeddingsResponseBody$inboundSchema` instead. */
  export const inboundSchema = CreateEmbeddingsResponseBody$inboundSchema;
  /** @deprecated use `CreateEmbeddingsResponseBody$outboundSchema` instead. */
  export const outboundSchema = CreateEmbeddingsResponseBody$outboundSchema;
  /** @deprecated use `CreateEmbeddingsResponseBody$Outbound` instead. */
  export type Outbound = CreateEmbeddingsResponseBody$Outbound;
}

export function createEmbeddingsResponseBodyToJSON(
  createEmbeddingsResponseBody: CreateEmbeddingsResponseBody,
): string {
  return JSON.stringify(
    CreateEmbeddingsResponseBody$outboundSchema.parse(
      createEmbeddingsResponseBody,
    ),
  );
}

export function createEmbeddingsResponseBodyFromJSON(
  jsonString: string,
): SafeParseResult<CreateEmbeddingsResponseBody, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => CreateEmbeddingsResponseBody$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'CreateEmbeddingsResponseBody' from JSON`,
  );
}

/** @internal */
export const CreateEmbeddingsResponse$inboundSchema: z.ZodType<
  CreateEmbeddingsResponse,
  unknown
> = z.union([
  z.lazy(() => CreateEmbeddingsResponseBody$inboundSchema),
  z.string(),
]);

/** @internal */
export type CreateEmbeddingsResponse$Outbound =
  | CreateEmbeddingsResponseBody$Outbound
  | string;

/** @internal */
export const CreateEmbeddingsResponse$outboundSchema: z.ZodType<
  CreateEmbeddingsResponse$Outbound,
  CreateEmbeddingsResponse
> = z.union([
  z.lazy(() => CreateEmbeddingsResponseBody$outboundSchema),
  z.string(),
]);

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace CreateEmbeddingsResponse$ {
  /** @deprecated use `CreateEmbeddingsResponse$inboundSchema` instead. */
  export const inboundSchema = CreateEmbeddingsResponse$inboundSchema;
  /** @deprecated use `CreateEmbeddingsResponse$outboundSchema` instead. */
  export const outboundSchema = CreateEmbeddingsResponse$outboundSchema;
  /** @deprecated use `CreateEmbeddingsResponse$Outbound` instead. */
  export type Outbound = CreateEmbeddingsResponse$Outbound;
}

export function createEmbeddingsResponseToJSON(
  createEmbeddingsResponse: CreateEmbeddingsResponse,
): string {
  return JSON.stringify(
    CreateEmbeddingsResponse$outboundSchema.parse(createEmbeddingsResponse),
  );
}

export function createEmbeddingsResponseFromJSON(
  jsonString: string,
): SafeParseResult<CreateEmbeddingsResponse, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => CreateEmbeddingsResponse$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'CreateEmbeddingsResponse' from JSON`,
  );
}
