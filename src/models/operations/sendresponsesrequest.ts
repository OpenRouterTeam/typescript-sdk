/*
 * Code generated by Speakeasy (https://speakeasy.com). DO NOT EDIT.
 */

import * as z from "zod";
import { EventStream } from "../../lib/event-streams.js";
import { remap as remap$ } from "../../lib/primitives.js";
import { safeParse } from "../../lib/schemas.js";
import { ClosedEnum } from "../../types/enums.js";
import { Result as SafeParseResult } from "../../types/fp.js";
import { SDKValidationError } from "../errors/sdkvalidationerror.js";
import * as models from "../index.js";

export const ServiceTier = {
  Auto: "auto",
  Default: "default",
  Flex: "flex",
  Priority: "priority",
  Scale: "scale",
} as const;
export type ServiceTier = ClosedEnum<typeof ServiceTier>;

export const Truncation = {
  Auto: "auto",
  Disabled: "disabled",
} as const;
export type Truncation = ClosedEnum<typeof Truncation>;

/**
 * Data collection setting. If no available model provider meets the requirement, your request will return an error.
 *
 * @remarks
 * - allow: (default) allow providers which store user data non-transiently and may train on it
 * - deny: use only providers which do not collect user data.
 */
export const SendResponsesRequestDataCollection = {
  Deny: "deny",
  Allow: "allow",
} as const;
/**
 * Data collection setting. If no available model provider meets the requirement, your request will return an error.
 *
 * @remarks
 * - allow: (default) allow providers which store user data non-transiently and may train on it
 * - deny: use only providers which do not collect user data.
 */
export type SendResponsesRequestDataCollection = ClosedEnum<
  typeof SendResponsesRequestDataCollection
>;

export const SendResponsesRequestOrderEnum = {
  AnyScale: "AnyScale",
  CentML: "Cent-ML",
  HuggingFace: "HuggingFace",
  Hyperbolic2: "Hyperbolic 2",
  Lepton: "Lepton",
  Lynn2: "Lynn 2",
  Lynn: "Lynn",
  Mancer: "Mancer",
  Modal: "Modal",
  OctoAI: "OctoAI",
  Recursal: "Recursal",
  Reflection: "Reflection",
  Replicate: "Replicate",
  SambaNova2: "SambaNova 2",
  SFCompute: "SF Compute",
  Together2: "Together 2",
  OneDotAI: "01.AI",
  Ai21: "AI21",
  AionLabs: "AionLabs",
  Alibaba: "Alibaba",
  AmazonBedrock: "Amazon Bedrock",
  Anthropic: "Anthropic",
  AtlasCloud: "AtlasCloud",
  Atoma: "Atoma",
  Avian: "Avian",
  Azure: "Azure",
  BaseTen: "BaseTen",
  Cerebras: "Cerebras",
  Chutes: "Chutes",
  Cloudflare: "Cloudflare",
  Cohere: "Cohere",
  CrofAI: "CrofAI",
  Crusoe: "Crusoe",
  DeepInfra: "DeepInfra",
  DeepSeek: "DeepSeek",
  Enfer: "Enfer",
  Featherless: "Featherless",
  Fireworks: "Fireworks",
  Friendli: "Friendli",
  GMICloud: "GMICloud",
  Google: "Google",
  GoogleAIStudio: "Google AI Studio",
  Groq: "Groq",
  Hyperbolic: "Hyperbolic",
  Inception: "Inception",
  InferenceNet: "InferenceNet",
  Infermatic: "Infermatic",
  Inflection: "Inflection",
  InoCloud: "InoCloud",
  Kluster: "Kluster",
  Lambda: "Lambda",
  Liquid: "Liquid",
  Mancer2: "Mancer 2",
  Meta: "Meta",
  Minimax: "Minimax",
  Mistral: "Mistral",
  MoonshotAI: "Moonshot AI",
  Morph: "Morph",
  NCompass: "NCompass",
  Nebius: "Nebius",
  NextBit: "NextBit",
  Nineteen: "Nineteen",
  Novita: "Novita",
  Nvidia: "Nvidia",
  OpenAI: "OpenAI",
  OpenInference: "OpenInference",
  Parasail: "Parasail",
  Perplexity: "Perplexity",
  Phala: "Phala",
  Relace: "Relace",
  SambaNova: "SambaNova",
  SiliconFlow: "SiliconFlow",
  Stealth: "Stealth",
  Switchpoint: "Switchpoint",
  Targon: "Targon",
  Together: "Together",
  Ubicloud: "Ubicloud",
  Venice: "Venice",
  WandB: "WandB",
  XAI: "xAI",
  ZAi: "Z.AI",
  FakeProvider: "FakeProvider",
} as const;
export type SendResponsesRequestOrderEnum = ClosedEnum<
  typeof SendResponsesRequestOrderEnum
>;

export type SendResponsesRequestOrderUnion =
  | SendResponsesRequestOrderEnum
  | string;

export const SendResponsesRequestOnlyEnum = {
  AnyScale: "AnyScale",
  CentML: "Cent-ML",
  HuggingFace: "HuggingFace",
  Hyperbolic2: "Hyperbolic 2",
  Lepton: "Lepton",
  Lynn2: "Lynn 2",
  Lynn: "Lynn",
  Mancer: "Mancer",
  Modal: "Modal",
  OctoAI: "OctoAI",
  Recursal: "Recursal",
  Reflection: "Reflection",
  Replicate: "Replicate",
  SambaNova2: "SambaNova 2",
  SFCompute: "SF Compute",
  Together2: "Together 2",
  OneDotAI: "01.AI",
  Ai21: "AI21",
  AionLabs: "AionLabs",
  Alibaba: "Alibaba",
  AmazonBedrock: "Amazon Bedrock",
  Anthropic: "Anthropic",
  AtlasCloud: "AtlasCloud",
  Atoma: "Atoma",
  Avian: "Avian",
  Azure: "Azure",
  BaseTen: "BaseTen",
  Cerebras: "Cerebras",
  Chutes: "Chutes",
  Cloudflare: "Cloudflare",
  Cohere: "Cohere",
  CrofAI: "CrofAI",
  Crusoe: "Crusoe",
  DeepInfra: "DeepInfra",
  DeepSeek: "DeepSeek",
  Enfer: "Enfer",
  Featherless: "Featherless",
  Fireworks: "Fireworks",
  Friendli: "Friendli",
  GMICloud: "GMICloud",
  Google: "Google",
  GoogleAIStudio: "Google AI Studio",
  Groq: "Groq",
  Hyperbolic: "Hyperbolic",
  Inception: "Inception",
  InferenceNet: "InferenceNet",
  Infermatic: "Infermatic",
  Inflection: "Inflection",
  InoCloud: "InoCloud",
  Kluster: "Kluster",
  Lambda: "Lambda",
  Liquid: "Liquid",
  Mancer2: "Mancer 2",
  Meta: "Meta",
  Minimax: "Minimax",
  Mistral: "Mistral",
  MoonshotAI: "Moonshot AI",
  Morph: "Morph",
  NCompass: "NCompass",
  Nebius: "Nebius",
  NextBit: "NextBit",
  Nineteen: "Nineteen",
  Novita: "Novita",
  Nvidia: "Nvidia",
  OpenAI: "OpenAI",
  OpenInference: "OpenInference",
  Parasail: "Parasail",
  Perplexity: "Perplexity",
  Phala: "Phala",
  Relace: "Relace",
  SambaNova: "SambaNova",
  SiliconFlow: "SiliconFlow",
  Stealth: "Stealth",
  Switchpoint: "Switchpoint",
  Targon: "Targon",
  Together: "Together",
  Ubicloud: "Ubicloud",
  Venice: "Venice",
  WandB: "WandB",
  XAI: "xAI",
  ZAi: "Z.AI",
  FakeProvider: "FakeProvider",
} as const;
export type SendResponsesRequestOnlyEnum = ClosedEnum<
  typeof SendResponsesRequestOnlyEnum
>;

export type SendResponsesRequestOnlyUnion =
  | SendResponsesRequestOnlyEnum
  | string;

export const SendResponsesRequestIgnoreEnum = {
  AnyScale: "AnyScale",
  CentML: "Cent-ML",
  HuggingFace: "HuggingFace",
  Hyperbolic2: "Hyperbolic 2",
  Lepton: "Lepton",
  Lynn2: "Lynn 2",
  Lynn: "Lynn",
  Mancer: "Mancer",
  Modal: "Modal",
  OctoAI: "OctoAI",
  Recursal: "Recursal",
  Reflection: "Reflection",
  Replicate: "Replicate",
  SambaNova2: "SambaNova 2",
  SFCompute: "SF Compute",
  Together2: "Together 2",
  OneDotAI: "01.AI",
  Ai21: "AI21",
  AionLabs: "AionLabs",
  Alibaba: "Alibaba",
  AmazonBedrock: "Amazon Bedrock",
  Anthropic: "Anthropic",
  AtlasCloud: "AtlasCloud",
  Atoma: "Atoma",
  Avian: "Avian",
  Azure: "Azure",
  BaseTen: "BaseTen",
  Cerebras: "Cerebras",
  Chutes: "Chutes",
  Cloudflare: "Cloudflare",
  Cohere: "Cohere",
  CrofAI: "CrofAI",
  Crusoe: "Crusoe",
  DeepInfra: "DeepInfra",
  DeepSeek: "DeepSeek",
  Enfer: "Enfer",
  Featherless: "Featherless",
  Fireworks: "Fireworks",
  Friendli: "Friendli",
  GMICloud: "GMICloud",
  Google: "Google",
  GoogleAIStudio: "Google AI Studio",
  Groq: "Groq",
  Hyperbolic: "Hyperbolic",
  Inception: "Inception",
  InferenceNet: "InferenceNet",
  Infermatic: "Infermatic",
  Inflection: "Inflection",
  InoCloud: "InoCloud",
  Kluster: "Kluster",
  Lambda: "Lambda",
  Liquid: "Liquid",
  Mancer2: "Mancer 2",
  Meta: "Meta",
  Minimax: "Minimax",
  Mistral: "Mistral",
  MoonshotAI: "Moonshot AI",
  Morph: "Morph",
  NCompass: "NCompass",
  Nebius: "Nebius",
  NextBit: "NextBit",
  Nineteen: "Nineteen",
  Novita: "Novita",
  Nvidia: "Nvidia",
  OpenAI: "OpenAI",
  OpenInference: "OpenInference",
  Parasail: "Parasail",
  Perplexity: "Perplexity",
  Phala: "Phala",
  Relace: "Relace",
  SambaNova: "SambaNova",
  SiliconFlow: "SiliconFlow",
  Stealth: "Stealth",
  Switchpoint: "Switchpoint",
  Targon: "Targon",
  Together: "Together",
  Ubicloud: "Ubicloud",
  Venice: "Venice",
  WandB: "WandB",
  XAI: "xAI",
  ZAi: "Z.AI",
  FakeProvider: "FakeProvider",
} as const;
export type SendResponsesRequestIgnoreEnum = ClosedEnum<
  typeof SendResponsesRequestIgnoreEnum
>;

export type SendResponsesRequestIgnoreUnion =
  | SendResponsesRequestIgnoreEnum
  | string;

export const SendResponsesRequestQuantization = {
  Int4: "int4",
  Int8: "int8",
  Fp4: "fp4",
  Fp6: "fp6",
  Fp8: "fp8",
  Fp16: "fp16",
  Bf16: "bf16",
  Fp32: "fp32",
  Unknown: "unknown",
} as const;
export type SendResponsesRequestQuantization = ClosedEnum<
  typeof SendResponsesRequestQuantization
>;

/**
 * The sorting strategy to use for this request, if "order" is not specified. When set, no load balancing is performed.
 */
export const SendResponsesRequestSort = {
  Price: "price",
  Throughput: "throughput",
  Latency: "latency",
} as const;
/**
 * The sorting strategy to use for this request, if "order" is not specified. When set, no load balancing is performed.
 */
export type SendResponsesRequestSort = ClosedEnum<
  typeof SendResponsesRequestSort
>;

export type SendResponsesRequestPrompt = number | string | any;

export type SendResponsesRequestCompletion = number | string | any;

export type SendResponsesRequestImage = number | string | any;

export type SendResponsesRequestAudio = number | string | any;

export type SendResponsesRequestRequestUnion = number | string | any;

/**
 * The object specifying the maximum price you want to pay for this request. USD price per million tokens, for prompt and completion.
 */
export type SendResponsesRequestMaxPrice = {
  prompt?: number | string | any | undefined;
  completion?: number | string | any | undefined;
  image?: number | string | any | undefined;
  audio?: number | string | any | undefined;
  request?: number | string | any | undefined;
};

export type SendResponsesRequestExperimental = {};

/**
 * When multiple model providers are available, optionally indicate your routing preference.
 */
export type SendResponsesRequestProvider = {
  /**
   * Whether to allow backup providers to serve requests
   *
   * @remarks
   * - true: (default) when the primary provider (or your custom providers in "order") is unavailable, use the next best provider.
   * - false: use only the primary/custom provider, and return the upstream error if it's unavailable.
   */
  allowFallbacks?: boolean | null | undefined;
  /**
   * Whether to filter providers to only those that support the parameters you've provided. If this setting is omitted or set to false, then providers will receive only the parameters they support, and ignore the rest.
   */
  requireParameters?: boolean | null | undefined;
  /**
   * Data collection setting. If no available model provider meets the requirement, your request will return an error.
   *
   * @remarks
   * - allow: (default) allow providers which store user data non-transiently and may train on it
   * - deny: use only providers which do not collect user data.
   */
  dataCollection?: SendResponsesRequestDataCollection | null | undefined;
  /**
   * Whether to restrict routing to only ZDR (Zero Data Retention) endpoints. When true, only endpoints that do not retain prompts will be used.
   */
  zdr?: boolean | null | undefined;
  /**
   * An ordered list of provider slugs. The router will attempt to use the first provider in the subset of this list that supports your requested model, and fall back to the next if it is unavailable. If no providers are available, the request will fail with an error message.
   */
  order?: Array<SendResponsesRequestOrderEnum | string> | null | undefined;
  /**
   * List of provider slugs to allow. If provided, this list is merged with your account-wide allowed provider settings for this request.
   */
  only?: Array<SendResponsesRequestOnlyEnum | string> | null | undefined;
  /**
   * List of provider slugs to ignore. If provided, this list is merged with your account-wide ignored provider settings for this request.
   */
  ignore?: Array<SendResponsesRequestIgnoreEnum | string> | null | undefined;
  /**
   * A list of quantization levels to filter the provider by.
   */
  quantizations?: Array<SendResponsesRequestQuantization> | null | undefined;
  /**
   * The sorting strategy to use for this request, if "order" is not specified. When set, no load balancing is performed.
   */
  sort?: SendResponsesRequestSort | null | undefined;
  /**
   * The object specifying the maximum price you want to pay for this request. USD price per million tokens, for prompt and completion.
   */
  maxPrice?: SendResponsesRequestMaxPrice | undefined;
  experimental?: SendResponsesRequestExperimental | null | undefined;
};

export const IdFileParser = {
  FileParser: "file-parser",
} as const;
export type IdFileParser = ClosedEnum<typeof IdFileParser>;

export const PdfEngine = {
  MistralOcr: "mistral-ocr",
  PdfText: "pdf-text",
  Native: "native",
} as const;
export type PdfEngine = ClosedEnum<typeof PdfEngine>;

export type Pdf = {
  engine?: PdfEngine | undefined;
};

export type PluginFileParser = {
  id: IdFileParser;
  maxFiles?: number | undefined;
  pdf?: Pdf | undefined;
};

export const IdChainOfThought = {
  ChainOfThought: "chain-of-thought",
} as const;
export type IdChainOfThought = ClosedEnum<typeof IdChainOfThought>;

export type PluginChainOfThought = {
  id: IdChainOfThought;
};

export const IdWeb = {
  Web: "web",
} as const;
export type IdWeb = ClosedEnum<typeof IdWeb>;

export const Engine = {
  Native: "native",
  Exa: "exa",
} as const;
export type Engine = ClosedEnum<typeof Engine>;

export type PluginWeb = {
  id: IdWeb;
  maxResults?: number | undefined;
  searchPrompt?: string | undefined;
  engine?: Engine | undefined;
};

export const IdModeration = {
  Moderation: "moderation",
} as const;
export type IdModeration = ClosedEnum<typeof IdModeration>;

export type PluginModeration = {
  id: IdModeration;
};

export type Plugin =
  | PluginModeration
  | PluginWeb
  | PluginChainOfThought
  | PluginFileParser;

/**
 * Request schema for OpenAI-compatible Responses API
 */
export type SendResponsesRequestRequest = {
  /**
   * Input for Responses API (can be a string or array of input items)
   */
  input?: models.ResponseInput | undefined;
  instructions?: string | null | undefined;
  /**
   * Metadata for Responses API requests (max 16 pairs, keys ≤64 chars, values ≤512 chars)
   */
  metadata?: { [k: string]: string } | null | undefined;
  tools?: Array<models.Tool> | undefined;
  /**
   * Tool choice configuration
   */
  toolChoice?: models.ToolChoiceUnion | undefined;
  parallelToolCalls?: boolean | null | undefined;
  model?: string | undefined;
  models?: Array<string> | undefined;
  /**
   * Text configuration for Responses API
   */
  text?: models.ResponseTextConfig | undefined;
  /**
   * Reasoning configuration for Responses API
   */
  reasoning?: models.ResponseReasoningConfig | null | undefined;
  maxOutputTokens?: number | null | undefined;
  temperature?: number | null | undefined;
  topP?: number | null | undefined;
  topK?: number | undefined;
  promptCacheKey?: string | undefined;
  previousResponseId?: string | null | undefined;
  /**
   * Prompt configuration with variables
   */
  prompt?: models.ResponsePrompt | null | undefined;
  include?: Array<models.ResponseIncludable> | null | undefined;
  background?: boolean | null | undefined;
  safetyIdentifier?: string | undefined;
  store?: boolean | null | undefined;
  serviceTier?: ServiceTier | null | undefined;
  truncation?: Truncation | null | undefined;
  stream?: boolean | null | undefined;
  /**
   * When multiple model providers are available, optionally indicate your routing preference.
   */
  provider?: SendResponsesRequestProvider | null | undefined;
  /**
   * Plugins you want to enable for this request, including their settings.
   */
  plugins?:
    | Array<
      PluginModeration | PluginWeb | PluginChainOfThought | PluginFileParser
    >
    | undefined;
  /**
   * A unique identifier representing your end-user, which helps distinguish between different users of your app. This allows your app to identify specific users in case of abuse reports, preventing your entire app from being affected by the actions of individual users. Maximum of 128 characters.
   */
  user?: string | undefined;
};

/**
 * Successful response
 */
export type SendResponsesRequestResponseBody = {
  /**
   * Streaming chunk from Responses API
   */
  data: models.ResponsesStreamChunkUnion;
};

export type SendResponsesRequestResponse =
  | models.ResponsesNonStreamingResponse
  | EventStream<SendResponsesRequestResponseBody>;

/** @internal */
export const ServiceTier$inboundSchema: z.ZodNativeEnum<typeof ServiceTier> = z
  .nativeEnum(ServiceTier);

/** @internal */
export const ServiceTier$outboundSchema: z.ZodNativeEnum<typeof ServiceTier> =
  ServiceTier$inboundSchema;

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace ServiceTier$ {
  /** @deprecated use `ServiceTier$inboundSchema` instead. */
  export const inboundSchema = ServiceTier$inboundSchema;
  /** @deprecated use `ServiceTier$outboundSchema` instead. */
  export const outboundSchema = ServiceTier$outboundSchema;
}

/** @internal */
export const Truncation$inboundSchema: z.ZodNativeEnum<typeof Truncation> = z
  .nativeEnum(Truncation);

/** @internal */
export const Truncation$outboundSchema: z.ZodNativeEnum<typeof Truncation> =
  Truncation$inboundSchema;

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace Truncation$ {
  /** @deprecated use `Truncation$inboundSchema` instead. */
  export const inboundSchema = Truncation$inboundSchema;
  /** @deprecated use `Truncation$outboundSchema` instead. */
  export const outboundSchema = Truncation$outboundSchema;
}

/** @internal */
export const SendResponsesRequestDataCollection$inboundSchema: z.ZodNativeEnum<
  typeof SendResponsesRequestDataCollection
> = z.nativeEnum(SendResponsesRequestDataCollection);

/** @internal */
export const SendResponsesRequestDataCollection$outboundSchema: z.ZodNativeEnum<
  typeof SendResponsesRequestDataCollection
> = SendResponsesRequestDataCollection$inboundSchema;

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace SendResponsesRequestDataCollection$ {
  /** @deprecated use `SendResponsesRequestDataCollection$inboundSchema` instead. */
  export const inboundSchema = SendResponsesRequestDataCollection$inboundSchema;
  /** @deprecated use `SendResponsesRequestDataCollection$outboundSchema` instead. */
  export const outboundSchema =
    SendResponsesRequestDataCollection$outboundSchema;
}

/** @internal */
export const SendResponsesRequestOrderEnum$inboundSchema: z.ZodNativeEnum<
  typeof SendResponsesRequestOrderEnum
> = z.nativeEnum(SendResponsesRequestOrderEnum);

/** @internal */
export const SendResponsesRequestOrderEnum$outboundSchema: z.ZodNativeEnum<
  typeof SendResponsesRequestOrderEnum
> = SendResponsesRequestOrderEnum$inboundSchema;

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace SendResponsesRequestOrderEnum$ {
  /** @deprecated use `SendResponsesRequestOrderEnum$inboundSchema` instead. */
  export const inboundSchema = SendResponsesRequestOrderEnum$inboundSchema;
  /** @deprecated use `SendResponsesRequestOrderEnum$outboundSchema` instead. */
  export const outboundSchema = SendResponsesRequestOrderEnum$outboundSchema;
}

/** @internal */
export const SendResponsesRequestOrderUnion$inboundSchema: z.ZodType<
  SendResponsesRequestOrderUnion,
  z.ZodTypeDef,
  unknown
> = z.union([SendResponsesRequestOrderEnum$inboundSchema, z.string()]);

/** @internal */
export type SendResponsesRequestOrderUnion$Outbound = string | string;

/** @internal */
export const SendResponsesRequestOrderUnion$outboundSchema: z.ZodType<
  SendResponsesRequestOrderUnion$Outbound,
  z.ZodTypeDef,
  SendResponsesRequestOrderUnion
> = z.union([SendResponsesRequestOrderEnum$outboundSchema, z.string()]);

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace SendResponsesRequestOrderUnion$ {
  /** @deprecated use `SendResponsesRequestOrderUnion$inboundSchema` instead. */
  export const inboundSchema = SendResponsesRequestOrderUnion$inboundSchema;
  /** @deprecated use `SendResponsesRequestOrderUnion$outboundSchema` instead. */
  export const outboundSchema = SendResponsesRequestOrderUnion$outboundSchema;
  /** @deprecated use `SendResponsesRequestOrderUnion$Outbound` instead. */
  export type Outbound = SendResponsesRequestOrderUnion$Outbound;
}

export function sendResponsesRequestOrderUnionToJSON(
  sendResponsesRequestOrderUnion: SendResponsesRequestOrderUnion,
): string {
  return JSON.stringify(
    SendResponsesRequestOrderUnion$outboundSchema.parse(
      sendResponsesRequestOrderUnion,
    ),
  );
}

export function sendResponsesRequestOrderUnionFromJSON(
  jsonString: string,
): SafeParseResult<SendResponsesRequestOrderUnion, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => SendResponsesRequestOrderUnion$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'SendResponsesRequestOrderUnion' from JSON`,
  );
}

/** @internal */
export const SendResponsesRequestOnlyEnum$inboundSchema: z.ZodNativeEnum<
  typeof SendResponsesRequestOnlyEnum
> = z.nativeEnum(SendResponsesRequestOnlyEnum);

/** @internal */
export const SendResponsesRequestOnlyEnum$outboundSchema: z.ZodNativeEnum<
  typeof SendResponsesRequestOnlyEnum
> = SendResponsesRequestOnlyEnum$inboundSchema;

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace SendResponsesRequestOnlyEnum$ {
  /** @deprecated use `SendResponsesRequestOnlyEnum$inboundSchema` instead. */
  export const inboundSchema = SendResponsesRequestOnlyEnum$inboundSchema;
  /** @deprecated use `SendResponsesRequestOnlyEnum$outboundSchema` instead. */
  export const outboundSchema = SendResponsesRequestOnlyEnum$outboundSchema;
}

/** @internal */
export const SendResponsesRequestOnlyUnion$inboundSchema: z.ZodType<
  SendResponsesRequestOnlyUnion,
  z.ZodTypeDef,
  unknown
> = z.union([SendResponsesRequestOnlyEnum$inboundSchema, z.string()]);

/** @internal */
export type SendResponsesRequestOnlyUnion$Outbound = string | string;

/** @internal */
export const SendResponsesRequestOnlyUnion$outboundSchema: z.ZodType<
  SendResponsesRequestOnlyUnion$Outbound,
  z.ZodTypeDef,
  SendResponsesRequestOnlyUnion
> = z.union([SendResponsesRequestOnlyEnum$outboundSchema, z.string()]);

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace SendResponsesRequestOnlyUnion$ {
  /** @deprecated use `SendResponsesRequestOnlyUnion$inboundSchema` instead. */
  export const inboundSchema = SendResponsesRequestOnlyUnion$inboundSchema;
  /** @deprecated use `SendResponsesRequestOnlyUnion$outboundSchema` instead. */
  export const outboundSchema = SendResponsesRequestOnlyUnion$outboundSchema;
  /** @deprecated use `SendResponsesRequestOnlyUnion$Outbound` instead. */
  export type Outbound = SendResponsesRequestOnlyUnion$Outbound;
}

export function sendResponsesRequestOnlyUnionToJSON(
  sendResponsesRequestOnlyUnion: SendResponsesRequestOnlyUnion,
): string {
  return JSON.stringify(
    SendResponsesRequestOnlyUnion$outboundSchema.parse(
      sendResponsesRequestOnlyUnion,
    ),
  );
}

export function sendResponsesRequestOnlyUnionFromJSON(
  jsonString: string,
): SafeParseResult<SendResponsesRequestOnlyUnion, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => SendResponsesRequestOnlyUnion$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'SendResponsesRequestOnlyUnion' from JSON`,
  );
}

/** @internal */
export const SendResponsesRequestIgnoreEnum$inboundSchema: z.ZodNativeEnum<
  typeof SendResponsesRequestIgnoreEnum
> = z.nativeEnum(SendResponsesRequestIgnoreEnum);

/** @internal */
export const SendResponsesRequestIgnoreEnum$outboundSchema: z.ZodNativeEnum<
  typeof SendResponsesRequestIgnoreEnum
> = SendResponsesRequestIgnoreEnum$inboundSchema;

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace SendResponsesRequestIgnoreEnum$ {
  /** @deprecated use `SendResponsesRequestIgnoreEnum$inboundSchema` instead. */
  export const inboundSchema = SendResponsesRequestIgnoreEnum$inboundSchema;
  /** @deprecated use `SendResponsesRequestIgnoreEnum$outboundSchema` instead. */
  export const outboundSchema = SendResponsesRequestIgnoreEnum$outboundSchema;
}

/** @internal */
export const SendResponsesRequestIgnoreUnion$inboundSchema: z.ZodType<
  SendResponsesRequestIgnoreUnion,
  z.ZodTypeDef,
  unknown
> = z.union([SendResponsesRequestIgnoreEnum$inboundSchema, z.string()]);

/** @internal */
export type SendResponsesRequestIgnoreUnion$Outbound = string | string;

/** @internal */
export const SendResponsesRequestIgnoreUnion$outboundSchema: z.ZodType<
  SendResponsesRequestIgnoreUnion$Outbound,
  z.ZodTypeDef,
  SendResponsesRequestIgnoreUnion
> = z.union([SendResponsesRequestIgnoreEnum$outboundSchema, z.string()]);

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace SendResponsesRequestIgnoreUnion$ {
  /** @deprecated use `SendResponsesRequestIgnoreUnion$inboundSchema` instead. */
  export const inboundSchema = SendResponsesRequestIgnoreUnion$inboundSchema;
  /** @deprecated use `SendResponsesRequestIgnoreUnion$outboundSchema` instead. */
  export const outboundSchema = SendResponsesRequestIgnoreUnion$outboundSchema;
  /** @deprecated use `SendResponsesRequestIgnoreUnion$Outbound` instead. */
  export type Outbound = SendResponsesRequestIgnoreUnion$Outbound;
}

export function sendResponsesRequestIgnoreUnionToJSON(
  sendResponsesRequestIgnoreUnion: SendResponsesRequestIgnoreUnion,
): string {
  return JSON.stringify(
    SendResponsesRequestIgnoreUnion$outboundSchema.parse(
      sendResponsesRequestIgnoreUnion,
    ),
  );
}

export function sendResponsesRequestIgnoreUnionFromJSON(
  jsonString: string,
): SafeParseResult<SendResponsesRequestIgnoreUnion, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => SendResponsesRequestIgnoreUnion$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'SendResponsesRequestIgnoreUnion' from JSON`,
  );
}

/** @internal */
export const SendResponsesRequestQuantization$inboundSchema: z.ZodNativeEnum<
  typeof SendResponsesRequestQuantization
> = z.nativeEnum(SendResponsesRequestQuantization);

/** @internal */
export const SendResponsesRequestQuantization$outboundSchema: z.ZodNativeEnum<
  typeof SendResponsesRequestQuantization
> = SendResponsesRequestQuantization$inboundSchema;

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace SendResponsesRequestQuantization$ {
  /** @deprecated use `SendResponsesRequestQuantization$inboundSchema` instead. */
  export const inboundSchema = SendResponsesRequestQuantization$inboundSchema;
  /** @deprecated use `SendResponsesRequestQuantization$outboundSchema` instead. */
  export const outboundSchema = SendResponsesRequestQuantization$outboundSchema;
}

/** @internal */
export const SendResponsesRequestSort$inboundSchema: z.ZodNativeEnum<
  typeof SendResponsesRequestSort
> = z.nativeEnum(SendResponsesRequestSort);

/** @internal */
export const SendResponsesRequestSort$outboundSchema: z.ZodNativeEnum<
  typeof SendResponsesRequestSort
> = SendResponsesRequestSort$inboundSchema;

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace SendResponsesRequestSort$ {
  /** @deprecated use `SendResponsesRequestSort$inboundSchema` instead. */
  export const inboundSchema = SendResponsesRequestSort$inboundSchema;
  /** @deprecated use `SendResponsesRequestSort$outboundSchema` instead. */
  export const outboundSchema = SendResponsesRequestSort$outboundSchema;
}

/** @internal */
export const SendResponsesRequestPrompt$inboundSchema: z.ZodType<
  SendResponsesRequestPrompt,
  z.ZodTypeDef,
  unknown
> = z.union([z.number(), z.string(), z.any()]);

/** @internal */
export type SendResponsesRequestPrompt$Outbound = number | string | any;

/** @internal */
export const SendResponsesRequestPrompt$outboundSchema: z.ZodType<
  SendResponsesRequestPrompt$Outbound,
  z.ZodTypeDef,
  SendResponsesRequestPrompt
> = z.union([z.number(), z.string(), z.any()]);

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace SendResponsesRequestPrompt$ {
  /** @deprecated use `SendResponsesRequestPrompt$inboundSchema` instead. */
  export const inboundSchema = SendResponsesRequestPrompt$inboundSchema;
  /** @deprecated use `SendResponsesRequestPrompt$outboundSchema` instead. */
  export const outboundSchema = SendResponsesRequestPrompt$outboundSchema;
  /** @deprecated use `SendResponsesRequestPrompt$Outbound` instead. */
  export type Outbound = SendResponsesRequestPrompt$Outbound;
}

export function sendResponsesRequestPromptToJSON(
  sendResponsesRequestPrompt: SendResponsesRequestPrompt,
): string {
  return JSON.stringify(
    SendResponsesRequestPrompt$outboundSchema.parse(sendResponsesRequestPrompt),
  );
}

export function sendResponsesRequestPromptFromJSON(
  jsonString: string,
): SafeParseResult<SendResponsesRequestPrompt, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => SendResponsesRequestPrompt$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'SendResponsesRequestPrompt' from JSON`,
  );
}

/** @internal */
export const SendResponsesRequestCompletion$inboundSchema: z.ZodType<
  SendResponsesRequestCompletion,
  z.ZodTypeDef,
  unknown
> = z.union([z.number(), z.string(), z.any()]);

/** @internal */
export type SendResponsesRequestCompletion$Outbound = number | string | any;

/** @internal */
export const SendResponsesRequestCompletion$outboundSchema: z.ZodType<
  SendResponsesRequestCompletion$Outbound,
  z.ZodTypeDef,
  SendResponsesRequestCompletion
> = z.union([z.number(), z.string(), z.any()]);

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace SendResponsesRequestCompletion$ {
  /** @deprecated use `SendResponsesRequestCompletion$inboundSchema` instead. */
  export const inboundSchema = SendResponsesRequestCompletion$inboundSchema;
  /** @deprecated use `SendResponsesRequestCompletion$outboundSchema` instead. */
  export const outboundSchema = SendResponsesRequestCompletion$outboundSchema;
  /** @deprecated use `SendResponsesRequestCompletion$Outbound` instead. */
  export type Outbound = SendResponsesRequestCompletion$Outbound;
}

export function sendResponsesRequestCompletionToJSON(
  sendResponsesRequestCompletion: SendResponsesRequestCompletion,
): string {
  return JSON.stringify(
    SendResponsesRequestCompletion$outboundSchema.parse(
      sendResponsesRequestCompletion,
    ),
  );
}

export function sendResponsesRequestCompletionFromJSON(
  jsonString: string,
): SafeParseResult<SendResponsesRequestCompletion, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => SendResponsesRequestCompletion$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'SendResponsesRequestCompletion' from JSON`,
  );
}

/** @internal */
export const SendResponsesRequestImage$inboundSchema: z.ZodType<
  SendResponsesRequestImage,
  z.ZodTypeDef,
  unknown
> = z.union([z.number(), z.string(), z.any()]);

/** @internal */
export type SendResponsesRequestImage$Outbound = number | string | any;

/** @internal */
export const SendResponsesRequestImage$outboundSchema: z.ZodType<
  SendResponsesRequestImage$Outbound,
  z.ZodTypeDef,
  SendResponsesRequestImage
> = z.union([z.number(), z.string(), z.any()]);

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace SendResponsesRequestImage$ {
  /** @deprecated use `SendResponsesRequestImage$inboundSchema` instead. */
  export const inboundSchema = SendResponsesRequestImage$inboundSchema;
  /** @deprecated use `SendResponsesRequestImage$outboundSchema` instead. */
  export const outboundSchema = SendResponsesRequestImage$outboundSchema;
  /** @deprecated use `SendResponsesRequestImage$Outbound` instead. */
  export type Outbound = SendResponsesRequestImage$Outbound;
}

export function sendResponsesRequestImageToJSON(
  sendResponsesRequestImage: SendResponsesRequestImage,
): string {
  return JSON.stringify(
    SendResponsesRequestImage$outboundSchema.parse(sendResponsesRequestImage),
  );
}

export function sendResponsesRequestImageFromJSON(
  jsonString: string,
): SafeParseResult<SendResponsesRequestImage, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => SendResponsesRequestImage$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'SendResponsesRequestImage' from JSON`,
  );
}

/** @internal */
export const SendResponsesRequestAudio$inboundSchema: z.ZodType<
  SendResponsesRequestAudio,
  z.ZodTypeDef,
  unknown
> = z.union([z.number(), z.string(), z.any()]);

/** @internal */
export type SendResponsesRequestAudio$Outbound = number | string | any;

/** @internal */
export const SendResponsesRequestAudio$outboundSchema: z.ZodType<
  SendResponsesRequestAudio$Outbound,
  z.ZodTypeDef,
  SendResponsesRequestAudio
> = z.union([z.number(), z.string(), z.any()]);

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace SendResponsesRequestAudio$ {
  /** @deprecated use `SendResponsesRequestAudio$inboundSchema` instead. */
  export const inboundSchema = SendResponsesRequestAudio$inboundSchema;
  /** @deprecated use `SendResponsesRequestAudio$outboundSchema` instead. */
  export const outboundSchema = SendResponsesRequestAudio$outboundSchema;
  /** @deprecated use `SendResponsesRequestAudio$Outbound` instead. */
  export type Outbound = SendResponsesRequestAudio$Outbound;
}

export function sendResponsesRequestAudioToJSON(
  sendResponsesRequestAudio: SendResponsesRequestAudio,
): string {
  return JSON.stringify(
    SendResponsesRequestAudio$outboundSchema.parse(sendResponsesRequestAudio),
  );
}

export function sendResponsesRequestAudioFromJSON(
  jsonString: string,
): SafeParseResult<SendResponsesRequestAudio, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => SendResponsesRequestAudio$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'SendResponsesRequestAudio' from JSON`,
  );
}

/** @internal */
export const SendResponsesRequestRequestUnion$inboundSchema: z.ZodType<
  SendResponsesRequestRequestUnion,
  z.ZodTypeDef,
  unknown
> = z.union([z.number(), z.string(), z.any()]);

/** @internal */
export type SendResponsesRequestRequestUnion$Outbound = number | string | any;

/** @internal */
export const SendResponsesRequestRequestUnion$outboundSchema: z.ZodType<
  SendResponsesRequestRequestUnion$Outbound,
  z.ZodTypeDef,
  SendResponsesRequestRequestUnion
> = z.union([z.number(), z.string(), z.any()]);

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace SendResponsesRequestRequestUnion$ {
  /** @deprecated use `SendResponsesRequestRequestUnion$inboundSchema` instead. */
  export const inboundSchema = SendResponsesRequestRequestUnion$inboundSchema;
  /** @deprecated use `SendResponsesRequestRequestUnion$outboundSchema` instead. */
  export const outboundSchema = SendResponsesRequestRequestUnion$outboundSchema;
  /** @deprecated use `SendResponsesRequestRequestUnion$Outbound` instead. */
  export type Outbound = SendResponsesRequestRequestUnion$Outbound;
}

export function sendResponsesRequestRequestUnionToJSON(
  sendResponsesRequestRequestUnion: SendResponsesRequestRequestUnion,
): string {
  return JSON.stringify(
    SendResponsesRequestRequestUnion$outboundSchema.parse(
      sendResponsesRequestRequestUnion,
    ),
  );
}

export function sendResponsesRequestRequestUnionFromJSON(
  jsonString: string,
): SafeParseResult<SendResponsesRequestRequestUnion, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => SendResponsesRequestRequestUnion$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'SendResponsesRequestRequestUnion' from JSON`,
  );
}

/** @internal */
export const SendResponsesRequestMaxPrice$inboundSchema: z.ZodType<
  SendResponsesRequestMaxPrice,
  z.ZodTypeDef,
  unknown
> = z.object({
  prompt: z.union([z.number(), z.string(), z.any()]).optional(),
  completion: z.union([z.number(), z.string(), z.any()]).optional(),
  image: z.union([z.number(), z.string(), z.any()]).optional(),
  audio: z.union([z.number(), z.string(), z.any()]).optional(),
  request: z.union([z.number(), z.string(), z.any()]).optional(),
});

/** @internal */
export type SendResponsesRequestMaxPrice$Outbound = {
  prompt?: number | string | any | undefined;
  completion?: number | string | any | undefined;
  image?: number | string | any | undefined;
  audio?: number | string | any | undefined;
  request?: number | string | any | undefined;
};

/** @internal */
export const SendResponsesRequestMaxPrice$outboundSchema: z.ZodType<
  SendResponsesRequestMaxPrice$Outbound,
  z.ZodTypeDef,
  SendResponsesRequestMaxPrice
> = z.object({
  prompt: z.union([z.number(), z.string(), z.any()]).optional(),
  completion: z.union([z.number(), z.string(), z.any()]).optional(),
  image: z.union([z.number(), z.string(), z.any()]).optional(),
  audio: z.union([z.number(), z.string(), z.any()]).optional(),
  request: z.union([z.number(), z.string(), z.any()]).optional(),
});

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace SendResponsesRequestMaxPrice$ {
  /** @deprecated use `SendResponsesRequestMaxPrice$inboundSchema` instead. */
  export const inboundSchema = SendResponsesRequestMaxPrice$inboundSchema;
  /** @deprecated use `SendResponsesRequestMaxPrice$outboundSchema` instead. */
  export const outboundSchema = SendResponsesRequestMaxPrice$outboundSchema;
  /** @deprecated use `SendResponsesRequestMaxPrice$Outbound` instead. */
  export type Outbound = SendResponsesRequestMaxPrice$Outbound;
}

export function sendResponsesRequestMaxPriceToJSON(
  sendResponsesRequestMaxPrice: SendResponsesRequestMaxPrice,
): string {
  return JSON.stringify(
    SendResponsesRequestMaxPrice$outboundSchema.parse(
      sendResponsesRequestMaxPrice,
    ),
  );
}

export function sendResponsesRequestMaxPriceFromJSON(
  jsonString: string,
): SafeParseResult<SendResponsesRequestMaxPrice, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => SendResponsesRequestMaxPrice$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'SendResponsesRequestMaxPrice' from JSON`,
  );
}

/** @internal */
export const SendResponsesRequestExperimental$inboundSchema: z.ZodType<
  SendResponsesRequestExperimental,
  z.ZodTypeDef,
  unknown
> = z.object({});

/** @internal */
export type SendResponsesRequestExperimental$Outbound = {};

/** @internal */
export const SendResponsesRequestExperimental$outboundSchema: z.ZodType<
  SendResponsesRequestExperimental$Outbound,
  z.ZodTypeDef,
  SendResponsesRequestExperimental
> = z.object({});

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace SendResponsesRequestExperimental$ {
  /** @deprecated use `SendResponsesRequestExperimental$inboundSchema` instead. */
  export const inboundSchema = SendResponsesRequestExperimental$inboundSchema;
  /** @deprecated use `SendResponsesRequestExperimental$outboundSchema` instead. */
  export const outboundSchema = SendResponsesRequestExperimental$outboundSchema;
  /** @deprecated use `SendResponsesRequestExperimental$Outbound` instead. */
  export type Outbound = SendResponsesRequestExperimental$Outbound;
}

export function sendResponsesRequestExperimentalToJSON(
  sendResponsesRequestExperimental: SendResponsesRequestExperimental,
): string {
  return JSON.stringify(
    SendResponsesRequestExperimental$outboundSchema.parse(
      sendResponsesRequestExperimental,
    ),
  );
}

export function sendResponsesRequestExperimentalFromJSON(
  jsonString: string,
): SafeParseResult<SendResponsesRequestExperimental, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => SendResponsesRequestExperimental$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'SendResponsesRequestExperimental' from JSON`,
  );
}

/** @internal */
export const SendResponsesRequestProvider$inboundSchema: z.ZodType<
  SendResponsesRequestProvider,
  z.ZodTypeDef,
  unknown
> = z.object({
  allow_fallbacks: z.nullable(z.boolean()).optional(),
  require_parameters: z.nullable(z.boolean()).optional(),
  data_collection: z.nullable(SendResponsesRequestDataCollection$inboundSchema)
    .optional(),
  zdr: z.nullable(z.boolean()).optional(),
  order: z.nullable(
    z.array(z.union([SendResponsesRequestOrderEnum$inboundSchema, z.string()])),
  ).optional(),
  only: z.nullable(
    z.array(z.union([SendResponsesRequestOnlyEnum$inboundSchema, z.string()])),
  ).optional(),
  ignore: z.nullable(
    z.array(
      z.union([SendResponsesRequestIgnoreEnum$inboundSchema, z.string()]),
    ),
  ).optional(),
  quantizations: z.nullable(
    z.array(SendResponsesRequestQuantization$inboundSchema),
  ).optional(),
  sort: z.nullable(SendResponsesRequestSort$inboundSchema).optional(),
  max_price: z.lazy(() => SendResponsesRequestMaxPrice$inboundSchema)
    .optional(),
  experimental: z.nullable(
    z.lazy(() => SendResponsesRequestExperimental$inboundSchema),
  ).optional(),
}).transform((v) => {
  return remap$(v, {
    "allow_fallbacks": "allowFallbacks",
    "require_parameters": "requireParameters",
    "data_collection": "dataCollection",
    "max_price": "maxPrice",
  });
});

/** @internal */
export type SendResponsesRequestProvider$Outbound = {
  allow_fallbacks?: boolean | null | undefined;
  require_parameters?: boolean | null | undefined;
  data_collection?: string | null | undefined;
  zdr?: boolean | null | undefined;
  order?: Array<string | string> | null | undefined;
  only?: Array<string | string> | null | undefined;
  ignore?: Array<string | string> | null | undefined;
  quantizations?: Array<string> | null | undefined;
  sort?: string | null | undefined;
  max_price?: SendResponsesRequestMaxPrice$Outbound | undefined;
  experimental?: SendResponsesRequestExperimental$Outbound | null | undefined;
};

/** @internal */
export const SendResponsesRequestProvider$outboundSchema: z.ZodType<
  SendResponsesRequestProvider$Outbound,
  z.ZodTypeDef,
  SendResponsesRequestProvider
> = z.object({
  allowFallbacks: z.nullable(z.boolean()).optional(),
  requireParameters: z.nullable(z.boolean()).optional(),
  dataCollection: z.nullable(SendResponsesRequestDataCollection$outboundSchema)
    .optional(),
  zdr: z.nullable(z.boolean()).optional(),
  order: z.nullable(
    z.array(
      z.union([SendResponsesRequestOrderEnum$outboundSchema, z.string()]),
    ),
  ).optional(),
  only: z.nullable(
    z.array(z.union([SendResponsesRequestOnlyEnum$outboundSchema, z.string()])),
  ).optional(),
  ignore: z.nullable(
    z.array(
      z.union([SendResponsesRequestIgnoreEnum$outboundSchema, z.string()]),
    ),
  ).optional(),
  quantizations: z.nullable(
    z.array(SendResponsesRequestQuantization$outboundSchema),
  ).optional(),
  sort: z.nullable(SendResponsesRequestSort$outboundSchema).optional(),
  maxPrice: z.lazy(() => SendResponsesRequestMaxPrice$outboundSchema)
    .optional(),
  experimental: z.nullable(
    z.lazy(() => SendResponsesRequestExperimental$outboundSchema),
  ).optional(),
}).transform((v) => {
  return remap$(v, {
    allowFallbacks: "allow_fallbacks",
    requireParameters: "require_parameters",
    dataCollection: "data_collection",
    maxPrice: "max_price",
  });
});

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace SendResponsesRequestProvider$ {
  /** @deprecated use `SendResponsesRequestProvider$inboundSchema` instead. */
  export const inboundSchema = SendResponsesRequestProvider$inboundSchema;
  /** @deprecated use `SendResponsesRequestProvider$outboundSchema` instead. */
  export const outboundSchema = SendResponsesRequestProvider$outboundSchema;
  /** @deprecated use `SendResponsesRequestProvider$Outbound` instead. */
  export type Outbound = SendResponsesRequestProvider$Outbound;
}

export function sendResponsesRequestProviderToJSON(
  sendResponsesRequestProvider: SendResponsesRequestProvider,
): string {
  return JSON.stringify(
    SendResponsesRequestProvider$outboundSchema.parse(
      sendResponsesRequestProvider,
    ),
  );
}

export function sendResponsesRequestProviderFromJSON(
  jsonString: string,
): SafeParseResult<SendResponsesRequestProvider, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => SendResponsesRequestProvider$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'SendResponsesRequestProvider' from JSON`,
  );
}

/** @internal */
export const IdFileParser$inboundSchema: z.ZodNativeEnum<typeof IdFileParser> =
  z.nativeEnum(IdFileParser);

/** @internal */
export const IdFileParser$outboundSchema: z.ZodNativeEnum<typeof IdFileParser> =
  IdFileParser$inboundSchema;

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace IdFileParser$ {
  /** @deprecated use `IdFileParser$inboundSchema` instead. */
  export const inboundSchema = IdFileParser$inboundSchema;
  /** @deprecated use `IdFileParser$outboundSchema` instead. */
  export const outboundSchema = IdFileParser$outboundSchema;
}

/** @internal */
export const PdfEngine$inboundSchema: z.ZodNativeEnum<typeof PdfEngine> = z
  .nativeEnum(PdfEngine);

/** @internal */
export const PdfEngine$outboundSchema: z.ZodNativeEnum<typeof PdfEngine> =
  PdfEngine$inboundSchema;

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace PdfEngine$ {
  /** @deprecated use `PdfEngine$inboundSchema` instead. */
  export const inboundSchema = PdfEngine$inboundSchema;
  /** @deprecated use `PdfEngine$outboundSchema` instead. */
  export const outboundSchema = PdfEngine$outboundSchema;
}

/** @internal */
export const Pdf$inboundSchema: z.ZodType<Pdf, z.ZodTypeDef, unknown> = z
  .object({
    engine: PdfEngine$inboundSchema.optional(),
  });

/** @internal */
export type Pdf$Outbound = {
  engine?: string | undefined;
};

/** @internal */
export const Pdf$outboundSchema: z.ZodType<Pdf$Outbound, z.ZodTypeDef, Pdf> = z
  .object({
    engine: PdfEngine$outboundSchema.optional(),
  });

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace Pdf$ {
  /** @deprecated use `Pdf$inboundSchema` instead. */
  export const inboundSchema = Pdf$inboundSchema;
  /** @deprecated use `Pdf$outboundSchema` instead. */
  export const outboundSchema = Pdf$outboundSchema;
  /** @deprecated use `Pdf$Outbound` instead. */
  export type Outbound = Pdf$Outbound;
}

export function pdfToJSON(pdf: Pdf): string {
  return JSON.stringify(Pdf$outboundSchema.parse(pdf));
}

export function pdfFromJSON(
  jsonString: string,
): SafeParseResult<Pdf, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => Pdf$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'Pdf' from JSON`,
  );
}

/** @internal */
export const PluginFileParser$inboundSchema: z.ZodType<
  PluginFileParser,
  z.ZodTypeDef,
  unknown
> = z.object({
  id: IdFileParser$inboundSchema,
  max_files: z.number().optional(),
  pdf: z.lazy(() => Pdf$inboundSchema).optional(),
}).transform((v) => {
  return remap$(v, {
    "max_files": "maxFiles",
  });
});

/** @internal */
export type PluginFileParser$Outbound = {
  id: string;
  max_files?: number | undefined;
  pdf?: Pdf$Outbound | undefined;
};

/** @internal */
export const PluginFileParser$outboundSchema: z.ZodType<
  PluginFileParser$Outbound,
  z.ZodTypeDef,
  PluginFileParser
> = z.object({
  id: IdFileParser$outboundSchema,
  maxFiles: z.number().optional(),
  pdf: z.lazy(() => Pdf$outboundSchema).optional(),
}).transform((v) => {
  return remap$(v, {
    maxFiles: "max_files",
  });
});

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace PluginFileParser$ {
  /** @deprecated use `PluginFileParser$inboundSchema` instead. */
  export const inboundSchema = PluginFileParser$inboundSchema;
  /** @deprecated use `PluginFileParser$outboundSchema` instead. */
  export const outboundSchema = PluginFileParser$outboundSchema;
  /** @deprecated use `PluginFileParser$Outbound` instead. */
  export type Outbound = PluginFileParser$Outbound;
}

export function pluginFileParserToJSON(
  pluginFileParser: PluginFileParser,
): string {
  return JSON.stringify(
    PluginFileParser$outboundSchema.parse(pluginFileParser),
  );
}

export function pluginFileParserFromJSON(
  jsonString: string,
): SafeParseResult<PluginFileParser, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => PluginFileParser$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'PluginFileParser' from JSON`,
  );
}

/** @internal */
export const IdChainOfThought$inboundSchema: z.ZodNativeEnum<
  typeof IdChainOfThought
> = z.nativeEnum(IdChainOfThought);

/** @internal */
export const IdChainOfThought$outboundSchema: z.ZodNativeEnum<
  typeof IdChainOfThought
> = IdChainOfThought$inboundSchema;

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace IdChainOfThought$ {
  /** @deprecated use `IdChainOfThought$inboundSchema` instead. */
  export const inboundSchema = IdChainOfThought$inboundSchema;
  /** @deprecated use `IdChainOfThought$outboundSchema` instead. */
  export const outboundSchema = IdChainOfThought$outboundSchema;
}

/** @internal */
export const PluginChainOfThought$inboundSchema: z.ZodType<
  PluginChainOfThought,
  z.ZodTypeDef,
  unknown
> = z.object({
  id: IdChainOfThought$inboundSchema,
});

/** @internal */
export type PluginChainOfThought$Outbound = {
  id: string;
};

/** @internal */
export const PluginChainOfThought$outboundSchema: z.ZodType<
  PluginChainOfThought$Outbound,
  z.ZodTypeDef,
  PluginChainOfThought
> = z.object({
  id: IdChainOfThought$outboundSchema,
});

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace PluginChainOfThought$ {
  /** @deprecated use `PluginChainOfThought$inboundSchema` instead. */
  export const inboundSchema = PluginChainOfThought$inboundSchema;
  /** @deprecated use `PluginChainOfThought$outboundSchema` instead. */
  export const outboundSchema = PluginChainOfThought$outboundSchema;
  /** @deprecated use `PluginChainOfThought$Outbound` instead. */
  export type Outbound = PluginChainOfThought$Outbound;
}

export function pluginChainOfThoughtToJSON(
  pluginChainOfThought: PluginChainOfThought,
): string {
  return JSON.stringify(
    PluginChainOfThought$outboundSchema.parse(pluginChainOfThought),
  );
}

export function pluginChainOfThoughtFromJSON(
  jsonString: string,
): SafeParseResult<PluginChainOfThought, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => PluginChainOfThought$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'PluginChainOfThought' from JSON`,
  );
}

/** @internal */
export const IdWeb$inboundSchema: z.ZodNativeEnum<typeof IdWeb> = z.nativeEnum(
  IdWeb,
);

/** @internal */
export const IdWeb$outboundSchema: z.ZodNativeEnum<typeof IdWeb> =
  IdWeb$inboundSchema;

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace IdWeb$ {
  /** @deprecated use `IdWeb$inboundSchema` instead. */
  export const inboundSchema = IdWeb$inboundSchema;
  /** @deprecated use `IdWeb$outboundSchema` instead. */
  export const outboundSchema = IdWeb$outboundSchema;
}

/** @internal */
export const Engine$inboundSchema: z.ZodNativeEnum<typeof Engine> = z
  .nativeEnum(Engine);

/** @internal */
export const Engine$outboundSchema: z.ZodNativeEnum<typeof Engine> =
  Engine$inboundSchema;

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace Engine$ {
  /** @deprecated use `Engine$inboundSchema` instead. */
  export const inboundSchema = Engine$inboundSchema;
  /** @deprecated use `Engine$outboundSchema` instead. */
  export const outboundSchema = Engine$outboundSchema;
}

/** @internal */
export const PluginWeb$inboundSchema: z.ZodType<
  PluginWeb,
  z.ZodTypeDef,
  unknown
> = z.object({
  id: IdWeb$inboundSchema,
  max_results: z.number().optional(),
  search_prompt: z.string().optional(),
  engine: Engine$inboundSchema.optional(),
}).transform((v) => {
  return remap$(v, {
    "max_results": "maxResults",
    "search_prompt": "searchPrompt",
  });
});

/** @internal */
export type PluginWeb$Outbound = {
  id: string;
  max_results?: number | undefined;
  search_prompt?: string | undefined;
  engine?: string | undefined;
};

/** @internal */
export const PluginWeb$outboundSchema: z.ZodType<
  PluginWeb$Outbound,
  z.ZodTypeDef,
  PluginWeb
> = z.object({
  id: IdWeb$outboundSchema,
  maxResults: z.number().optional(),
  searchPrompt: z.string().optional(),
  engine: Engine$outboundSchema.optional(),
}).transform((v) => {
  return remap$(v, {
    maxResults: "max_results",
    searchPrompt: "search_prompt",
  });
});

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace PluginWeb$ {
  /** @deprecated use `PluginWeb$inboundSchema` instead. */
  export const inboundSchema = PluginWeb$inboundSchema;
  /** @deprecated use `PluginWeb$outboundSchema` instead. */
  export const outboundSchema = PluginWeb$outboundSchema;
  /** @deprecated use `PluginWeb$Outbound` instead. */
  export type Outbound = PluginWeb$Outbound;
}

export function pluginWebToJSON(pluginWeb: PluginWeb): string {
  return JSON.stringify(PluginWeb$outboundSchema.parse(pluginWeb));
}

export function pluginWebFromJSON(
  jsonString: string,
): SafeParseResult<PluginWeb, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => PluginWeb$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'PluginWeb' from JSON`,
  );
}

/** @internal */
export const IdModeration$inboundSchema: z.ZodNativeEnum<typeof IdModeration> =
  z.nativeEnum(IdModeration);

/** @internal */
export const IdModeration$outboundSchema: z.ZodNativeEnum<typeof IdModeration> =
  IdModeration$inboundSchema;

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace IdModeration$ {
  /** @deprecated use `IdModeration$inboundSchema` instead. */
  export const inboundSchema = IdModeration$inboundSchema;
  /** @deprecated use `IdModeration$outboundSchema` instead. */
  export const outboundSchema = IdModeration$outboundSchema;
}

/** @internal */
export const PluginModeration$inboundSchema: z.ZodType<
  PluginModeration,
  z.ZodTypeDef,
  unknown
> = z.object({
  id: IdModeration$inboundSchema,
});

/** @internal */
export type PluginModeration$Outbound = {
  id: string;
};

/** @internal */
export const PluginModeration$outboundSchema: z.ZodType<
  PluginModeration$Outbound,
  z.ZodTypeDef,
  PluginModeration
> = z.object({
  id: IdModeration$outboundSchema,
});

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace PluginModeration$ {
  /** @deprecated use `PluginModeration$inboundSchema` instead. */
  export const inboundSchema = PluginModeration$inboundSchema;
  /** @deprecated use `PluginModeration$outboundSchema` instead. */
  export const outboundSchema = PluginModeration$outboundSchema;
  /** @deprecated use `PluginModeration$Outbound` instead. */
  export type Outbound = PluginModeration$Outbound;
}

export function pluginModerationToJSON(
  pluginModeration: PluginModeration,
): string {
  return JSON.stringify(
    PluginModeration$outboundSchema.parse(pluginModeration),
  );
}

export function pluginModerationFromJSON(
  jsonString: string,
): SafeParseResult<PluginModeration, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => PluginModeration$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'PluginModeration' from JSON`,
  );
}

/** @internal */
export const Plugin$inboundSchema: z.ZodType<Plugin, z.ZodTypeDef, unknown> = z
  .union([
    z.lazy(() => PluginModeration$inboundSchema),
    z.lazy(() => PluginWeb$inboundSchema),
    z.lazy(() => PluginChainOfThought$inboundSchema),
    z.lazy(() => PluginFileParser$inboundSchema),
  ]);

/** @internal */
export type Plugin$Outbound =
  | PluginModeration$Outbound
  | PluginWeb$Outbound
  | PluginChainOfThought$Outbound
  | PluginFileParser$Outbound;

/** @internal */
export const Plugin$outboundSchema: z.ZodType<
  Plugin$Outbound,
  z.ZodTypeDef,
  Plugin
> = z.union([
  z.lazy(() => PluginModeration$outboundSchema),
  z.lazy(() => PluginWeb$outboundSchema),
  z.lazy(() => PluginChainOfThought$outboundSchema),
  z.lazy(() => PluginFileParser$outboundSchema),
]);

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace Plugin$ {
  /** @deprecated use `Plugin$inboundSchema` instead. */
  export const inboundSchema = Plugin$inboundSchema;
  /** @deprecated use `Plugin$outboundSchema` instead. */
  export const outboundSchema = Plugin$outboundSchema;
  /** @deprecated use `Plugin$Outbound` instead. */
  export type Outbound = Plugin$Outbound;
}

export function pluginToJSON(plugin: Plugin): string {
  return JSON.stringify(Plugin$outboundSchema.parse(plugin));
}

export function pluginFromJSON(
  jsonString: string,
): SafeParseResult<Plugin, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => Plugin$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'Plugin' from JSON`,
  );
}

/** @internal */
export const SendResponsesRequestRequest$inboundSchema: z.ZodType<
  SendResponsesRequestRequest,
  z.ZodTypeDef,
  unknown
> = z.object({
  input: models.ResponseInput$inboundSchema.optional(),
  instructions: z.nullable(z.string()).optional(),
  metadata: z.nullable(z.record(z.string())).optional(),
  tools: z.array(models.Tool$inboundSchema).optional(),
  tool_choice: models.ToolChoiceUnion$inboundSchema.optional(),
  parallel_tool_calls: z.nullable(z.boolean()).optional(),
  model: z.string().optional(),
  models: z.array(z.string()).optional(),
  text: models.ResponseTextConfig$inboundSchema.optional(),
  reasoning: z.nullable(models.ResponseReasoningConfig$inboundSchema)
    .optional(),
  max_output_tokens: z.nullable(z.number()).optional(),
  temperature: z.nullable(z.number()).optional(),
  top_p: z.nullable(z.number()).optional(),
  top_k: z.number().optional(),
  prompt_cache_key: z.string().optional(),
  previous_response_id: z.nullable(z.string()).optional(),
  prompt: z.nullable(models.ResponsePrompt$inboundSchema).optional(),
  include: z.nullable(z.array(models.ResponseIncludable$inboundSchema))
    .optional(),
  background: z.nullable(z.boolean()).optional(),
  safety_identifier: z.string().optional(),
  store: z.nullable(z.boolean()).optional(),
  service_tier: z.nullable(ServiceTier$inboundSchema).optional(),
  truncation: z.nullable(Truncation$inboundSchema).optional(),
  stream: z.nullable(z.boolean()).optional(),
  provider: z.nullable(z.lazy(() => SendResponsesRequestProvider$inboundSchema))
    .optional(),
  plugins: z.array(
    z.union([
      z.lazy(() => PluginModeration$inboundSchema),
      z.lazy(() => PluginWeb$inboundSchema),
      z.lazy(() => PluginChainOfThought$inboundSchema),
      z.lazy(() => PluginFileParser$inboundSchema),
    ]),
  ).optional(),
  user: z.string().optional(),
}).transform((v) => {
  return remap$(v, {
    "tool_choice": "toolChoice",
    "parallel_tool_calls": "parallelToolCalls",
    "max_output_tokens": "maxOutputTokens",
    "top_p": "topP",
    "top_k": "topK",
    "prompt_cache_key": "promptCacheKey",
    "previous_response_id": "previousResponseId",
    "safety_identifier": "safetyIdentifier",
    "service_tier": "serviceTier",
  });
});

/** @internal */
export type SendResponsesRequestRequest$Outbound = {
  input?: models.ResponseInput$Outbound | undefined;
  instructions?: string | null | undefined;
  metadata?: { [k: string]: string } | null | undefined;
  tools?: Array<models.Tool$Outbound> | undefined;
  tool_choice?: models.ToolChoiceUnion$Outbound | undefined;
  parallel_tool_calls?: boolean | null | undefined;
  model?: string | undefined;
  models?: Array<string> | undefined;
  text?: models.ResponseTextConfig$Outbound | undefined;
  reasoning?: models.ResponseReasoningConfig$Outbound | null | undefined;
  max_output_tokens?: number | null | undefined;
  temperature?: number | null | undefined;
  top_p?: number | null | undefined;
  top_k?: number | undefined;
  prompt_cache_key?: string | undefined;
  previous_response_id?: string | null | undefined;
  prompt?: models.ResponsePrompt$Outbound | null | undefined;
  include?: Array<string> | null | undefined;
  background?: boolean | null | undefined;
  safety_identifier?: string | undefined;
  store?: boolean | null | undefined;
  service_tier?: string | null | undefined;
  truncation?: string | null | undefined;
  stream?: boolean | null | undefined;
  provider?: SendResponsesRequestProvider$Outbound | null | undefined;
  plugins?:
    | Array<
      | PluginModeration$Outbound
      | PluginWeb$Outbound
      | PluginChainOfThought$Outbound
      | PluginFileParser$Outbound
    >
    | undefined;
  user?: string | undefined;
};

/** @internal */
export const SendResponsesRequestRequest$outboundSchema: z.ZodType<
  SendResponsesRequestRequest$Outbound,
  z.ZodTypeDef,
  SendResponsesRequestRequest
> = z.object({
  input: models.ResponseInput$outboundSchema.optional(),
  instructions: z.nullable(z.string()).optional(),
  metadata: z.nullable(z.record(z.string())).optional(),
  tools: z.array(models.Tool$outboundSchema).optional(),
  toolChoice: models.ToolChoiceUnion$outboundSchema.optional(),
  parallelToolCalls: z.nullable(z.boolean()).optional(),
  model: z.string().optional(),
  models: z.array(z.string()).optional(),
  text: models.ResponseTextConfig$outboundSchema.optional(),
  reasoning: z.nullable(models.ResponseReasoningConfig$outboundSchema)
    .optional(),
  maxOutputTokens: z.nullable(z.number()).optional(),
  temperature: z.nullable(z.number()).optional(),
  topP: z.nullable(z.number()).optional(),
  topK: z.number().optional(),
  promptCacheKey: z.string().optional(),
  previousResponseId: z.nullable(z.string()).optional(),
  prompt: z.nullable(models.ResponsePrompt$outboundSchema).optional(),
  include: z.nullable(z.array(models.ResponseIncludable$outboundSchema))
    .optional(),
  background: z.nullable(z.boolean()).optional(),
  safetyIdentifier: z.string().optional(),
  store: z.nullable(z.boolean()).optional(),
  serviceTier: z.nullable(ServiceTier$outboundSchema).optional(),
  truncation: z.nullable(Truncation$outboundSchema).optional(),
  stream: z.nullable(z.boolean()).optional(),
  provider: z.nullable(
    z.lazy(() => SendResponsesRequestProvider$outboundSchema),
  ).optional(),
  plugins: z.array(
    z.union([
      z.lazy(() => PluginModeration$outboundSchema),
      z.lazy(() => PluginWeb$outboundSchema),
      z.lazy(() => PluginChainOfThought$outboundSchema),
      z.lazy(() => PluginFileParser$outboundSchema),
    ]),
  ).optional(),
  user: z.string().optional(),
}).transform((v) => {
  return remap$(v, {
    toolChoice: "tool_choice",
    parallelToolCalls: "parallel_tool_calls",
    maxOutputTokens: "max_output_tokens",
    topP: "top_p",
    topK: "top_k",
    promptCacheKey: "prompt_cache_key",
    previousResponseId: "previous_response_id",
    safetyIdentifier: "safety_identifier",
    serviceTier: "service_tier",
  });
});

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace SendResponsesRequestRequest$ {
  /** @deprecated use `SendResponsesRequestRequest$inboundSchema` instead. */
  export const inboundSchema = SendResponsesRequestRequest$inboundSchema;
  /** @deprecated use `SendResponsesRequestRequest$outboundSchema` instead. */
  export const outboundSchema = SendResponsesRequestRequest$outboundSchema;
  /** @deprecated use `SendResponsesRequestRequest$Outbound` instead. */
  export type Outbound = SendResponsesRequestRequest$Outbound;
}

export function sendResponsesRequestRequestToJSON(
  sendResponsesRequestRequest: SendResponsesRequestRequest,
): string {
  return JSON.stringify(
    SendResponsesRequestRequest$outboundSchema.parse(
      sendResponsesRequestRequest,
    ),
  );
}

export function sendResponsesRequestRequestFromJSON(
  jsonString: string,
): SafeParseResult<SendResponsesRequestRequest, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => SendResponsesRequestRequest$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'SendResponsesRequestRequest' from JSON`,
  );
}

/** @internal */
export const SendResponsesRequestResponseBody$inboundSchema: z.ZodType<
  SendResponsesRequestResponseBody,
  z.ZodTypeDef,
  unknown
> = z.object({
  data: z.string().transform((v, ctx) => {
    try {
      return JSON.parse(v);
    } catch (err) {
      ctx.addIssue({
        code: z.ZodIssueCode.custom,
        message: `malformed json: ${err}`,
      });
      return z.NEVER;
    }
  }).pipe(models.ResponsesStreamChunkUnion$inboundSchema),
});

/** @internal */
export type SendResponsesRequestResponseBody$Outbound = {
  data: models.ResponsesStreamChunkUnion$Outbound;
};

/** @internal */
export const SendResponsesRequestResponseBody$outboundSchema: z.ZodType<
  SendResponsesRequestResponseBody$Outbound,
  z.ZodTypeDef,
  SendResponsesRequestResponseBody
> = z.object({
  data: models.ResponsesStreamChunkUnion$outboundSchema,
});

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace SendResponsesRequestResponseBody$ {
  /** @deprecated use `SendResponsesRequestResponseBody$inboundSchema` instead. */
  export const inboundSchema = SendResponsesRequestResponseBody$inboundSchema;
  /** @deprecated use `SendResponsesRequestResponseBody$outboundSchema` instead. */
  export const outboundSchema = SendResponsesRequestResponseBody$outboundSchema;
  /** @deprecated use `SendResponsesRequestResponseBody$Outbound` instead. */
  export type Outbound = SendResponsesRequestResponseBody$Outbound;
}

export function sendResponsesRequestResponseBodyToJSON(
  sendResponsesRequestResponseBody: SendResponsesRequestResponseBody,
): string {
  return JSON.stringify(
    SendResponsesRequestResponseBody$outboundSchema.parse(
      sendResponsesRequestResponseBody,
    ),
  );
}

export function sendResponsesRequestResponseBodyFromJSON(
  jsonString: string,
): SafeParseResult<SendResponsesRequestResponseBody, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => SendResponsesRequestResponseBody$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'SendResponsesRequestResponseBody' from JSON`,
  );
}

/** @internal */
export const SendResponsesRequestResponse$inboundSchema: z.ZodType<
  SendResponsesRequestResponse,
  z.ZodTypeDef,
  unknown
> = z.union([
  models.ResponsesNonStreamingResponse$inboundSchema,
  z
    .instanceof(ReadableStream<Uint8Array>)
    .transform(stream => {
      return new EventStream(stream, rawEvent => {
        if (rawEvent.data === "[DONE]") return { done: true };
        return {
          value: z.lazy(() => SendResponsesRequestResponseBody$inboundSchema)
            .parse(rawEvent),
        };
      });
    }),
]);

/** @internal */
export type SendResponsesRequestResponse$Outbound =
  | models.ResponsesNonStreamingResponse$Outbound
  | never;

/** @internal */
export const SendResponsesRequestResponse$outboundSchema: z.ZodType<
  SendResponsesRequestResponse$Outbound,
  z.ZodTypeDef,
  SendResponsesRequestResponse
> = z.union([models.ResponsesNonStreamingResponse$outboundSchema, z.never()]);

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace SendResponsesRequestResponse$ {
  /** @deprecated use `SendResponsesRequestResponse$inboundSchema` instead. */
  export const inboundSchema = SendResponsesRequestResponse$inboundSchema;
  /** @deprecated use `SendResponsesRequestResponse$outboundSchema` instead. */
  export const outboundSchema = SendResponsesRequestResponse$outboundSchema;
  /** @deprecated use `SendResponsesRequestResponse$Outbound` instead. */
  export type Outbound = SendResponsesRequestResponse$Outbound;
}

export function sendResponsesRequestResponseToJSON(
  sendResponsesRequestResponse: SendResponsesRequestResponse,
): string {
  return JSON.stringify(
    SendResponsesRequestResponse$outboundSchema.parse(
      sendResponsesRequestResponse,
    ),
  );
}

export function sendResponsesRequestResponseFromJSON(
  jsonString: string,
): SafeParseResult<SendResponsesRequestResponse, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => SendResponsesRequestResponse$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'SendResponsesRequestResponse' from JSON`,
  );
}
