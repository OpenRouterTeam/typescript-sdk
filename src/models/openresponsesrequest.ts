/*
 * Code generated by Speakeasy (https://speakeasy.com). DO NOT EDIT.
 */

import * as z from "zod";
import { remap as remap$ } from "../lib/primitives.js";
import { safeParse } from "../lib/schemas.js";
import {
  catchUnrecognizedEnum,
  ClosedEnum,
  OpenEnum,
  Unrecognized,
} from "../types/enums.js";
import { Result as SafeParseResult } from "../types/fp.js";
import {
  DataCollection,
  DataCollection$inboundSchema,
  DataCollection$outboundSchema,
} from "./datacollection.js";
import { SDKValidationError } from "./errors/sdkvalidationerror.js";
import {
  OpenAIResponsesIncludable,
  OpenAIResponsesIncludable$inboundSchema,
  OpenAIResponsesIncludable$outboundSchema,
} from "./openairesponsesincludable.js";
import {
  OpenAIResponsesPrompt,
  OpenAIResponsesPrompt$inboundSchema,
  OpenAIResponsesPrompt$Outbound,
  OpenAIResponsesPrompt$outboundSchema,
} from "./openairesponsesprompt.js";
import {
  OpenResponsesInputUnion,
  OpenResponsesInputUnion$inboundSchema,
  OpenResponsesInputUnion$Outbound,
  OpenResponsesInputUnion$outboundSchema,
} from "./openresponsesinputunion.js";
import {
  OpenResponsesReasoningConfig,
  OpenResponsesReasoningConfig$inboundSchema,
  OpenResponsesReasoningConfig$Outbound,
  OpenResponsesReasoningConfig$outboundSchema,
} from "./openresponsesreasoningconfig.js";
import {
  OpenResponsesResponseText,
  OpenResponsesResponseText$inboundSchema,
  OpenResponsesResponseText$Outbound,
  OpenResponsesResponseText$outboundSchema,
} from "./openresponsesresponsetext.js";
import {
  OpenResponsesWebSearch20250826Tool,
  OpenResponsesWebSearch20250826Tool$inboundSchema,
  OpenResponsesWebSearch20250826Tool$Outbound,
  OpenResponsesWebSearch20250826Tool$outboundSchema,
} from "./openresponseswebsearch20250826tool.js";
import {
  OpenResponsesWebSearchPreview20250311Tool,
  OpenResponsesWebSearchPreview20250311Tool$inboundSchema,
  OpenResponsesWebSearchPreview20250311Tool$Outbound,
  OpenResponsesWebSearchPreview20250311Tool$outboundSchema,
} from "./openresponseswebsearchpreview20250311tool.js";
import {
  OpenResponsesWebSearchPreviewTool,
  OpenResponsesWebSearchPreviewTool$inboundSchema,
  OpenResponsesWebSearchPreviewTool$Outbound,
  OpenResponsesWebSearchPreviewTool$outboundSchema,
} from "./openresponseswebsearchpreviewtool.js";
import {
  OpenResponsesWebSearchTool,
  OpenResponsesWebSearchTool$inboundSchema,
  OpenResponsesWebSearchTool$Outbound,
  OpenResponsesWebSearchTool$outboundSchema,
} from "./openresponseswebsearchtool.js";
import {
  ProviderName,
  ProviderName$inboundSchema,
  ProviderName$outboundSchema,
} from "./providername.js";
import {
  ProviderSort,
  ProviderSort$inboundSchema,
  ProviderSort$outboundSchema,
} from "./providersort.js";
import {
  Quantization,
  Quantization$inboundSchema,
  Quantization$outboundSchema,
} from "./quantization.js";
import {
  ServiceTier,
  ServiceTier$inboundSchema,
  ServiceTier$outboundSchema,
} from "./servicetier.js";
import {
  Truncation,
  Truncation$inboundSchema,
  Truncation$outboundSchema,
} from "./truncation.js";

export const OpenResponsesRequestToolType = {
  Function: "function",
} as const;
export type OpenResponsesRequestToolType = ClosedEnum<
  typeof OpenResponsesRequestToolType
>;

/**
 * Function tool definition
 */
export type OpenResponsesRequestToolFunction = {
  type: OpenResponsesRequestToolType;
  name: string;
  description?: string | null | undefined;
  strict?: boolean | null | undefined;
  parameters: { [k: string]: any | null } | null;
};

export type OpenResponsesRequestToolUnion =
  | OpenResponsesRequestToolFunction
  | OpenResponsesWebSearchPreviewTool
  | OpenResponsesWebSearchPreview20250311Tool
  | OpenResponsesWebSearchTool
  | OpenResponsesWebSearch20250826Tool;

export const OpenResponsesRequestTypeWebSearchPreview = {
  WebSearchPreview: "web_search_preview",
} as const;
export type OpenResponsesRequestTypeWebSearchPreview = ClosedEnum<
  typeof OpenResponsesRequestTypeWebSearchPreview
>;

export const OpenResponsesRequestTypeWebSearchPreview20250311 = {
  WebSearchPreview20250311: "web_search_preview_2025_03_11",
} as const;
export type OpenResponsesRequestTypeWebSearchPreview20250311 = ClosedEnum<
  typeof OpenResponsesRequestTypeWebSearchPreview20250311
>;

export type OpenResponsesRequestTypeUnion =
  | OpenResponsesRequestTypeWebSearchPreview20250311
  | OpenResponsesRequestTypeWebSearchPreview;

export type OpenResponsesRequestToolChoice = {
  type:
    | OpenResponsesRequestTypeWebSearchPreview20250311
    | OpenResponsesRequestTypeWebSearchPreview;
};

export const OpenResponsesRequestToolChoiceTypeFunction = {
  Function: "function",
} as const;
export type OpenResponsesRequestToolChoiceTypeFunction = ClosedEnum<
  typeof OpenResponsesRequestToolChoiceTypeFunction
>;

export type OpenResponsesRequestToolChoiceFunction = {
  type: OpenResponsesRequestToolChoiceTypeFunction;
  name: string;
};

export const OpenResponsesRequestToolChoiceRequired = {
  Required: "required",
} as const;
export type OpenResponsesRequestToolChoiceRequired = ClosedEnum<
  typeof OpenResponsesRequestToolChoiceRequired
>;

export const OpenResponsesRequestToolChoiceNone = {
  None: "none",
} as const;
export type OpenResponsesRequestToolChoiceNone = ClosedEnum<
  typeof OpenResponsesRequestToolChoiceNone
>;

export const OpenResponsesRequestToolChoiceAuto = {
  Auto: "auto",
} as const;
export type OpenResponsesRequestToolChoiceAuto = ClosedEnum<
  typeof OpenResponsesRequestToolChoiceAuto
>;

export type OpenResponsesRequestToolChoiceUnion =
  | OpenResponsesRequestToolChoiceFunction
  | OpenResponsesRequestToolChoice
  | OpenResponsesRequestToolChoiceAuto
  | OpenResponsesRequestToolChoiceNone
  | OpenResponsesRequestToolChoiceRequired;

export type Order = ProviderName | string;

export type Only = ProviderName | string;

export type Ignore = ProviderName | string;

export type OpenResponsesRequestPrompt = number | string | any;

export type OpenResponsesRequestCompletion = number | string | any;

export type OpenResponsesRequestImage = number | string | any;

export type OpenResponsesRequestAudio = number | string | any;

export type OpenResponsesRequestRequest = number | string | any;

/**
 * The object specifying the maximum price you want to pay for this request. USD price per million tokens, for prompt and completion.
 */
export type MaxPrice = {
  prompt?: number | string | any | undefined;
  completion?: number | string | any | undefined;
  image?: number | string | any | undefined;
  audio?: number | string | any | undefined;
  request?: number | string | any | undefined;
};

export type Experimental = {};

/**
 * When multiple model providers are available, optionally indicate your routing preference.
 */
export type Provider = {
  /**
   * Whether to allow backup providers to serve requests
   *
   * @remarks
   * - true: (default) when the primary provider (or your custom providers in "order") is unavailable, use the next best provider.
   * - false: use only the primary/custom provider, and return the upstream error if it's unavailable.
   */
  allowFallbacks?: boolean | null | undefined;
  /**
   * Whether to filter providers to only those that support the parameters you've provided. If this setting is omitted or set to false, then providers will receive only the parameters they support, and ignore the rest.
   */
  requireParameters?: boolean | null | undefined;
  /**
   * Data collection setting. If no available model provider meets the requirement, your request will return an error.
   *
   * @remarks
   * - allow: (default) allow providers which store user data non-transiently and may train on it
   * - deny: use only providers which do not collect user data.
   */
  dataCollection?: DataCollection | null | undefined;
  /**
   * Whether to restrict routing to only ZDR (Zero Data Retention) endpoints. When true, only endpoints that do not retain prompts will be used.
   */
  zdr?: boolean | null | undefined;
  /**
   * An ordered list of provider slugs. The router will attempt to use the first provider in the subset of this list that supports your requested model, and fall back to the next if it is unavailable. If no providers are available, the request will fail with an error message.
   */
  order?: Array<ProviderName | string> | null | undefined;
  /**
   * List of provider slugs to allow. If provided, this list is merged with your account-wide allowed provider settings for this request.
   */
  only?: Array<ProviderName | string> | null | undefined;
  /**
   * List of provider slugs to ignore. If provided, this list is merged with your account-wide ignored provider settings for this request.
   */
  ignore?: Array<ProviderName | string> | null | undefined;
  /**
   * A list of quantization levels to filter the provider by.
   */
  quantizations?: Array<Quantization> | null | undefined;
  /**
   * The sorting strategy to use for this request, if "order" is not specified. When set, no load balancing is performed.
   */
  sort?: ProviderSort | null | undefined;
  /**
   * The object specifying the maximum price you want to pay for this request. USD price per million tokens, for prompt and completion.
   */
  maxPrice?: MaxPrice | undefined;
  experimental?: Experimental | null | undefined;
};

export const IdFileParser = {
  FileParser: "file-parser",
} as const;
export type IdFileParser = ClosedEnum<typeof IdFileParser>;

export const PdfEngine = {
  MistralOcr: "mistral-ocr",
  PdfText: "pdf-text",
  Native: "native",
} as const;
export type PdfEngine = OpenEnum<typeof PdfEngine>;

export type Pdf = {
  engine?: PdfEngine | undefined;
};

export type PluginFileParser = {
  id: IdFileParser;
  maxFiles?: number | undefined;
  pdf?: Pdf | undefined;
};

export const IdWeb = {
  Web: "web",
} as const;
export type IdWeb = ClosedEnum<typeof IdWeb>;

export const Engine = {
  Native: "native",
  Exa: "exa",
} as const;
export type Engine = OpenEnum<typeof Engine>;

export type PluginWeb = {
  id: IdWeb;
  maxResults?: number | undefined;
  searchPrompt?: string | undefined;
  engine?: Engine | undefined;
};

export const IdModeration = {
  Moderation: "moderation",
} as const;
export type IdModeration = ClosedEnum<typeof IdModeration>;

export type PluginModeration = {
  id: IdModeration;
};

export type Plugin = PluginModeration | PluginWeb | PluginFileParser;

/**
 * Request schema for Responses endpoint
 */
export type OpenResponsesRequest = {
  /**
   * Input for a response request - can be a string or array of items
   */
  input?: OpenResponsesInputUnion | undefined;
  instructions?: string | null | undefined;
  /**
   * Metadata key-value pairs for the request. Keys must be ≤64 characters and cannot contain brackets. Values must be ≤512 characters. Maximum 16 pairs allowed.
   */
  metadata?: { [k: string]: string } | null | undefined;
  tools?:
    | Array<
      | OpenResponsesRequestToolFunction
      | OpenResponsesWebSearchPreviewTool
      | OpenResponsesWebSearchPreview20250311Tool
      | OpenResponsesWebSearchTool
      | OpenResponsesWebSearch20250826Tool
    >
    | undefined;
  toolChoice?:
    | OpenResponsesRequestToolChoiceFunction
    | OpenResponsesRequestToolChoice
    | OpenResponsesRequestToolChoiceAuto
    | OpenResponsesRequestToolChoiceNone
    | OpenResponsesRequestToolChoiceRequired
    | undefined;
  parallelToolCalls?: boolean | null | undefined;
  model?: string | undefined;
  models?: Array<string> | undefined;
  /**
   * Text output configuration including format and verbosity
   */
  text?: OpenResponsesResponseText | undefined;
  /**
   * Configuration for reasoning mode in the response
   */
  reasoning?: OpenResponsesReasoningConfig | null | undefined;
  maxOutputTokens?: number | null | undefined;
  temperature?: number | null | undefined;
  topP?: number | null | undefined;
  topK?: number | undefined;
  promptCacheKey?: string | null | undefined;
  previousResponseId?: string | null | undefined;
  prompt?: OpenAIResponsesPrompt | null | undefined;
  include?: Array<OpenAIResponsesIncludable> | null | undefined;
  background?: boolean | null | undefined;
  safetyIdentifier?: string | null | undefined;
  store?: boolean | null | undefined;
  serviceTier?: ServiceTier | null | undefined;
  truncation?: Truncation | null | undefined;
  stream?: boolean | null | undefined;
  /**
   * When multiple model providers are available, optionally indicate your routing preference.
   */
  provider?: Provider | null | undefined;
  /**
   * Plugins you want to enable for this request, including their settings.
   */
  plugins?: Array<PluginModeration | PluginWeb | PluginFileParser> | undefined;
  /**
   * A unique identifier representing your end-user, which helps distinguish between different users of your app. This allows your app to identify specific users in case of abuse reports, preventing your entire app from being affected by the actions of individual users. Maximum of 128 characters.
   */
  user?: string | undefined;
};

/** @internal */
export const OpenResponsesRequestToolType$inboundSchema: z.ZodNativeEnum<
  typeof OpenResponsesRequestToolType
> = z.nativeEnum(OpenResponsesRequestToolType);

/** @internal */
export const OpenResponsesRequestToolType$outboundSchema: z.ZodNativeEnum<
  typeof OpenResponsesRequestToolType
> = OpenResponsesRequestToolType$inboundSchema;

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace OpenResponsesRequestToolType$ {
  /** @deprecated use `OpenResponsesRequestToolType$inboundSchema` instead. */
  export const inboundSchema = OpenResponsesRequestToolType$inboundSchema;
  /** @deprecated use `OpenResponsesRequestToolType$outboundSchema` instead. */
  export const outboundSchema = OpenResponsesRequestToolType$outboundSchema;
}

/** @internal */
export const OpenResponsesRequestToolFunction$inboundSchema: z.ZodType<
  OpenResponsesRequestToolFunction,
  z.ZodTypeDef,
  unknown
> = z.object({
  type: OpenResponsesRequestToolType$inboundSchema,
  name: z.string(),
  description: z.nullable(z.string()).optional(),
  strict: z.nullable(z.boolean()).optional(),
  parameters: z.nullable(z.record(z.nullable(z.any()))),
});

/** @internal */
export type OpenResponsesRequestToolFunction$Outbound = {
  type: string;
  name: string;
  description?: string | null | undefined;
  strict?: boolean | null | undefined;
  parameters: { [k: string]: any | null } | null;
};

/** @internal */
export const OpenResponsesRequestToolFunction$outboundSchema: z.ZodType<
  OpenResponsesRequestToolFunction$Outbound,
  z.ZodTypeDef,
  OpenResponsesRequestToolFunction
> = z.object({
  type: OpenResponsesRequestToolType$outboundSchema,
  name: z.string(),
  description: z.nullable(z.string()).optional(),
  strict: z.nullable(z.boolean()).optional(),
  parameters: z.nullable(z.record(z.nullable(z.any()))),
});

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace OpenResponsesRequestToolFunction$ {
  /** @deprecated use `OpenResponsesRequestToolFunction$inboundSchema` instead. */
  export const inboundSchema = OpenResponsesRequestToolFunction$inboundSchema;
  /** @deprecated use `OpenResponsesRequestToolFunction$outboundSchema` instead. */
  export const outboundSchema = OpenResponsesRequestToolFunction$outboundSchema;
  /** @deprecated use `OpenResponsesRequestToolFunction$Outbound` instead. */
  export type Outbound = OpenResponsesRequestToolFunction$Outbound;
}

export function openResponsesRequestToolFunctionToJSON(
  openResponsesRequestToolFunction: OpenResponsesRequestToolFunction,
): string {
  return JSON.stringify(
    OpenResponsesRequestToolFunction$outboundSchema.parse(
      openResponsesRequestToolFunction,
    ),
  );
}

export function openResponsesRequestToolFunctionFromJSON(
  jsonString: string,
): SafeParseResult<OpenResponsesRequestToolFunction, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => OpenResponsesRequestToolFunction$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'OpenResponsesRequestToolFunction' from JSON`,
  );
}

/** @internal */
export const OpenResponsesRequestToolUnion$inboundSchema: z.ZodType<
  OpenResponsesRequestToolUnion,
  z.ZodTypeDef,
  unknown
> = z.union([
  z.lazy(() => OpenResponsesRequestToolFunction$inboundSchema),
  OpenResponsesWebSearchPreviewTool$inboundSchema,
  OpenResponsesWebSearchPreview20250311Tool$inboundSchema,
  OpenResponsesWebSearchTool$inboundSchema,
  OpenResponsesWebSearch20250826Tool$inboundSchema,
]);

/** @internal */
export type OpenResponsesRequestToolUnion$Outbound =
  | OpenResponsesRequestToolFunction$Outbound
  | OpenResponsesWebSearchPreviewTool$Outbound
  | OpenResponsesWebSearchPreview20250311Tool$Outbound
  | OpenResponsesWebSearchTool$Outbound
  | OpenResponsesWebSearch20250826Tool$Outbound;

/** @internal */
export const OpenResponsesRequestToolUnion$outboundSchema: z.ZodType<
  OpenResponsesRequestToolUnion$Outbound,
  z.ZodTypeDef,
  OpenResponsesRequestToolUnion
> = z.union([
  z.lazy(() => OpenResponsesRequestToolFunction$outboundSchema),
  OpenResponsesWebSearchPreviewTool$outboundSchema,
  OpenResponsesWebSearchPreview20250311Tool$outboundSchema,
  OpenResponsesWebSearchTool$outboundSchema,
  OpenResponsesWebSearch20250826Tool$outboundSchema,
]);

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace OpenResponsesRequestToolUnion$ {
  /** @deprecated use `OpenResponsesRequestToolUnion$inboundSchema` instead. */
  export const inboundSchema = OpenResponsesRequestToolUnion$inboundSchema;
  /** @deprecated use `OpenResponsesRequestToolUnion$outboundSchema` instead. */
  export const outboundSchema = OpenResponsesRequestToolUnion$outboundSchema;
  /** @deprecated use `OpenResponsesRequestToolUnion$Outbound` instead. */
  export type Outbound = OpenResponsesRequestToolUnion$Outbound;
}

export function openResponsesRequestToolUnionToJSON(
  openResponsesRequestToolUnion: OpenResponsesRequestToolUnion,
): string {
  return JSON.stringify(
    OpenResponsesRequestToolUnion$outboundSchema.parse(
      openResponsesRequestToolUnion,
    ),
  );
}

export function openResponsesRequestToolUnionFromJSON(
  jsonString: string,
): SafeParseResult<OpenResponsesRequestToolUnion, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => OpenResponsesRequestToolUnion$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'OpenResponsesRequestToolUnion' from JSON`,
  );
}

/** @internal */
export const OpenResponsesRequestTypeWebSearchPreview$inboundSchema:
  z.ZodNativeEnum<typeof OpenResponsesRequestTypeWebSearchPreview> = z
    .nativeEnum(OpenResponsesRequestTypeWebSearchPreview);

/** @internal */
export const OpenResponsesRequestTypeWebSearchPreview$outboundSchema:
  z.ZodNativeEnum<typeof OpenResponsesRequestTypeWebSearchPreview> =
    OpenResponsesRequestTypeWebSearchPreview$inboundSchema;

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace OpenResponsesRequestTypeWebSearchPreview$ {
  /** @deprecated use `OpenResponsesRequestTypeWebSearchPreview$inboundSchema` instead. */
  export const inboundSchema =
    OpenResponsesRequestTypeWebSearchPreview$inboundSchema;
  /** @deprecated use `OpenResponsesRequestTypeWebSearchPreview$outboundSchema` instead. */
  export const outboundSchema =
    OpenResponsesRequestTypeWebSearchPreview$outboundSchema;
}

/** @internal */
export const OpenResponsesRequestTypeWebSearchPreview20250311$inboundSchema:
  z.ZodNativeEnum<typeof OpenResponsesRequestTypeWebSearchPreview20250311> = z
    .nativeEnum(OpenResponsesRequestTypeWebSearchPreview20250311);

/** @internal */
export const OpenResponsesRequestTypeWebSearchPreview20250311$outboundSchema:
  z.ZodNativeEnum<typeof OpenResponsesRequestTypeWebSearchPreview20250311> =
    OpenResponsesRequestTypeWebSearchPreview20250311$inboundSchema;

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace OpenResponsesRequestTypeWebSearchPreview20250311$ {
  /** @deprecated use `OpenResponsesRequestTypeWebSearchPreview20250311$inboundSchema` instead. */
  export const inboundSchema =
    OpenResponsesRequestTypeWebSearchPreview20250311$inboundSchema;
  /** @deprecated use `OpenResponsesRequestTypeWebSearchPreview20250311$outboundSchema` instead. */
  export const outboundSchema =
    OpenResponsesRequestTypeWebSearchPreview20250311$outboundSchema;
}

/** @internal */
export const OpenResponsesRequestTypeUnion$inboundSchema: z.ZodType<
  OpenResponsesRequestTypeUnion,
  z.ZodTypeDef,
  unknown
> = z.union([
  OpenResponsesRequestTypeWebSearchPreview20250311$inboundSchema,
  OpenResponsesRequestTypeWebSearchPreview$inboundSchema,
]);

/** @internal */
export type OpenResponsesRequestTypeUnion$Outbound = string | string;

/** @internal */
export const OpenResponsesRequestTypeUnion$outboundSchema: z.ZodType<
  OpenResponsesRequestTypeUnion$Outbound,
  z.ZodTypeDef,
  OpenResponsesRequestTypeUnion
> = z.union([
  OpenResponsesRequestTypeWebSearchPreview20250311$outboundSchema,
  OpenResponsesRequestTypeWebSearchPreview$outboundSchema,
]);

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace OpenResponsesRequestTypeUnion$ {
  /** @deprecated use `OpenResponsesRequestTypeUnion$inboundSchema` instead. */
  export const inboundSchema = OpenResponsesRequestTypeUnion$inboundSchema;
  /** @deprecated use `OpenResponsesRequestTypeUnion$outboundSchema` instead. */
  export const outboundSchema = OpenResponsesRequestTypeUnion$outboundSchema;
  /** @deprecated use `OpenResponsesRequestTypeUnion$Outbound` instead. */
  export type Outbound = OpenResponsesRequestTypeUnion$Outbound;
}

export function openResponsesRequestTypeUnionToJSON(
  openResponsesRequestTypeUnion: OpenResponsesRequestTypeUnion,
): string {
  return JSON.stringify(
    OpenResponsesRequestTypeUnion$outboundSchema.parse(
      openResponsesRequestTypeUnion,
    ),
  );
}

export function openResponsesRequestTypeUnionFromJSON(
  jsonString: string,
): SafeParseResult<OpenResponsesRequestTypeUnion, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => OpenResponsesRequestTypeUnion$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'OpenResponsesRequestTypeUnion' from JSON`,
  );
}

/** @internal */
export const OpenResponsesRequestToolChoice$inboundSchema: z.ZodType<
  OpenResponsesRequestToolChoice,
  z.ZodTypeDef,
  unknown
> = z.object({
  type: z.union([
    OpenResponsesRequestTypeWebSearchPreview20250311$inboundSchema,
    OpenResponsesRequestTypeWebSearchPreview$inboundSchema,
  ]),
});

/** @internal */
export type OpenResponsesRequestToolChoice$Outbound = {
  type: string | string;
};

/** @internal */
export const OpenResponsesRequestToolChoice$outboundSchema: z.ZodType<
  OpenResponsesRequestToolChoice$Outbound,
  z.ZodTypeDef,
  OpenResponsesRequestToolChoice
> = z.object({
  type: z.union([
    OpenResponsesRequestTypeWebSearchPreview20250311$outboundSchema,
    OpenResponsesRequestTypeWebSearchPreview$outboundSchema,
  ]),
});

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace OpenResponsesRequestToolChoice$ {
  /** @deprecated use `OpenResponsesRequestToolChoice$inboundSchema` instead. */
  export const inboundSchema = OpenResponsesRequestToolChoice$inboundSchema;
  /** @deprecated use `OpenResponsesRequestToolChoice$outboundSchema` instead. */
  export const outboundSchema = OpenResponsesRequestToolChoice$outboundSchema;
  /** @deprecated use `OpenResponsesRequestToolChoice$Outbound` instead. */
  export type Outbound = OpenResponsesRequestToolChoice$Outbound;
}

export function openResponsesRequestToolChoiceToJSON(
  openResponsesRequestToolChoice: OpenResponsesRequestToolChoice,
): string {
  return JSON.stringify(
    OpenResponsesRequestToolChoice$outboundSchema.parse(
      openResponsesRequestToolChoice,
    ),
  );
}

export function openResponsesRequestToolChoiceFromJSON(
  jsonString: string,
): SafeParseResult<OpenResponsesRequestToolChoice, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => OpenResponsesRequestToolChoice$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'OpenResponsesRequestToolChoice' from JSON`,
  );
}

/** @internal */
export const OpenResponsesRequestToolChoiceTypeFunction$inboundSchema:
  z.ZodNativeEnum<typeof OpenResponsesRequestToolChoiceTypeFunction> = z
    .nativeEnum(OpenResponsesRequestToolChoiceTypeFunction);

/** @internal */
export const OpenResponsesRequestToolChoiceTypeFunction$outboundSchema:
  z.ZodNativeEnum<typeof OpenResponsesRequestToolChoiceTypeFunction> =
    OpenResponsesRequestToolChoiceTypeFunction$inboundSchema;

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace OpenResponsesRequestToolChoiceTypeFunction$ {
  /** @deprecated use `OpenResponsesRequestToolChoiceTypeFunction$inboundSchema` instead. */
  export const inboundSchema =
    OpenResponsesRequestToolChoiceTypeFunction$inboundSchema;
  /** @deprecated use `OpenResponsesRequestToolChoiceTypeFunction$outboundSchema` instead. */
  export const outboundSchema =
    OpenResponsesRequestToolChoiceTypeFunction$outboundSchema;
}

/** @internal */
export const OpenResponsesRequestToolChoiceFunction$inboundSchema: z.ZodType<
  OpenResponsesRequestToolChoiceFunction,
  z.ZodTypeDef,
  unknown
> = z.object({
  type: OpenResponsesRequestToolChoiceTypeFunction$inboundSchema,
  name: z.string(),
});

/** @internal */
export type OpenResponsesRequestToolChoiceFunction$Outbound = {
  type: string;
  name: string;
};

/** @internal */
export const OpenResponsesRequestToolChoiceFunction$outboundSchema: z.ZodType<
  OpenResponsesRequestToolChoiceFunction$Outbound,
  z.ZodTypeDef,
  OpenResponsesRequestToolChoiceFunction
> = z.object({
  type: OpenResponsesRequestToolChoiceTypeFunction$outboundSchema,
  name: z.string(),
});

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace OpenResponsesRequestToolChoiceFunction$ {
  /** @deprecated use `OpenResponsesRequestToolChoiceFunction$inboundSchema` instead. */
  export const inboundSchema =
    OpenResponsesRequestToolChoiceFunction$inboundSchema;
  /** @deprecated use `OpenResponsesRequestToolChoiceFunction$outboundSchema` instead. */
  export const outboundSchema =
    OpenResponsesRequestToolChoiceFunction$outboundSchema;
  /** @deprecated use `OpenResponsesRequestToolChoiceFunction$Outbound` instead. */
  export type Outbound = OpenResponsesRequestToolChoiceFunction$Outbound;
}

export function openResponsesRequestToolChoiceFunctionToJSON(
  openResponsesRequestToolChoiceFunction:
    OpenResponsesRequestToolChoiceFunction,
): string {
  return JSON.stringify(
    OpenResponsesRequestToolChoiceFunction$outboundSchema.parse(
      openResponsesRequestToolChoiceFunction,
    ),
  );
}

export function openResponsesRequestToolChoiceFunctionFromJSON(
  jsonString: string,
): SafeParseResult<OpenResponsesRequestToolChoiceFunction, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) =>
      OpenResponsesRequestToolChoiceFunction$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'OpenResponsesRequestToolChoiceFunction' from JSON`,
  );
}

/** @internal */
export const OpenResponsesRequestToolChoiceRequired$inboundSchema:
  z.ZodNativeEnum<typeof OpenResponsesRequestToolChoiceRequired> = z.nativeEnum(
    OpenResponsesRequestToolChoiceRequired,
  );

/** @internal */
export const OpenResponsesRequestToolChoiceRequired$outboundSchema:
  z.ZodNativeEnum<typeof OpenResponsesRequestToolChoiceRequired> =
    OpenResponsesRequestToolChoiceRequired$inboundSchema;

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace OpenResponsesRequestToolChoiceRequired$ {
  /** @deprecated use `OpenResponsesRequestToolChoiceRequired$inboundSchema` instead. */
  export const inboundSchema =
    OpenResponsesRequestToolChoiceRequired$inboundSchema;
  /** @deprecated use `OpenResponsesRequestToolChoiceRequired$outboundSchema` instead. */
  export const outboundSchema =
    OpenResponsesRequestToolChoiceRequired$outboundSchema;
}

/** @internal */
export const OpenResponsesRequestToolChoiceNone$inboundSchema: z.ZodNativeEnum<
  typeof OpenResponsesRequestToolChoiceNone
> = z.nativeEnum(OpenResponsesRequestToolChoiceNone);

/** @internal */
export const OpenResponsesRequestToolChoiceNone$outboundSchema: z.ZodNativeEnum<
  typeof OpenResponsesRequestToolChoiceNone
> = OpenResponsesRequestToolChoiceNone$inboundSchema;

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace OpenResponsesRequestToolChoiceNone$ {
  /** @deprecated use `OpenResponsesRequestToolChoiceNone$inboundSchema` instead. */
  export const inboundSchema = OpenResponsesRequestToolChoiceNone$inboundSchema;
  /** @deprecated use `OpenResponsesRequestToolChoiceNone$outboundSchema` instead. */
  export const outboundSchema =
    OpenResponsesRequestToolChoiceNone$outboundSchema;
}

/** @internal */
export const OpenResponsesRequestToolChoiceAuto$inboundSchema: z.ZodNativeEnum<
  typeof OpenResponsesRequestToolChoiceAuto
> = z.nativeEnum(OpenResponsesRequestToolChoiceAuto);

/** @internal */
export const OpenResponsesRequestToolChoiceAuto$outboundSchema: z.ZodNativeEnum<
  typeof OpenResponsesRequestToolChoiceAuto
> = OpenResponsesRequestToolChoiceAuto$inboundSchema;

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace OpenResponsesRequestToolChoiceAuto$ {
  /** @deprecated use `OpenResponsesRequestToolChoiceAuto$inboundSchema` instead. */
  export const inboundSchema = OpenResponsesRequestToolChoiceAuto$inboundSchema;
  /** @deprecated use `OpenResponsesRequestToolChoiceAuto$outboundSchema` instead. */
  export const outboundSchema =
    OpenResponsesRequestToolChoiceAuto$outboundSchema;
}

/** @internal */
export const OpenResponsesRequestToolChoiceUnion$inboundSchema: z.ZodType<
  OpenResponsesRequestToolChoiceUnion,
  z.ZodTypeDef,
  unknown
> = z.union([
  z.lazy(() => OpenResponsesRequestToolChoiceFunction$inboundSchema),
  z.lazy(() => OpenResponsesRequestToolChoice$inboundSchema),
  OpenResponsesRequestToolChoiceAuto$inboundSchema,
  OpenResponsesRequestToolChoiceNone$inboundSchema,
  OpenResponsesRequestToolChoiceRequired$inboundSchema,
]);

/** @internal */
export type OpenResponsesRequestToolChoiceUnion$Outbound =
  | OpenResponsesRequestToolChoiceFunction$Outbound
  | OpenResponsesRequestToolChoice$Outbound
  | string
  | string
  | string;

/** @internal */
export const OpenResponsesRequestToolChoiceUnion$outboundSchema: z.ZodType<
  OpenResponsesRequestToolChoiceUnion$Outbound,
  z.ZodTypeDef,
  OpenResponsesRequestToolChoiceUnion
> = z.union([
  z.lazy(() => OpenResponsesRequestToolChoiceFunction$outboundSchema),
  z.lazy(() => OpenResponsesRequestToolChoice$outboundSchema),
  OpenResponsesRequestToolChoiceAuto$outboundSchema,
  OpenResponsesRequestToolChoiceNone$outboundSchema,
  OpenResponsesRequestToolChoiceRequired$outboundSchema,
]);

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace OpenResponsesRequestToolChoiceUnion$ {
  /** @deprecated use `OpenResponsesRequestToolChoiceUnion$inboundSchema` instead. */
  export const inboundSchema =
    OpenResponsesRequestToolChoiceUnion$inboundSchema;
  /** @deprecated use `OpenResponsesRequestToolChoiceUnion$outboundSchema` instead. */
  export const outboundSchema =
    OpenResponsesRequestToolChoiceUnion$outboundSchema;
  /** @deprecated use `OpenResponsesRequestToolChoiceUnion$Outbound` instead. */
  export type Outbound = OpenResponsesRequestToolChoiceUnion$Outbound;
}

export function openResponsesRequestToolChoiceUnionToJSON(
  openResponsesRequestToolChoiceUnion: OpenResponsesRequestToolChoiceUnion,
): string {
  return JSON.stringify(
    OpenResponsesRequestToolChoiceUnion$outboundSchema.parse(
      openResponsesRequestToolChoiceUnion,
    ),
  );
}

export function openResponsesRequestToolChoiceUnionFromJSON(
  jsonString: string,
): SafeParseResult<OpenResponsesRequestToolChoiceUnion, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) =>
      OpenResponsesRequestToolChoiceUnion$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'OpenResponsesRequestToolChoiceUnion' from JSON`,
  );
}

/** @internal */
export const Order$inboundSchema: z.ZodType<Order, z.ZodTypeDef, unknown> = z
  .union([ProviderName$inboundSchema, z.string()]);

/** @internal */
export type Order$Outbound = string | string;

/** @internal */
export const Order$outboundSchema: z.ZodType<
  Order$Outbound,
  z.ZodTypeDef,
  Order
> = z.union([ProviderName$outboundSchema, z.string()]);

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace Order$ {
  /** @deprecated use `Order$inboundSchema` instead. */
  export const inboundSchema = Order$inboundSchema;
  /** @deprecated use `Order$outboundSchema` instead. */
  export const outboundSchema = Order$outboundSchema;
  /** @deprecated use `Order$Outbound` instead. */
  export type Outbound = Order$Outbound;
}

export function orderToJSON(order: Order): string {
  return JSON.stringify(Order$outboundSchema.parse(order));
}

export function orderFromJSON(
  jsonString: string,
): SafeParseResult<Order, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => Order$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'Order' from JSON`,
  );
}

/** @internal */
export const Only$inboundSchema: z.ZodType<Only, z.ZodTypeDef, unknown> = z
  .union([ProviderName$inboundSchema, z.string()]);

/** @internal */
export type Only$Outbound = string | string;

/** @internal */
export const Only$outboundSchema: z.ZodType<Only$Outbound, z.ZodTypeDef, Only> =
  z.union([ProviderName$outboundSchema, z.string()]);

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace Only$ {
  /** @deprecated use `Only$inboundSchema` instead. */
  export const inboundSchema = Only$inboundSchema;
  /** @deprecated use `Only$outboundSchema` instead. */
  export const outboundSchema = Only$outboundSchema;
  /** @deprecated use `Only$Outbound` instead. */
  export type Outbound = Only$Outbound;
}

export function onlyToJSON(only: Only): string {
  return JSON.stringify(Only$outboundSchema.parse(only));
}

export function onlyFromJSON(
  jsonString: string,
): SafeParseResult<Only, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => Only$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'Only' from JSON`,
  );
}

/** @internal */
export const Ignore$inboundSchema: z.ZodType<Ignore, z.ZodTypeDef, unknown> = z
  .union([ProviderName$inboundSchema, z.string()]);

/** @internal */
export type Ignore$Outbound = string | string;

/** @internal */
export const Ignore$outboundSchema: z.ZodType<
  Ignore$Outbound,
  z.ZodTypeDef,
  Ignore
> = z.union([ProviderName$outboundSchema, z.string()]);

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace Ignore$ {
  /** @deprecated use `Ignore$inboundSchema` instead. */
  export const inboundSchema = Ignore$inboundSchema;
  /** @deprecated use `Ignore$outboundSchema` instead. */
  export const outboundSchema = Ignore$outboundSchema;
  /** @deprecated use `Ignore$Outbound` instead. */
  export type Outbound = Ignore$Outbound;
}

export function ignoreToJSON(ignore: Ignore): string {
  return JSON.stringify(Ignore$outboundSchema.parse(ignore));
}

export function ignoreFromJSON(
  jsonString: string,
): SafeParseResult<Ignore, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => Ignore$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'Ignore' from JSON`,
  );
}

/** @internal */
export const OpenResponsesRequestPrompt$inboundSchema: z.ZodType<
  OpenResponsesRequestPrompt,
  z.ZodTypeDef,
  unknown
> = z.union([z.number(), z.string(), z.any()]);

/** @internal */
export type OpenResponsesRequestPrompt$Outbound = number | string | any;

/** @internal */
export const OpenResponsesRequestPrompt$outboundSchema: z.ZodType<
  OpenResponsesRequestPrompt$Outbound,
  z.ZodTypeDef,
  OpenResponsesRequestPrompt
> = z.union([z.number(), z.string(), z.any()]);

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace OpenResponsesRequestPrompt$ {
  /** @deprecated use `OpenResponsesRequestPrompt$inboundSchema` instead. */
  export const inboundSchema = OpenResponsesRequestPrompt$inboundSchema;
  /** @deprecated use `OpenResponsesRequestPrompt$outboundSchema` instead. */
  export const outboundSchema = OpenResponsesRequestPrompt$outboundSchema;
  /** @deprecated use `OpenResponsesRequestPrompt$Outbound` instead. */
  export type Outbound = OpenResponsesRequestPrompt$Outbound;
}

export function openResponsesRequestPromptToJSON(
  openResponsesRequestPrompt: OpenResponsesRequestPrompt,
): string {
  return JSON.stringify(
    OpenResponsesRequestPrompt$outboundSchema.parse(openResponsesRequestPrompt),
  );
}

export function openResponsesRequestPromptFromJSON(
  jsonString: string,
): SafeParseResult<OpenResponsesRequestPrompt, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => OpenResponsesRequestPrompt$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'OpenResponsesRequestPrompt' from JSON`,
  );
}

/** @internal */
export const OpenResponsesRequestCompletion$inboundSchema: z.ZodType<
  OpenResponsesRequestCompletion,
  z.ZodTypeDef,
  unknown
> = z.union([z.number(), z.string(), z.any()]);

/** @internal */
export type OpenResponsesRequestCompletion$Outbound = number | string | any;

/** @internal */
export const OpenResponsesRequestCompletion$outboundSchema: z.ZodType<
  OpenResponsesRequestCompletion$Outbound,
  z.ZodTypeDef,
  OpenResponsesRequestCompletion
> = z.union([z.number(), z.string(), z.any()]);

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace OpenResponsesRequestCompletion$ {
  /** @deprecated use `OpenResponsesRequestCompletion$inboundSchema` instead. */
  export const inboundSchema = OpenResponsesRequestCompletion$inboundSchema;
  /** @deprecated use `OpenResponsesRequestCompletion$outboundSchema` instead. */
  export const outboundSchema = OpenResponsesRequestCompletion$outboundSchema;
  /** @deprecated use `OpenResponsesRequestCompletion$Outbound` instead. */
  export type Outbound = OpenResponsesRequestCompletion$Outbound;
}

export function openResponsesRequestCompletionToJSON(
  openResponsesRequestCompletion: OpenResponsesRequestCompletion,
): string {
  return JSON.stringify(
    OpenResponsesRequestCompletion$outboundSchema.parse(
      openResponsesRequestCompletion,
    ),
  );
}

export function openResponsesRequestCompletionFromJSON(
  jsonString: string,
): SafeParseResult<OpenResponsesRequestCompletion, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => OpenResponsesRequestCompletion$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'OpenResponsesRequestCompletion' from JSON`,
  );
}

/** @internal */
export const OpenResponsesRequestImage$inboundSchema: z.ZodType<
  OpenResponsesRequestImage,
  z.ZodTypeDef,
  unknown
> = z.union([z.number(), z.string(), z.any()]);

/** @internal */
export type OpenResponsesRequestImage$Outbound = number | string | any;

/** @internal */
export const OpenResponsesRequestImage$outboundSchema: z.ZodType<
  OpenResponsesRequestImage$Outbound,
  z.ZodTypeDef,
  OpenResponsesRequestImage
> = z.union([z.number(), z.string(), z.any()]);

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace OpenResponsesRequestImage$ {
  /** @deprecated use `OpenResponsesRequestImage$inboundSchema` instead. */
  export const inboundSchema = OpenResponsesRequestImage$inboundSchema;
  /** @deprecated use `OpenResponsesRequestImage$outboundSchema` instead. */
  export const outboundSchema = OpenResponsesRequestImage$outboundSchema;
  /** @deprecated use `OpenResponsesRequestImage$Outbound` instead. */
  export type Outbound = OpenResponsesRequestImage$Outbound;
}

export function openResponsesRequestImageToJSON(
  openResponsesRequestImage: OpenResponsesRequestImage,
): string {
  return JSON.stringify(
    OpenResponsesRequestImage$outboundSchema.parse(openResponsesRequestImage),
  );
}

export function openResponsesRequestImageFromJSON(
  jsonString: string,
): SafeParseResult<OpenResponsesRequestImage, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => OpenResponsesRequestImage$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'OpenResponsesRequestImage' from JSON`,
  );
}

/** @internal */
export const OpenResponsesRequestAudio$inboundSchema: z.ZodType<
  OpenResponsesRequestAudio,
  z.ZodTypeDef,
  unknown
> = z.union([z.number(), z.string(), z.any()]);

/** @internal */
export type OpenResponsesRequestAudio$Outbound = number | string | any;

/** @internal */
export const OpenResponsesRequestAudio$outboundSchema: z.ZodType<
  OpenResponsesRequestAudio$Outbound,
  z.ZodTypeDef,
  OpenResponsesRequestAudio
> = z.union([z.number(), z.string(), z.any()]);

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace OpenResponsesRequestAudio$ {
  /** @deprecated use `OpenResponsesRequestAudio$inboundSchema` instead. */
  export const inboundSchema = OpenResponsesRequestAudio$inboundSchema;
  /** @deprecated use `OpenResponsesRequestAudio$outboundSchema` instead. */
  export const outboundSchema = OpenResponsesRequestAudio$outboundSchema;
  /** @deprecated use `OpenResponsesRequestAudio$Outbound` instead. */
  export type Outbound = OpenResponsesRequestAudio$Outbound;
}

export function openResponsesRequestAudioToJSON(
  openResponsesRequestAudio: OpenResponsesRequestAudio,
): string {
  return JSON.stringify(
    OpenResponsesRequestAudio$outboundSchema.parse(openResponsesRequestAudio),
  );
}

export function openResponsesRequestAudioFromJSON(
  jsonString: string,
): SafeParseResult<OpenResponsesRequestAudio, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => OpenResponsesRequestAudio$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'OpenResponsesRequestAudio' from JSON`,
  );
}

/** @internal */
export const OpenResponsesRequestRequest$inboundSchema: z.ZodType<
  OpenResponsesRequestRequest,
  z.ZodTypeDef,
  unknown
> = z.union([z.number(), z.string(), z.any()]);

/** @internal */
export type OpenResponsesRequestRequest$Outbound = number | string | any;

/** @internal */
export const OpenResponsesRequestRequest$outboundSchema: z.ZodType<
  OpenResponsesRequestRequest$Outbound,
  z.ZodTypeDef,
  OpenResponsesRequestRequest
> = z.union([z.number(), z.string(), z.any()]);

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace OpenResponsesRequestRequest$ {
  /** @deprecated use `OpenResponsesRequestRequest$inboundSchema` instead. */
  export const inboundSchema = OpenResponsesRequestRequest$inboundSchema;
  /** @deprecated use `OpenResponsesRequestRequest$outboundSchema` instead. */
  export const outboundSchema = OpenResponsesRequestRequest$outboundSchema;
  /** @deprecated use `OpenResponsesRequestRequest$Outbound` instead. */
  export type Outbound = OpenResponsesRequestRequest$Outbound;
}

export function openResponsesRequestRequestToJSON(
  openResponsesRequestRequest: OpenResponsesRequestRequest,
): string {
  return JSON.stringify(
    OpenResponsesRequestRequest$outboundSchema.parse(
      openResponsesRequestRequest,
    ),
  );
}

export function openResponsesRequestRequestFromJSON(
  jsonString: string,
): SafeParseResult<OpenResponsesRequestRequest, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => OpenResponsesRequestRequest$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'OpenResponsesRequestRequest' from JSON`,
  );
}

/** @internal */
export const MaxPrice$inboundSchema: z.ZodType<
  MaxPrice,
  z.ZodTypeDef,
  unknown
> = z.object({
  prompt: z.union([z.number(), z.string(), z.any()]).optional(),
  completion: z.union([z.number(), z.string(), z.any()]).optional(),
  image: z.union([z.number(), z.string(), z.any()]).optional(),
  audio: z.union([z.number(), z.string(), z.any()]).optional(),
  request: z.union([z.number(), z.string(), z.any()]).optional(),
});

/** @internal */
export type MaxPrice$Outbound = {
  prompt?: number | string | any | undefined;
  completion?: number | string | any | undefined;
  image?: number | string | any | undefined;
  audio?: number | string | any | undefined;
  request?: number | string | any | undefined;
};

/** @internal */
export const MaxPrice$outboundSchema: z.ZodType<
  MaxPrice$Outbound,
  z.ZodTypeDef,
  MaxPrice
> = z.object({
  prompt: z.union([z.number(), z.string(), z.any()]).optional(),
  completion: z.union([z.number(), z.string(), z.any()]).optional(),
  image: z.union([z.number(), z.string(), z.any()]).optional(),
  audio: z.union([z.number(), z.string(), z.any()]).optional(),
  request: z.union([z.number(), z.string(), z.any()]).optional(),
});

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace MaxPrice$ {
  /** @deprecated use `MaxPrice$inboundSchema` instead. */
  export const inboundSchema = MaxPrice$inboundSchema;
  /** @deprecated use `MaxPrice$outboundSchema` instead. */
  export const outboundSchema = MaxPrice$outboundSchema;
  /** @deprecated use `MaxPrice$Outbound` instead. */
  export type Outbound = MaxPrice$Outbound;
}

export function maxPriceToJSON(maxPrice: MaxPrice): string {
  return JSON.stringify(MaxPrice$outboundSchema.parse(maxPrice));
}

export function maxPriceFromJSON(
  jsonString: string,
): SafeParseResult<MaxPrice, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => MaxPrice$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'MaxPrice' from JSON`,
  );
}

/** @internal */
export const Experimental$inboundSchema: z.ZodType<
  Experimental,
  z.ZodTypeDef,
  unknown
> = z.object({});

/** @internal */
export type Experimental$Outbound = {};

/** @internal */
export const Experimental$outboundSchema: z.ZodType<
  Experimental$Outbound,
  z.ZodTypeDef,
  Experimental
> = z.object({});

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace Experimental$ {
  /** @deprecated use `Experimental$inboundSchema` instead. */
  export const inboundSchema = Experimental$inboundSchema;
  /** @deprecated use `Experimental$outboundSchema` instead. */
  export const outboundSchema = Experimental$outboundSchema;
  /** @deprecated use `Experimental$Outbound` instead. */
  export type Outbound = Experimental$Outbound;
}

export function experimentalToJSON(experimental: Experimental): string {
  return JSON.stringify(Experimental$outboundSchema.parse(experimental));
}

export function experimentalFromJSON(
  jsonString: string,
): SafeParseResult<Experimental, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => Experimental$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'Experimental' from JSON`,
  );
}

/** @internal */
export const Provider$inboundSchema: z.ZodType<
  Provider,
  z.ZodTypeDef,
  unknown
> = z.object({
  allow_fallbacks: z.nullable(z.boolean()).optional(),
  require_parameters: z.nullable(z.boolean()).optional(),
  data_collection: z.nullable(DataCollection$inboundSchema).optional(),
  zdr: z.nullable(z.boolean()).optional(),
  order: z.nullable(z.array(z.union([ProviderName$inboundSchema, z.string()])))
    .optional(),
  only: z.nullable(z.array(z.union([ProviderName$inboundSchema, z.string()])))
    .optional(),
  ignore: z.nullable(z.array(z.union([ProviderName$inboundSchema, z.string()])))
    .optional(),
  quantizations: z.nullable(z.array(Quantization$inboundSchema)).optional(),
  sort: z.nullable(ProviderSort$inboundSchema).optional(),
  max_price: z.lazy(() => MaxPrice$inboundSchema).optional(),
  experimental: z.nullable(z.lazy(() => Experimental$inboundSchema)).optional(),
}).transform((v) => {
  return remap$(v, {
    "allow_fallbacks": "allowFallbacks",
    "require_parameters": "requireParameters",
    "data_collection": "dataCollection",
    "max_price": "maxPrice",
  });
});

/** @internal */
export type Provider$Outbound = {
  allow_fallbacks?: boolean | null | undefined;
  require_parameters?: boolean | null | undefined;
  data_collection?: string | null | undefined;
  zdr?: boolean | null | undefined;
  order?: Array<string | string> | null | undefined;
  only?: Array<string | string> | null | undefined;
  ignore?: Array<string | string> | null | undefined;
  quantizations?: Array<string> | null | undefined;
  sort?: string | null | undefined;
  max_price?: MaxPrice$Outbound | undefined;
  experimental?: Experimental$Outbound | null | undefined;
};

/** @internal */
export const Provider$outboundSchema: z.ZodType<
  Provider$Outbound,
  z.ZodTypeDef,
  Provider
> = z.object({
  allowFallbacks: z.nullable(z.boolean()).optional(),
  requireParameters: z.nullable(z.boolean()).optional(),
  dataCollection: z.nullable(DataCollection$outboundSchema).optional(),
  zdr: z.nullable(z.boolean()).optional(),
  order: z.nullable(z.array(z.union([ProviderName$outboundSchema, z.string()])))
    .optional(),
  only: z.nullable(z.array(z.union([ProviderName$outboundSchema, z.string()])))
    .optional(),
  ignore: z.nullable(
    z.array(z.union([ProviderName$outboundSchema, z.string()])),
  ).optional(),
  quantizations: z.nullable(z.array(Quantization$outboundSchema)).optional(),
  sort: z.nullable(ProviderSort$outboundSchema).optional(),
  maxPrice: z.lazy(() => MaxPrice$outboundSchema).optional(),
  experimental: z.nullable(z.lazy(() => Experimental$outboundSchema))
    .optional(),
}).transform((v) => {
  return remap$(v, {
    allowFallbacks: "allow_fallbacks",
    requireParameters: "require_parameters",
    dataCollection: "data_collection",
    maxPrice: "max_price",
  });
});

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace Provider$ {
  /** @deprecated use `Provider$inboundSchema` instead. */
  export const inboundSchema = Provider$inboundSchema;
  /** @deprecated use `Provider$outboundSchema` instead. */
  export const outboundSchema = Provider$outboundSchema;
  /** @deprecated use `Provider$Outbound` instead. */
  export type Outbound = Provider$Outbound;
}

export function providerToJSON(provider: Provider): string {
  return JSON.stringify(Provider$outboundSchema.parse(provider));
}

export function providerFromJSON(
  jsonString: string,
): SafeParseResult<Provider, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => Provider$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'Provider' from JSON`,
  );
}

/** @internal */
export const IdFileParser$inboundSchema: z.ZodNativeEnum<typeof IdFileParser> =
  z.nativeEnum(IdFileParser);

/** @internal */
export const IdFileParser$outboundSchema: z.ZodNativeEnum<typeof IdFileParser> =
  IdFileParser$inboundSchema;

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace IdFileParser$ {
  /** @deprecated use `IdFileParser$inboundSchema` instead. */
  export const inboundSchema = IdFileParser$inboundSchema;
  /** @deprecated use `IdFileParser$outboundSchema` instead. */
  export const outboundSchema = IdFileParser$outboundSchema;
}

/** @internal */
export const PdfEngine$inboundSchema: z.ZodType<
  PdfEngine,
  z.ZodTypeDef,
  unknown
> = z
  .union([
    z.nativeEnum(PdfEngine),
    z.string().transform(catchUnrecognizedEnum),
  ]);

/** @internal */
export const PdfEngine$outboundSchema: z.ZodType<
  PdfEngine,
  z.ZodTypeDef,
  PdfEngine
> = z.union([
  z.nativeEnum(PdfEngine),
  z.string().and(z.custom<Unrecognized<string>>()),
]);

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace PdfEngine$ {
  /** @deprecated use `PdfEngine$inboundSchema` instead. */
  export const inboundSchema = PdfEngine$inboundSchema;
  /** @deprecated use `PdfEngine$outboundSchema` instead. */
  export const outboundSchema = PdfEngine$outboundSchema;
}

/** @internal */
export const Pdf$inboundSchema: z.ZodType<Pdf, z.ZodTypeDef, unknown> = z
  .object({
    engine: PdfEngine$inboundSchema.optional(),
  });

/** @internal */
export type Pdf$Outbound = {
  engine?: string | undefined;
};

/** @internal */
export const Pdf$outboundSchema: z.ZodType<Pdf$Outbound, z.ZodTypeDef, Pdf> = z
  .object({
    engine: PdfEngine$outboundSchema.optional(),
  });

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace Pdf$ {
  /** @deprecated use `Pdf$inboundSchema` instead. */
  export const inboundSchema = Pdf$inboundSchema;
  /** @deprecated use `Pdf$outboundSchema` instead. */
  export const outboundSchema = Pdf$outboundSchema;
  /** @deprecated use `Pdf$Outbound` instead. */
  export type Outbound = Pdf$Outbound;
}

export function pdfToJSON(pdf: Pdf): string {
  return JSON.stringify(Pdf$outboundSchema.parse(pdf));
}

export function pdfFromJSON(
  jsonString: string,
): SafeParseResult<Pdf, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => Pdf$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'Pdf' from JSON`,
  );
}

/** @internal */
export const PluginFileParser$inboundSchema: z.ZodType<
  PluginFileParser,
  z.ZodTypeDef,
  unknown
> = z.object({
  id: IdFileParser$inboundSchema,
  max_files: z.number().optional(),
  pdf: z.lazy(() => Pdf$inboundSchema).optional(),
}).transform((v) => {
  return remap$(v, {
    "max_files": "maxFiles",
  });
});

/** @internal */
export type PluginFileParser$Outbound = {
  id: string;
  max_files?: number | undefined;
  pdf?: Pdf$Outbound | undefined;
};

/** @internal */
export const PluginFileParser$outboundSchema: z.ZodType<
  PluginFileParser$Outbound,
  z.ZodTypeDef,
  PluginFileParser
> = z.object({
  id: IdFileParser$outboundSchema,
  maxFiles: z.number().optional(),
  pdf: z.lazy(() => Pdf$outboundSchema).optional(),
}).transform((v) => {
  return remap$(v, {
    maxFiles: "max_files",
  });
});

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace PluginFileParser$ {
  /** @deprecated use `PluginFileParser$inboundSchema` instead. */
  export const inboundSchema = PluginFileParser$inboundSchema;
  /** @deprecated use `PluginFileParser$outboundSchema` instead. */
  export const outboundSchema = PluginFileParser$outboundSchema;
  /** @deprecated use `PluginFileParser$Outbound` instead. */
  export type Outbound = PluginFileParser$Outbound;
}

export function pluginFileParserToJSON(
  pluginFileParser: PluginFileParser,
): string {
  return JSON.stringify(
    PluginFileParser$outboundSchema.parse(pluginFileParser),
  );
}

export function pluginFileParserFromJSON(
  jsonString: string,
): SafeParseResult<PluginFileParser, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => PluginFileParser$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'PluginFileParser' from JSON`,
  );
}

/** @internal */
export const IdWeb$inboundSchema: z.ZodNativeEnum<typeof IdWeb> = z.nativeEnum(
  IdWeb,
);

/** @internal */
export const IdWeb$outboundSchema: z.ZodNativeEnum<typeof IdWeb> =
  IdWeb$inboundSchema;

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace IdWeb$ {
  /** @deprecated use `IdWeb$inboundSchema` instead. */
  export const inboundSchema = IdWeb$inboundSchema;
  /** @deprecated use `IdWeb$outboundSchema` instead. */
  export const outboundSchema = IdWeb$outboundSchema;
}

/** @internal */
export const Engine$inboundSchema: z.ZodType<Engine, z.ZodTypeDef, unknown> = z
  .union([
    z.nativeEnum(Engine),
    z.string().transform(catchUnrecognizedEnum),
  ]);

/** @internal */
export const Engine$outboundSchema: z.ZodType<Engine, z.ZodTypeDef, Engine> = z
  .union([
    z.nativeEnum(Engine),
    z.string().and(z.custom<Unrecognized<string>>()),
  ]);

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace Engine$ {
  /** @deprecated use `Engine$inboundSchema` instead. */
  export const inboundSchema = Engine$inboundSchema;
  /** @deprecated use `Engine$outboundSchema` instead. */
  export const outboundSchema = Engine$outboundSchema;
}

/** @internal */
export const PluginWeb$inboundSchema: z.ZodType<
  PluginWeb,
  z.ZodTypeDef,
  unknown
> = z.object({
  id: IdWeb$inboundSchema,
  max_results: z.number().optional(),
  search_prompt: z.string().optional(),
  engine: Engine$inboundSchema.optional(),
}).transform((v) => {
  return remap$(v, {
    "max_results": "maxResults",
    "search_prompt": "searchPrompt",
  });
});

/** @internal */
export type PluginWeb$Outbound = {
  id: string;
  max_results?: number | undefined;
  search_prompt?: string | undefined;
  engine?: string | undefined;
};

/** @internal */
export const PluginWeb$outboundSchema: z.ZodType<
  PluginWeb$Outbound,
  z.ZodTypeDef,
  PluginWeb
> = z.object({
  id: IdWeb$outboundSchema,
  maxResults: z.number().optional(),
  searchPrompt: z.string().optional(),
  engine: Engine$outboundSchema.optional(),
}).transform((v) => {
  return remap$(v, {
    maxResults: "max_results",
    searchPrompt: "search_prompt",
  });
});

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace PluginWeb$ {
  /** @deprecated use `PluginWeb$inboundSchema` instead. */
  export const inboundSchema = PluginWeb$inboundSchema;
  /** @deprecated use `PluginWeb$outboundSchema` instead. */
  export const outboundSchema = PluginWeb$outboundSchema;
  /** @deprecated use `PluginWeb$Outbound` instead. */
  export type Outbound = PluginWeb$Outbound;
}

export function pluginWebToJSON(pluginWeb: PluginWeb): string {
  return JSON.stringify(PluginWeb$outboundSchema.parse(pluginWeb));
}

export function pluginWebFromJSON(
  jsonString: string,
): SafeParseResult<PluginWeb, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => PluginWeb$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'PluginWeb' from JSON`,
  );
}

/** @internal */
export const IdModeration$inboundSchema: z.ZodNativeEnum<typeof IdModeration> =
  z.nativeEnum(IdModeration);

/** @internal */
export const IdModeration$outboundSchema: z.ZodNativeEnum<typeof IdModeration> =
  IdModeration$inboundSchema;

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace IdModeration$ {
  /** @deprecated use `IdModeration$inboundSchema` instead. */
  export const inboundSchema = IdModeration$inboundSchema;
  /** @deprecated use `IdModeration$outboundSchema` instead. */
  export const outboundSchema = IdModeration$outboundSchema;
}

/** @internal */
export const PluginModeration$inboundSchema: z.ZodType<
  PluginModeration,
  z.ZodTypeDef,
  unknown
> = z.object({
  id: IdModeration$inboundSchema,
});

/** @internal */
export type PluginModeration$Outbound = {
  id: string;
};

/** @internal */
export const PluginModeration$outboundSchema: z.ZodType<
  PluginModeration$Outbound,
  z.ZodTypeDef,
  PluginModeration
> = z.object({
  id: IdModeration$outboundSchema,
});

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace PluginModeration$ {
  /** @deprecated use `PluginModeration$inboundSchema` instead. */
  export const inboundSchema = PluginModeration$inboundSchema;
  /** @deprecated use `PluginModeration$outboundSchema` instead. */
  export const outboundSchema = PluginModeration$outboundSchema;
  /** @deprecated use `PluginModeration$Outbound` instead. */
  export type Outbound = PluginModeration$Outbound;
}

export function pluginModerationToJSON(
  pluginModeration: PluginModeration,
): string {
  return JSON.stringify(
    PluginModeration$outboundSchema.parse(pluginModeration),
  );
}

export function pluginModerationFromJSON(
  jsonString: string,
): SafeParseResult<PluginModeration, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => PluginModeration$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'PluginModeration' from JSON`,
  );
}

/** @internal */
export const Plugin$inboundSchema: z.ZodType<Plugin, z.ZodTypeDef, unknown> = z
  .union([
    z.lazy(() => PluginModeration$inboundSchema),
    z.lazy(() => PluginWeb$inboundSchema),
    z.lazy(() => PluginFileParser$inboundSchema),
  ]);

/** @internal */
export type Plugin$Outbound =
  | PluginModeration$Outbound
  | PluginWeb$Outbound
  | PluginFileParser$Outbound;

/** @internal */
export const Plugin$outboundSchema: z.ZodType<
  Plugin$Outbound,
  z.ZodTypeDef,
  Plugin
> = z.union([
  z.lazy(() => PluginModeration$outboundSchema),
  z.lazy(() => PluginWeb$outboundSchema),
  z.lazy(() => PluginFileParser$outboundSchema),
]);

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace Plugin$ {
  /** @deprecated use `Plugin$inboundSchema` instead. */
  export const inboundSchema = Plugin$inboundSchema;
  /** @deprecated use `Plugin$outboundSchema` instead. */
  export const outboundSchema = Plugin$outboundSchema;
  /** @deprecated use `Plugin$Outbound` instead. */
  export type Outbound = Plugin$Outbound;
}

export function pluginToJSON(plugin: Plugin): string {
  return JSON.stringify(Plugin$outboundSchema.parse(plugin));
}

export function pluginFromJSON(
  jsonString: string,
): SafeParseResult<Plugin, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => Plugin$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'Plugin' from JSON`,
  );
}

/** @internal */
export const OpenResponsesRequest$inboundSchema: z.ZodType<
  OpenResponsesRequest,
  z.ZodTypeDef,
  unknown
> = z.object({
  input: OpenResponsesInputUnion$inboundSchema.optional(),
  instructions: z.nullable(z.string()).optional(),
  metadata: z.nullable(z.record(z.string())).optional(),
  tools: z.array(
    z.union([
      z.lazy(() => OpenResponsesRequestToolFunction$inboundSchema),
      OpenResponsesWebSearchPreviewTool$inboundSchema,
      OpenResponsesWebSearchPreview20250311Tool$inboundSchema,
      OpenResponsesWebSearchTool$inboundSchema,
      OpenResponsesWebSearch20250826Tool$inboundSchema,
    ]),
  ).optional(),
  tool_choice: z.union([
    z.lazy(() => OpenResponsesRequestToolChoiceFunction$inboundSchema),
    z.lazy(() => OpenResponsesRequestToolChoice$inboundSchema),
    OpenResponsesRequestToolChoiceAuto$inboundSchema,
    OpenResponsesRequestToolChoiceNone$inboundSchema,
    OpenResponsesRequestToolChoiceRequired$inboundSchema,
  ]).optional(),
  parallel_tool_calls: z.nullable(z.boolean()).optional(),
  model: z.string().optional(),
  models: z.array(z.string()).optional(),
  text: OpenResponsesResponseText$inboundSchema.optional(),
  reasoning: z.nullable(OpenResponsesReasoningConfig$inboundSchema).optional(),
  max_output_tokens: z.nullable(z.number()).optional(),
  temperature: z.nullable(z.number()).optional(),
  top_p: z.nullable(z.number()).optional(),
  top_k: z.number().optional(),
  prompt_cache_key: z.nullable(z.string()).optional(),
  previous_response_id: z.nullable(z.string()).optional(),
  prompt: z.nullable(OpenAIResponsesPrompt$inboundSchema).optional(),
  include: z.nullable(z.array(OpenAIResponsesIncludable$inboundSchema))
    .optional(),
  background: z.nullable(z.boolean()).optional(),
  safety_identifier: z.nullable(z.string()).optional(),
  store: z.nullable(z.boolean()).optional(),
  service_tier: z.nullable(ServiceTier$inboundSchema).optional(),
  truncation: z.nullable(Truncation$inboundSchema).optional(),
  stream: z.nullable(z.boolean()).optional(),
  provider: z.nullable(z.lazy(() => Provider$inboundSchema)).optional(),
  plugins: z.array(
    z.union([
      z.lazy(() => PluginModeration$inboundSchema),
      z.lazy(() => PluginWeb$inboundSchema),
      z.lazy(() => PluginFileParser$inboundSchema),
    ]),
  ).optional(),
  user: z.string().optional(),
}).transform((v) => {
  return remap$(v, {
    "tool_choice": "toolChoice",
    "parallel_tool_calls": "parallelToolCalls",
    "max_output_tokens": "maxOutputTokens",
    "top_p": "topP",
    "top_k": "topK",
    "prompt_cache_key": "promptCacheKey",
    "previous_response_id": "previousResponseId",
    "safety_identifier": "safetyIdentifier",
    "service_tier": "serviceTier",
  });
});

/** @internal */
export type OpenResponsesRequest$Outbound = {
  input?: OpenResponsesInputUnion$Outbound | undefined;
  instructions?: string | null | undefined;
  metadata?: { [k: string]: string } | null | undefined;
  tools?:
    | Array<
      | OpenResponsesRequestToolFunction$Outbound
      | OpenResponsesWebSearchPreviewTool$Outbound
      | OpenResponsesWebSearchPreview20250311Tool$Outbound
      | OpenResponsesWebSearchTool$Outbound
      | OpenResponsesWebSearch20250826Tool$Outbound
    >
    | undefined;
  tool_choice?:
    | OpenResponsesRequestToolChoiceFunction$Outbound
    | OpenResponsesRequestToolChoice$Outbound
    | string
    | string
    | string
    | undefined;
  parallel_tool_calls?: boolean | null | undefined;
  model?: string | undefined;
  models?: Array<string> | undefined;
  text?: OpenResponsesResponseText$Outbound | undefined;
  reasoning?: OpenResponsesReasoningConfig$Outbound | null | undefined;
  max_output_tokens?: number | null | undefined;
  temperature?: number | null | undefined;
  top_p?: number | null | undefined;
  top_k?: number | undefined;
  prompt_cache_key?: string | null | undefined;
  previous_response_id?: string | null | undefined;
  prompt?: OpenAIResponsesPrompt$Outbound | null | undefined;
  include?: Array<string> | null | undefined;
  background?: boolean | null | undefined;
  safety_identifier?: string | null | undefined;
  store?: boolean | null | undefined;
  service_tier?: string | null | undefined;
  truncation?: string | null | undefined;
  stream?: boolean | null | undefined;
  provider?: Provider$Outbound | null | undefined;
  plugins?:
    | Array<
      PluginModeration$Outbound | PluginWeb$Outbound | PluginFileParser$Outbound
    >
    | undefined;
  user?: string | undefined;
};

/** @internal */
export const OpenResponsesRequest$outboundSchema: z.ZodType<
  OpenResponsesRequest$Outbound,
  z.ZodTypeDef,
  OpenResponsesRequest
> = z.object({
  input: OpenResponsesInputUnion$outboundSchema.optional(),
  instructions: z.nullable(z.string()).optional(),
  metadata: z.nullable(z.record(z.string())).optional(),
  tools: z.array(
    z.union([
      z.lazy(() => OpenResponsesRequestToolFunction$outboundSchema),
      OpenResponsesWebSearchPreviewTool$outboundSchema,
      OpenResponsesWebSearchPreview20250311Tool$outboundSchema,
      OpenResponsesWebSearchTool$outboundSchema,
      OpenResponsesWebSearch20250826Tool$outboundSchema,
    ]),
  ).optional(),
  toolChoice: z.union([
    z.lazy(() => OpenResponsesRequestToolChoiceFunction$outboundSchema),
    z.lazy(() => OpenResponsesRequestToolChoice$outboundSchema),
    OpenResponsesRequestToolChoiceAuto$outboundSchema,
    OpenResponsesRequestToolChoiceNone$outboundSchema,
    OpenResponsesRequestToolChoiceRequired$outboundSchema,
  ]).optional(),
  parallelToolCalls: z.nullable(z.boolean()).optional(),
  model: z.string().optional(),
  models: z.array(z.string()).optional(),
  text: OpenResponsesResponseText$outboundSchema.optional(),
  reasoning: z.nullable(OpenResponsesReasoningConfig$outboundSchema).optional(),
  maxOutputTokens: z.nullable(z.number()).optional(),
  temperature: z.nullable(z.number()).optional(),
  topP: z.nullable(z.number()).optional(),
  topK: z.number().optional(),
  promptCacheKey: z.nullable(z.string()).optional(),
  previousResponseId: z.nullable(z.string()).optional(),
  prompt: z.nullable(OpenAIResponsesPrompt$outboundSchema).optional(),
  include: z.nullable(z.array(OpenAIResponsesIncludable$outboundSchema))
    .optional(),
  background: z.nullable(z.boolean()).optional(),
  safetyIdentifier: z.nullable(z.string()).optional(),
  store: z.nullable(z.boolean()).optional(),
  serviceTier: z.nullable(ServiceTier$outboundSchema).optional(),
  truncation: z.nullable(Truncation$outboundSchema).optional(),
  stream: z.nullable(z.boolean()).optional(),
  provider: z.nullable(z.lazy(() => Provider$outboundSchema)).optional(),
  plugins: z.array(
    z.union([
      z.lazy(() => PluginModeration$outboundSchema),
      z.lazy(() => PluginWeb$outboundSchema),
      z.lazy(() => PluginFileParser$outboundSchema),
    ]),
  ).optional(),
  user: z.string().optional(),
}).transform((v) => {
  return remap$(v, {
    toolChoice: "tool_choice",
    parallelToolCalls: "parallel_tool_calls",
    maxOutputTokens: "max_output_tokens",
    topP: "top_p",
    topK: "top_k",
    promptCacheKey: "prompt_cache_key",
    previousResponseId: "previous_response_id",
    safetyIdentifier: "safety_identifier",
    serviceTier: "service_tier",
  });
});

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace OpenResponsesRequest$ {
  /** @deprecated use `OpenResponsesRequest$inboundSchema` instead. */
  export const inboundSchema = OpenResponsesRequest$inboundSchema;
  /** @deprecated use `OpenResponsesRequest$outboundSchema` instead. */
  export const outboundSchema = OpenResponsesRequest$outboundSchema;
  /** @deprecated use `OpenResponsesRequest$Outbound` instead. */
  export type Outbound = OpenResponsesRequest$Outbound;
}

export function openResponsesRequestToJSON(
  openResponsesRequest: OpenResponsesRequest,
): string {
  return JSON.stringify(
    OpenResponsesRequest$outboundSchema.parse(openResponsesRequest),
  );
}

export function openResponsesRequestFromJSON(
  jsonString: string,
): SafeParseResult<OpenResponsesRequest, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => OpenResponsesRequest$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'OpenResponsesRequest' from JSON`,
  );
}
