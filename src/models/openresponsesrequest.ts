/*
 * Code generated by Speakeasy (https://speakeasy.com). DO NOT EDIT.
 * @generated-id: ff8a31d46b1c
 */

import * as z from "zod/v4";
import { remap as remap$ } from "../lib/primitives.js";
import * as openEnums from "../types/enums.js";
import { ClosedEnum, OpenEnum } from "../types/enums.js";
import {
  DataCollection,
  DataCollection$outboundSchema,
} from "./datacollection.js";
import {
  OpenAIResponsesIncludable,
  OpenAIResponsesIncludable$outboundSchema,
} from "./openairesponsesincludable.js";
import {
  OpenAIResponsesPrompt,
  OpenAIResponsesPrompt$Outbound,
  OpenAIResponsesPrompt$outboundSchema,
} from "./openairesponsesprompt.js";
import {
  OpenAIResponsesToolChoiceUnion,
  OpenAIResponsesToolChoiceUnion$Outbound,
  OpenAIResponsesToolChoiceUnion$outboundSchema,
} from "./openairesponsestoolchoiceunion.js";
import {
  OpenResponsesInput,
  OpenResponsesInput$Outbound,
  OpenResponsesInput$outboundSchema,
} from "./openresponsesinput.js";
import {
  OpenResponsesReasoningConfig,
  OpenResponsesReasoningConfig$Outbound,
  OpenResponsesReasoningConfig$outboundSchema,
} from "./openresponsesreasoningconfig.js";
import {
  OpenResponsesResponseText,
  OpenResponsesResponseText$Outbound,
  OpenResponsesResponseText$outboundSchema,
} from "./openresponsesresponsetext.js";
import {
  OpenResponsesWebSearch20250826Tool,
  OpenResponsesWebSearch20250826Tool$Outbound,
  OpenResponsesWebSearch20250826Tool$outboundSchema,
} from "./openresponseswebsearch20250826tool.js";
import {
  OpenResponsesWebSearchPreview20250311Tool,
  OpenResponsesWebSearchPreview20250311Tool$Outbound,
  OpenResponsesWebSearchPreview20250311Tool$outboundSchema,
} from "./openresponseswebsearchpreview20250311tool.js";
import {
  OpenResponsesWebSearchPreviewTool,
  OpenResponsesWebSearchPreviewTool$Outbound,
  OpenResponsesWebSearchPreviewTool$outboundSchema,
} from "./openresponseswebsearchpreviewtool.js";
import {
  OpenResponsesWebSearchTool,
  OpenResponsesWebSearchTool$Outbound,
  OpenResponsesWebSearchTool$outboundSchema,
} from "./openresponseswebsearchtool.js";
import {
  PDFParserOptions,
  PDFParserOptions$Outbound,
  PDFParserOptions$outboundSchema,
} from "./pdfparseroptions.js";
import { ProviderName, ProviderName$outboundSchema } from "./providername.js";
import { ProviderSort, ProviderSort$outboundSchema } from "./providersort.js";
import {
  ProviderSortConfig,
  ProviderSortConfig$Outbound,
  ProviderSortConfig$outboundSchema,
} from "./providersortconfig.js";
import { Quantization, Quantization$outboundSchema } from "./quantization.js";
import {
  WebSearchEngine,
  WebSearchEngine$outboundSchema,
} from "./websearchengine.js";

/**
 * Function tool definition
 */
export type OpenResponsesRequestToolFunction = {
  type: "function";
  name: string;
  description?: string | null | undefined;
  strict?: boolean | null | undefined;
  parameters: { [k: string]: any | null } | null;
};

export type OpenResponsesRequestToolUnion =
  | OpenResponsesRequestToolFunction
  | OpenResponsesWebSearchPreviewTool
  | OpenResponsesWebSearchPreview20250311Tool
  | OpenResponsesWebSearchTool
  | OpenResponsesWebSearch20250826Tool;

export const ServiceTier = {
  Auto: "auto",
} as const;
export type ServiceTier = ClosedEnum<typeof ServiceTier>;

export const Truncation = {
  Auto: "auto",
  Disabled: "disabled",
} as const;
export type Truncation = OpenEnum<typeof Truncation>;

export type OpenResponsesRequestOrder = ProviderName | string;

export type OpenResponsesRequestOnly = ProviderName | string;

export type OpenResponsesRequestIgnore = ProviderName | string;

/**
 * The sorting strategy to use for this request, if "order" is not specified. When set, no load balancing is performed.
 */
export type OpenResponsesRequestSort = ProviderSort | ProviderSortConfig | any;

/**
 * The object specifying the maximum price you want to pay for this request. USD price per million tokens, for prompt and completion.
 */
export type OpenResponsesRequestMaxPrice = {
  /**
   * A value in string format that is a large number
   */
  prompt?: string | undefined;
  /**
   * A value in string format that is a large number
   */
  completion?: string | undefined;
  /**
   * A value in string format that is a large number
   */
  image?: string | undefined;
  /**
   * A value in string format that is a large number
   */
  audio?: string | undefined;
  /**
   * A value in string format that is a large number
   */
  request?: string | undefined;
};

/**
 * When multiple model providers are available, optionally indicate your routing preference.
 */
export type OpenResponsesRequestProvider = {
  /**
   * Whether to allow backup providers to serve requests
   *
   * @remarks
   * - true: (default) when the primary provider (or your custom providers in "order") is unavailable, use the next best provider.
   * - false: use only the primary/custom provider, and return the upstream error if it's unavailable.
   */
  allowFallbacks?: boolean | null | undefined;
  /**
   * Whether to filter providers to only those that support the parameters you've provided. If this setting is omitted or set to false, then providers will receive only the parameters they support, and ignore the rest.
   */
  requireParameters?: boolean | null | undefined;
  /**
   * Data collection setting. If no available model provider meets the requirement, your request will return an error.
   *
   * @remarks
   * - allow: (default) allow providers which store user data non-transiently and may train on it
   *
   * - deny: use only providers which do not collect user data.
   */
  dataCollection?: DataCollection | null | undefined;
  /**
   * Whether to restrict routing to only ZDR (Zero Data Retention) endpoints. When true, only endpoints that do not retain prompts will be used.
   */
  zdr?: boolean | null | undefined;
  /**
   * Whether to restrict routing to only models that allow text distillation. When true, only models where the author has allowed distillation will be used.
   */
  enforceDistillableText?: boolean | null | undefined;
  /**
   * An ordered list of provider slugs. The router will attempt to use the first provider in the subset of this list that supports your requested model, and fall back to the next if it is unavailable. If no providers are available, the request will fail with an error message.
   */
  order?: Array<ProviderName | string> | null | undefined;
  /**
   * List of provider slugs to allow. If provided, this list is merged with your account-wide allowed provider settings for this request.
   */
  only?: Array<ProviderName | string> | null | undefined;
  /**
   * List of provider slugs to ignore. If provided, this list is merged with your account-wide ignored provider settings for this request.
   */
  ignore?: Array<ProviderName | string> | null | undefined;
  /**
   * A list of quantization levels to filter the provider by.
   */
  quantizations?: Array<Quantization> | null | undefined;
  /**
   * The sorting strategy to use for this request, if "order" is not specified. When set, no load balancing is performed.
   */
  sort?: ProviderSort | ProviderSortConfig | any | null | undefined;
  /**
   * The object specifying the maximum price you want to pay for this request. USD price per million tokens, for prompt and completion.
   */
  maxPrice?: OpenResponsesRequestMaxPrice | undefined;
  /**
   * Preferred minimum throughput (in tokens per second). Endpoints below this threshold may still be used, but are deprioritized in routing. When using fallback models, this may cause a fallback model to be used instead of the primary model if it meets the threshold.
   */
  preferredMinThroughput?: number | null | undefined;
  /**
   * Preferred maximum latency (in seconds). Endpoints above this threshold may still be used, but are deprioritized in routing. When using fallback models, this may cause a fallback model to be used instead of the primary model if it meets the threshold.
   */
  preferredMaxLatency?: number | null | undefined;
  /**
   * **DEPRECATED** Use preferred_min_throughput instead. Backwards-compatible alias for preferred_min_throughput.
   *
   * @deprecated field: Use preferred_min_throughput instead..
   */
  minThroughput?: number | null | undefined;
  /**
   * **DEPRECATED** Use preferred_max_latency instead. Backwards-compatible alias for preferred_max_latency.
   *
   * @deprecated field: Use preferred_max_latency instead..
   */
  maxLatency?: number | null | undefined;
};

export type OpenResponsesRequestPluginResponseHealing = {
  id: "response-healing";
  /**
   * Set to false to disable the response-healing plugin for this request. Defaults to true.
   */
  enabled?: boolean | undefined;
};

export type OpenResponsesRequestPluginFileParser = {
  id: "file-parser";
  /**
   * Set to false to disable the file-parser plugin for this request. Defaults to true.
   */
  enabled?: boolean | undefined;
  /**
   * Options for PDF parsing.
   */
  pdf?: PDFParserOptions | undefined;
};

export type OpenResponsesRequestPluginWeb = {
  id: "web";
  /**
   * Set to false to disable the web-search plugin for this request. Defaults to true.
   */
  enabled?: boolean | undefined;
  maxResults?: number | undefined;
  searchPrompt?: string | undefined;
  /**
   * The search engine to use for web search.
   */
  engine?: WebSearchEngine | undefined;
};

export type OpenResponsesRequestPluginModeration = {
  id: "moderation";
};

export type OpenResponsesRequestPluginUnion =
  | OpenResponsesRequestPluginModeration
  | OpenResponsesRequestPluginWeb
  | OpenResponsesRequestPluginFileParser
  | OpenResponsesRequestPluginResponseHealing;

/**
 * Request schema for Responses endpoint
 */
export type OpenResponsesRequest = {
  /**
   * Input for a response request - can be a string or array of items
   */
  input?: OpenResponsesInput | undefined;
  instructions?: string | null | undefined;
  /**
   * Metadata key-value pairs for the request. Keys must be ≤64 characters and cannot contain brackets. Values must be ≤512 characters. Maximum 16 pairs allowed.
   */
  metadata?: { [k: string]: string } | null | undefined;
  tools?:
    | Array<
      | OpenResponsesRequestToolFunction
      | OpenResponsesWebSearchPreviewTool
      | OpenResponsesWebSearchPreview20250311Tool
      | OpenResponsesWebSearchTool
      | OpenResponsesWebSearch20250826Tool
    >
    | undefined;
  toolChoice?: OpenAIResponsesToolChoiceUnion | undefined;
  parallelToolCalls?: boolean | null | undefined;
  model?: string | undefined;
  models?: Array<string> | undefined;
  /**
   * Text output configuration including format and verbosity
   */
  text?: OpenResponsesResponseText | undefined;
  /**
   * Configuration for reasoning mode in the response
   */
  reasoning?: OpenResponsesReasoningConfig | null | undefined;
  maxOutputTokens?: number | null | undefined;
  temperature?: number | null | undefined;
  topP?: number | null | undefined;
  topK?: number | undefined;
  promptCacheKey?: string | null | undefined;
  previousResponseId?: string | null | undefined;
  prompt?: OpenAIResponsesPrompt | null | undefined;
  include?: Array<OpenAIResponsesIncludable> | null | undefined;
  background?: boolean | null | undefined;
  safetyIdentifier?: string | null | undefined;
  store?: false | undefined;
  serviceTier?: ServiceTier | undefined;
  truncation?: Truncation | null | undefined;
  stream?: boolean | undefined;
  /**
   * When multiple model providers are available, optionally indicate your routing preference.
   */
  provider?: OpenResponsesRequestProvider | null | undefined;
  /**
   * Plugins you want to enable for this request, including their settings.
   */
  plugins?:
    | Array<
      | OpenResponsesRequestPluginModeration
      | OpenResponsesRequestPluginWeb
      | OpenResponsesRequestPluginFileParser
      | OpenResponsesRequestPluginResponseHealing
    >
    | undefined;
  /**
   * A unique identifier representing your end-user, which helps distinguish between different users of your app. This allows your app to identify specific users in case of abuse reports, preventing your entire app from being affected by the actions of individual users. Maximum of 128 characters.
   */
  user?: string | undefined;
  /**
   * A unique identifier for grouping related requests (e.g., a conversation or agent workflow) for observability. If provided in both the request body and the x-session-id header, the body value takes precedence. Maximum of 128 characters.
   */
  sessionId?: string | undefined;
};

/** @internal */
export type OpenResponsesRequestToolFunction$Outbound = {
  type: "function";
  name: string;
  description?: string | null | undefined;
  strict?: boolean | null | undefined;
  parameters: { [k: string]: any | null } | null;
};

/** @internal */
export const OpenResponsesRequestToolFunction$outboundSchema: z.ZodType<
  OpenResponsesRequestToolFunction$Outbound,
  OpenResponsesRequestToolFunction
> = z.object({
  type: z.literal("function"),
  name: z.string(),
  description: z.nullable(z.string()).optional(),
  strict: z.nullable(z.boolean()).optional(),
  parameters: z.nullable(z.record(z.string(), z.nullable(z.any()))),
});

export function openResponsesRequestToolFunctionToJSON(
  openResponsesRequestToolFunction: OpenResponsesRequestToolFunction,
): string {
  return JSON.stringify(
    OpenResponsesRequestToolFunction$outboundSchema.parse(
      openResponsesRequestToolFunction,
    ),
  );
}

/** @internal */
export type OpenResponsesRequestToolUnion$Outbound =
  | OpenResponsesRequestToolFunction$Outbound
  | OpenResponsesWebSearchPreviewTool$Outbound
  | OpenResponsesWebSearchPreview20250311Tool$Outbound
  | OpenResponsesWebSearchTool$Outbound
  | OpenResponsesWebSearch20250826Tool$Outbound;

/** @internal */
export const OpenResponsesRequestToolUnion$outboundSchema: z.ZodType<
  OpenResponsesRequestToolUnion$Outbound,
  OpenResponsesRequestToolUnion
> = z.union([
  z.lazy(() => OpenResponsesRequestToolFunction$outboundSchema),
  OpenResponsesWebSearchPreviewTool$outboundSchema,
  OpenResponsesWebSearchPreview20250311Tool$outboundSchema,
  OpenResponsesWebSearchTool$outboundSchema,
  OpenResponsesWebSearch20250826Tool$outboundSchema,
]);

export function openResponsesRequestToolUnionToJSON(
  openResponsesRequestToolUnion: OpenResponsesRequestToolUnion,
): string {
  return JSON.stringify(
    OpenResponsesRequestToolUnion$outboundSchema.parse(
      openResponsesRequestToolUnion,
    ),
  );
}

/** @internal */
export const ServiceTier$outboundSchema: z.ZodEnum<typeof ServiceTier> = z.enum(
  ServiceTier,
);

/** @internal */
export const Truncation$outboundSchema: z.ZodType<string, Truncation> =
  openEnums.outboundSchema(Truncation);

/** @internal */
export type OpenResponsesRequestOrder$Outbound = string | string;

/** @internal */
export const OpenResponsesRequestOrder$outboundSchema: z.ZodType<
  OpenResponsesRequestOrder$Outbound,
  OpenResponsesRequestOrder
> = z.union([ProviderName$outboundSchema, z.string()]);

export function openResponsesRequestOrderToJSON(
  openResponsesRequestOrder: OpenResponsesRequestOrder,
): string {
  return JSON.stringify(
    OpenResponsesRequestOrder$outboundSchema.parse(openResponsesRequestOrder),
  );
}

/** @internal */
export type OpenResponsesRequestOnly$Outbound = string | string;

/** @internal */
export const OpenResponsesRequestOnly$outboundSchema: z.ZodType<
  OpenResponsesRequestOnly$Outbound,
  OpenResponsesRequestOnly
> = z.union([ProviderName$outboundSchema, z.string()]);

export function openResponsesRequestOnlyToJSON(
  openResponsesRequestOnly: OpenResponsesRequestOnly,
): string {
  return JSON.stringify(
    OpenResponsesRequestOnly$outboundSchema.parse(openResponsesRequestOnly),
  );
}

/** @internal */
export type OpenResponsesRequestIgnore$Outbound = string | string;

/** @internal */
export const OpenResponsesRequestIgnore$outboundSchema: z.ZodType<
  OpenResponsesRequestIgnore$Outbound,
  OpenResponsesRequestIgnore
> = z.union([ProviderName$outboundSchema, z.string()]);

export function openResponsesRequestIgnoreToJSON(
  openResponsesRequestIgnore: OpenResponsesRequestIgnore,
): string {
  return JSON.stringify(
    OpenResponsesRequestIgnore$outboundSchema.parse(openResponsesRequestIgnore),
  );
}

/** @internal */
export type OpenResponsesRequestSort$Outbound =
  | string
  | ProviderSortConfig$Outbound
  | any;

/** @internal */
export const OpenResponsesRequestSort$outboundSchema: z.ZodType<
  OpenResponsesRequestSort$Outbound,
  OpenResponsesRequestSort
> = z.union([
  ProviderSort$outboundSchema,
  ProviderSortConfig$outboundSchema,
  z.any(),
]);

export function openResponsesRequestSortToJSON(
  openResponsesRequestSort: OpenResponsesRequestSort,
): string {
  return JSON.stringify(
    OpenResponsesRequestSort$outboundSchema.parse(openResponsesRequestSort),
  );
}

/** @internal */
export type OpenResponsesRequestMaxPrice$Outbound = {
  prompt?: string | undefined;
  completion?: string | undefined;
  image?: string | undefined;
  audio?: string | undefined;
  request?: string | undefined;
};

/** @internal */
export const OpenResponsesRequestMaxPrice$outboundSchema: z.ZodType<
  OpenResponsesRequestMaxPrice$Outbound,
  OpenResponsesRequestMaxPrice
> = z.object({
  prompt: z.string().optional(),
  completion: z.string().optional(),
  image: z.string().optional(),
  audio: z.string().optional(),
  request: z.string().optional(),
});

export function openResponsesRequestMaxPriceToJSON(
  openResponsesRequestMaxPrice: OpenResponsesRequestMaxPrice,
): string {
  return JSON.stringify(
    OpenResponsesRequestMaxPrice$outboundSchema.parse(
      openResponsesRequestMaxPrice,
    ),
  );
}

/** @internal */
export type OpenResponsesRequestProvider$Outbound = {
  allow_fallbacks?: boolean | null | undefined;
  require_parameters?: boolean | null | undefined;
  data_collection?: string | null | undefined;
  zdr?: boolean | null | undefined;
  enforce_distillable_text?: boolean | null | undefined;
  order?: Array<string | string> | null | undefined;
  only?: Array<string | string> | null | undefined;
  ignore?: Array<string | string> | null | undefined;
  quantizations?: Array<string> | null | undefined;
  sort?: string | ProviderSortConfig$Outbound | any | null | undefined;
  max_price?: OpenResponsesRequestMaxPrice$Outbound | undefined;
  preferred_min_throughput?: number | null | undefined;
  preferred_max_latency?: number | null | undefined;
  min_throughput?: number | null | undefined;
  max_latency?: number | null | undefined;
};

/** @internal */
export const OpenResponsesRequestProvider$outboundSchema: z.ZodType<
  OpenResponsesRequestProvider$Outbound,
  OpenResponsesRequestProvider
> = z.object({
  allowFallbacks: z.nullable(z.boolean()).optional(),
  requireParameters: z.nullable(z.boolean()).optional(),
  dataCollection: z.nullable(DataCollection$outboundSchema).optional(),
  zdr: z.nullable(z.boolean()).optional(),
  enforceDistillableText: z.nullable(z.boolean()).optional(),
  order: z.nullable(z.array(z.union([ProviderName$outboundSchema, z.string()])))
    .optional(),
  only: z.nullable(z.array(z.union([ProviderName$outboundSchema, z.string()])))
    .optional(),
  ignore: z.nullable(
    z.array(z.union([ProviderName$outboundSchema, z.string()])),
  ).optional(),
  quantizations: z.nullable(z.array(Quantization$outboundSchema)).optional(),
  sort: z.nullable(
    z.union([
      ProviderSort$outboundSchema,
      ProviderSortConfig$outboundSchema,
      z.any(),
    ]),
  ).optional(),
  maxPrice: z.lazy(() => OpenResponsesRequestMaxPrice$outboundSchema)
    .optional(),
  preferredMinThroughput: z.nullable(z.number()).optional(),
  preferredMaxLatency: z.nullable(z.number()).optional(),
  minThroughput: z.nullable(z.number()).optional(),
  maxLatency: z.nullable(z.number()).optional(),
}).transform((v) => {
  return remap$(v, {
    allowFallbacks: "allow_fallbacks",
    requireParameters: "require_parameters",
    dataCollection: "data_collection",
    enforceDistillableText: "enforce_distillable_text",
    maxPrice: "max_price",
    preferredMinThroughput: "preferred_min_throughput",
    preferredMaxLatency: "preferred_max_latency",
    minThroughput: "min_throughput",
    maxLatency: "max_latency",
  });
});

export function openResponsesRequestProviderToJSON(
  openResponsesRequestProvider: OpenResponsesRequestProvider,
): string {
  return JSON.stringify(
    OpenResponsesRequestProvider$outboundSchema.parse(
      openResponsesRequestProvider,
    ),
  );
}

/** @internal */
export type OpenResponsesRequestPluginResponseHealing$Outbound = {
  id: "response-healing";
  enabled?: boolean | undefined;
};

/** @internal */
export const OpenResponsesRequestPluginResponseHealing$outboundSchema:
  z.ZodType<
    OpenResponsesRequestPluginResponseHealing$Outbound,
    OpenResponsesRequestPluginResponseHealing
  > = z.object({
    id: z.literal("response-healing"),
    enabled: z.boolean().optional(),
  });

export function openResponsesRequestPluginResponseHealingToJSON(
  openResponsesRequestPluginResponseHealing:
    OpenResponsesRequestPluginResponseHealing,
): string {
  return JSON.stringify(
    OpenResponsesRequestPluginResponseHealing$outboundSchema.parse(
      openResponsesRequestPluginResponseHealing,
    ),
  );
}

/** @internal */
export type OpenResponsesRequestPluginFileParser$Outbound = {
  id: "file-parser";
  enabled?: boolean | undefined;
  pdf?: PDFParserOptions$Outbound | undefined;
};

/** @internal */
export const OpenResponsesRequestPluginFileParser$outboundSchema: z.ZodType<
  OpenResponsesRequestPluginFileParser$Outbound,
  OpenResponsesRequestPluginFileParser
> = z.object({
  id: z.literal("file-parser"),
  enabled: z.boolean().optional(),
  pdf: PDFParserOptions$outboundSchema.optional(),
});

export function openResponsesRequestPluginFileParserToJSON(
  openResponsesRequestPluginFileParser: OpenResponsesRequestPluginFileParser,
): string {
  return JSON.stringify(
    OpenResponsesRequestPluginFileParser$outboundSchema.parse(
      openResponsesRequestPluginFileParser,
    ),
  );
}

/** @internal */
export type OpenResponsesRequestPluginWeb$Outbound = {
  id: "web";
  enabled?: boolean | undefined;
  max_results?: number | undefined;
  search_prompt?: string | undefined;
  engine?: string | undefined;
};

/** @internal */
export const OpenResponsesRequestPluginWeb$outboundSchema: z.ZodType<
  OpenResponsesRequestPluginWeb$Outbound,
  OpenResponsesRequestPluginWeb
> = z.object({
  id: z.literal("web"),
  enabled: z.boolean().optional(),
  maxResults: z.number().optional(),
  searchPrompt: z.string().optional(),
  engine: WebSearchEngine$outboundSchema.optional(),
}).transform((v) => {
  return remap$(v, {
    maxResults: "max_results",
    searchPrompt: "search_prompt",
  });
});

export function openResponsesRequestPluginWebToJSON(
  openResponsesRequestPluginWeb: OpenResponsesRequestPluginWeb,
): string {
  return JSON.stringify(
    OpenResponsesRequestPluginWeb$outboundSchema.parse(
      openResponsesRequestPluginWeb,
    ),
  );
}

/** @internal */
export type OpenResponsesRequestPluginModeration$Outbound = {
  id: "moderation";
};

/** @internal */
export const OpenResponsesRequestPluginModeration$outboundSchema: z.ZodType<
  OpenResponsesRequestPluginModeration$Outbound,
  OpenResponsesRequestPluginModeration
> = z.object({
  id: z.literal("moderation"),
});

export function openResponsesRequestPluginModerationToJSON(
  openResponsesRequestPluginModeration: OpenResponsesRequestPluginModeration,
): string {
  return JSON.stringify(
    OpenResponsesRequestPluginModeration$outboundSchema.parse(
      openResponsesRequestPluginModeration,
    ),
  );
}

/** @internal */
export type OpenResponsesRequestPluginUnion$Outbound =
  | OpenResponsesRequestPluginModeration$Outbound
  | OpenResponsesRequestPluginWeb$Outbound
  | OpenResponsesRequestPluginFileParser$Outbound
  | OpenResponsesRequestPluginResponseHealing$Outbound;

/** @internal */
export const OpenResponsesRequestPluginUnion$outboundSchema: z.ZodType<
  OpenResponsesRequestPluginUnion$Outbound,
  OpenResponsesRequestPluginUnion
> = z.union([
  z.lazy(() => OpenResponsesRequestPluginModeration$outboundSchema),
  z.lazy(() => OpenResponsesRequestPluginWeb$outboundSchema),
  z.lazy(() => OpenResponsesRequestPluginFileParser$outboundSchema),
  z.lazy(() => OpenResponsesRequestPluginResponseHealing$outboundSchema),
]);

export function openResponsesRequestPluginUnionToJSON(
  openResponsesRequestPluginUnion: OpenResponsesRequestPluginUnion,
): string {
  return JSON.stringify(
    OpenResponsesRequestPluginUnion$outboundSchema.parse(
      openResponsesRequestPluginUnion,
    ),
  );
}

/** @internal */
export type OpenResponsesRequest$Outbound = {
  input?: OpenResponsesInput$Outbound | undefined;
  instructions?: string | null | undefined;
  metadata?: { [k: string]: string } | null | undefined;
  tools?:
    | Array<
      | OpenResponsesRequestToolFunction$Outbound
      | OpenResponsesWebSearchPreviewTool$Outbound
      | OpenResponsesWebSearchPreview20250311Tool$Outbound
      | OpenResponsesWebSearchTool$Outbound
      | OpenResponsesWebSearch20250826Tool$Outbound
    >
    | undefined;
  tool_choice?: OpenAIResponsesToolChoiceUnion$Outbound | undefined;
  parallel_tool_calls?: boolean | null | undefined;
  model?: string | undefined;
  models?: Array<string> | undefined;
  text?: OpenResponsesResponseText$Outbound | undefined;
  reasoning?: OpenResponsesReasoningConfig$Outbound | null | undefined;
  max_output_tokens?: number | null | undefined;
  temperature?: number | null | undefined;
  top_p?: number | null | undefined;
  top_k?: number | undefined;
  prompt_cache_key?: string | null | undefined;
  previous_response_id?: string | null | undefined;
  prompt?: OpenAIResponsesPrompt$Outbound | null | undefined;
  include?: Array<string> | null | undefined;
  background?: boolean | null | undefined;
  safety_identifier?: string | null | undefined;
  store: false;
  service_tier: string;
  truncation?: string | null | undefined;
  stream: boolean;
  provider?: OpenResponsesRequestProvider$Outbound | null | undefined;
  plugins?:
    | Array<
      | OpenResponsesRequestPluginModeration$Outbound
      | OpenResponsesRequestPluginWeb$Outbound
      | OpenResponsesRequestPluginFileParser$Outbound
      | OpenResponsesRequestPluginResponseHealing$Outbound
    >
    | undefined;
  user?: string | undefined;
  session_id?: string | undefined;
};

/** @internal */
export const OpenResponsesRequest$outboundSchema: z.ZodType<
  OpenResponsesRequest$Outbound,
  OpenResponsesRequest
> = z.object({
  input: OpenResponsesInput$outboundSchema.optional(),
  instructions: z.nullable(z.string()).optional(),
  metadata: z.nullable(z.record(z.string(), z.string())).optional(),
  tools: z.array(
    z.union([
      z.lazy(() => OpenResponsesRequestToolFunction$outboundSchema),
      OpenResponsesWebSearchPreviewTool$outboundSchema,
      OpenResponsesWebSearchPreview20250311Tool$outboundSchema,
      OpenResponsesWebSearchTool$outboundSchema,
      OpenResponsesWebSearch20250826Tool$outboundSchema,
    ]),
  ).optional(),
  toolChoice: OpenAIResponsesToolChoiceUnion$outboundSchema.optional(),
  parallelToolCalls: z.nullable(z.boolean()).optional(),
  model: z.string().optional(),
  models: z.array(z.string()).optional(),
  text: OpenResponsesResponseText$outboundSchema.optional(),
  reasoning: z.nullable(OpenResponsesReasoningConfig$outboundSchema).optional(),
  maxOutputTokens: z.nullable(z.number()).optional(),
  temperature: z.nullable(z.number()).optional(),
  topP: z.nullable(z.number()).optional(),
  topK: z.number().optional(),
  promptCacheKey: z.nullable(z.string()).optional(),
  previousResponseId: z.nullable(z.string()).optional(),
  prompt: z.nullable(OpenAIResponsesPrompt$outboundSchema).optional(),
  include: z.nullable(z.array(OpenAIResponsesIncludable$outboundSchema))
    .optional(),
  background: z.nullable(z.boolean()).optional(),
  safetyIdentifier: z.nullable(z.string()).optional(),
  store: z.literal(false).default(false as const),
  serviceTier: ServiceTier$outboundSchema.default("auto"),
  truncation: z.nullable(Truncation$outboundSchema).optional(),
  stream: z.boolean().default(false),
  provider: z.nullable(
    z.lazy(() => OpenResponsesRequestProvider$outboundSchema),
  ).optional(),
  plugins: z.array(
    z.union([
      z.lazy(() => OpenResponsesRequestPluginModeration$outboundSchema),
      z.lazy(() => OpenResponsesRequestPluginWeb$outboundSchema),
      z.lazy(() => OpenResponsesRequestPluginFileParser$outboundSchema),
      z.lazy(() => OpenResponsesRequestPluginResponseHealing$outboundSchema),
    ]),
  ).optional(),
  user: z.string().optional(),
  sessionId: z.string().optional(),
}).transform((v) => {
  return remap$(v, {
    toolChoice: "tool_choice",
    parallelToolCalls: "parallel_tool_calls",
    maxOutputTokens: "max_output_tokens",
    topP: "top_p",
    topK: "top_k",
    promptCacheKey: "prompt_cache_key",
    previousResponseId: "previous_response_id",
    safetyIdentifier: "safety_identifier",
    serviceTier: "service_tier",
    sessionId: "session_id",
  });
});

export function openResponsesRequestToJSON(
  openResponsesRequest: OpenResponsesRequest,
): string {
  return JSON.stringify(
    OpenResponsesRequest$outboundSchema.parse(openResponsesRequest),
  );
}
