/*
 * Code generated by Speakeasy (https://speakeasy.com). DO NOT EDIT.
 */

import * as z from "zod";
import { remap as remap$ } from "../lib/primitives.js";
import { safeParse } from "../lib/schemas.js";
import { ClosedEnum } from "../types/enums.js";
import { Result as SafeParseResult } from "../types/fp.js";
import { SDKValidationError } from "./errors/sdkvalidationerror.js";

export type ModelsListPrompt = number | string | any;

export type ModelsListCompletion = number | string | any;

export type ModelsListRequest = number | string | any;

export type ModelsListImage = number | string | any;

export type ModelsListImageOutput = number | string | any;

export type ModelsListAudio = number | string | any;

export type ModelsListInputAudioCache = number | string | any;

export type ModelsListWebSearch = number | string | any;

export type ModelsListInternalReasoning = number | string | any;

export type ModelsListInputCacheRead = number | string | any;

export type ModelsListInputCacheWrite = number | string | any;

/**
 * Pricing information for the model
 */
export type ModelsListPricing = {
  prompt?: number | string | any | undefined;
  completion?: number | string | any | undefined;
  request?: number | string | any | undefined;
  image?: number | string | any | undefined;
  imageOutput?: number | string | any | undefined;
  audio?: number | string | any | undefined;
  inputAudioCache?: number | string | any | undefined;
  webSearch?: number | string | any | undefined;
  internalReasoning?: number | string | any | undefined;
  inputCacheRead?: number | string | any | undefined;
  inputCacheWrite?: number | string | any | undefined;
  discount?: number | undefined;
};

/**
 * Tokenizer type used by the model
 */
export const Tokenizer = {
  Router: "Router",
  Media: "Media",
  Other: "Other",
  Gpt: "GPT",
  Claude: "Claude",
  Gemini: "Gemini",
  Grok: "Grok",
  Cohere: "Cohere",
  Nova: "Nova",
  Qwen: "Qwen",
  Yi: "Yi",
  DeepSeek: "DeepSeek",
  Mistral: "Mistral",
  Llama2: "Llama2",
  Llama3: "Llama3",
  Llama4: "Llama4",
  PaLM: "PaLM",
  Rwkv: "RWKV",
  Qwen3: "Qwen3",
} as const;
/**
 * Tokenizer type used by the model
 */
export type Tokenizer = ClosedEnum<typeof Tokenizer>;

/**
 * Instruction format type
 */
export const InstructType = {
  None: "none",
  Airoboros: "airoboros",
  Alpaca: "alpaca",
  AlpacaModif: "alpaca-modif",
  Chatml: "chatml",
  Claude: "claude",
  CodeLlama: "code-llama",
  Gemma: "gemma",
  Llama2: "llama2",
  Llama3: "llama3",
  Mistral: "mistral",
  Nemotron: "nemotron",
  Neural: "neural",
  Openchat: "openchat",
  Phi3: "phi3",
  Rwkv: "rwkv",
  Vicuna: "vicuna",
  Zephyr: "zephyr",
  DeepseekR1: "deepseek-r1",
  DeepseekV31: "deepseek-v3.1",
  Qwq: "qwq",
  Qwen3: "qwen3",
} as const;
/**
 * Instruction format type
 */
export type InstructType = ClosedEnum<typeof InstructType>;

export const InputModality = {
  Text: "text",
  Image: "image",
  File: "file",
  Audio: "audio",
} as const;
export type InputModality = ClosedEnum<typeof InputModality>;

export const OutputModality = {
  Text: "text",
  Image: "image",
  Embeddings: "embeddings",
} as const;
export type OutputModality = ClosedEnum<typeof OutputModality>;

/**
 * Model architecture information
 */
export type Architecture = {
  /**
   * Tokenizer type used by the model
   */
  tokenizer?: Tokenizer | undefined;
  /**
   * Instruction format type
   */
  instructType?: InstructType | null | undefined;
  /**
   * Primary modality of the model
   */
  modality: string | null;
  /**
   * Supported input modalities
   */
  inputModalities: Array<InputModality>;
  /**
   * Supported output modalities
   */
  outputModalities: Array<OutputModality>;
};

/**
 * Information about the top provider for this model
 */
export type TopProvider = {
  /**
   * Context length from the top provider
   */
  contextLength?: number | null | undefined;
  /**
   * Maximum completion tokens from the top provider
   */
  maxCompletionTokens?: number | null | undefined;
  /**
   * Whether the top provider moderates content
   */
  isModerated: boolean;
};

/**
 * Per-request token limits
 */
export type PerRequestLimits = {
  /**
   * Maximum prompt tokens per request
   */
  promptTokens?: any | undefined;
  /**
   * Maximum completion tokens per request
   */
  completionTokens?: any | undefined;
};

export const ModelsListSupportedParameter = {
  Temperature: "temperature",
  TopP: "top_p",
  TopK: "top_k",
  MinP: "min_p",
  TopA: "top_a",
  FrequencyPenalty: "frequency_penalty",
  PresencePenalty: "presence_penalty",
  RepetitionPenalty: "repetition_penalty",
  MaxTokens: "max_tokens",
  LogitBias: "logit_bias",
  Logprobs: "logprobs",
  TopLogprobs: "top_logprobs",
  Seed: "seed",
  ResponseFormat: "response_format",
  StructuredOutputs: "structured_outputs",
  Stop: "stop",
  Tools: "tools",
  ToolChoice: "tool_choice",
  ParallelToolCalls: "parallel_tool_calls",
  IncludeReasoning: "include_reasoning",
  Reasoning: "reasoning",
  WebSearchOptions: "web_search_options",
  Verbosity: "verbosity",
} as const;
export type ModelsListSupportedParameter = ClosedEnum<
  typeof ModelsListSupportedParameter
>;

/**
 * Default parameters for this model
 */
export type DefaultParameters = {
  temperature?: number | null | undefined;
  topP?: number | null | undefined;
  frequencyPenalty?: number | null | undefined;
};

export type ModelsList = {
  /**
   * Unique identifier for the model
   */
  id: string;
  /**
   * Canonical slug for the model
   */
  canonicalSlug: string;
  /**
   * Hugging Face model identifier, if applicable
   */
  huggingFaceId?: string | null | undefined;
  /**
   * Display name of the model
   */
  name: string;
  /**
   * Unix timestamp of when the model was created
   */
  created: number;
  /**
   * Description of the model
   */
  description?: string | undefined;
  /**
   * Pricing information for the model
   */
  pricing: ModelsListPricing;
  /**
   * Maximum context length in tokens
   */
  contextLength: number | null;
  /**
   * Model architecture information
   */
  architecture: Architecture;
  /**
   * Information about the top provider for this model
   */
  topProvider: TopProvider;
  /**
   * Per-request token limits
   */
  perRequestLimits: PerRequestLimits | null;
  /**
   * List of supported parameters for this model
   */
  supportedParameters: Array<ModelsListSupportedParameter>;
  /**
   * Default parameters for this model
   */
  defaultParameters: DefaultParameters | null;
};

/** @internal */
export const ModelsListPrompt$inboundSchema: z.ZodType<
  ModelsListPrompt,
  z.ZodTypeDef,
  unknown
> = z.union([z.number(), z.string(), z.any()]);

/** @internal */
export type ModelsListPrompt$Outbound = number | string | any;

/** @internal */
export const ModelsListPrompt$outboundSchema: z.ZodType<
  ModelsListPrompt$Outbound,
  z.ZodTypeDef,
  ModelsListPrompt
> = z.union([z.number(), z.string(), z.any()]);

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace ModelsListPrompt$ {
  /** @deprecated use `ModelsListPrompt$inboundSchema` instead. */
  export const inboundSchema = ModelsListPrompt$inboundSchema;
  /** @deprecated use `ModelsListPrompt$outboundSchema` instead. */
  export const outboundSchema = ModelsListPrompt$outboundSchema;
  /** @deprecated use `ModelsListPrompt$Outbound` instead. */
  export type Outbound = ModelsListPrompt$Outbound;
}

export function modelsListPromptToJSON(
  modelsListPrompt: ModelsListPrompt,
): string {
  return JSON.stringify(
    ModelsListPrompt$outboundSchema.parse(modelsListPrompt),
  );
}

export function modelsListPromptFromJSON(
  jsonString: string,
): SafeParseResult<ModelsListPrompt, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => ModelsListPrompt$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'ModelsListPrompt' from JSON`,
  );
}

/** @internal */
export const ModelsListCompletion$inboundSchema: z.ZodType<
  ModelsListCompletion,
  z.ZodTypeDef,
  unknown
> = z.union([z.number(), z.string(), z.any()]);

/** @internal */
export type ModelsListCompletion$Outbound = number | string | any;

/** @internal */
export const ModelsListCompletion$outboundSchema: z.ZodType<
  ModelsListCompletion$Outbound,
  z.ZodTypeDef,
  ModelsListCompletion
> = z.union([z.number(), z.string(), z.any()]);

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace ModelsListCompletion$ {
  /** @deprecated use `ModelsListCompletion$inboundSchema` instead. */
  export const inboundSchema = ModelsListCompletion$inboundSchema;
  /** @deprecated use `ModelsListCompletion$outboundSchema` instead. */
  export const outboundSchema = ModelsListCompletion$outboundSchema;
  /** @deprecated use `ModelsListCompletion$Outbound` instead. */
  export type Outbound = ModelsListCompletion$Outbound;
}

export function modelsListCompletionToJSON(
  modelsListCompletion: ModelsListCompletion,
): string {
  return JSON.stringify(
    ModelsListCompletion$outboundSchema.parse(modelsListCompletion),
  );
}

export function modelsListCompletionFromJSON(
  jsonString: string,
): SafeParseResult<ModelsListCompletion, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => ModelsListCompletion$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'ModelsListCompletion' from JSON`,
  );
}

/** @internal */
export const ModelsListRequest$inboundSchema: z.ZodType<
  ModelsListRequest,
  z.ZodTypeDef,
  unknown
> = z.union([z.number(), z.string(), z.any()]);

/** @internal */
export type ModelsListRequest$Outbound = number | string | any;

/** @internal */
export const ModelsListRequest$outboundSchema: z.ZodType<
  ModelsListRequest$Outbound,
  z.ZodTypeDef,
  ModelsListRequest
> = z.union([z.number(), z.string(), z.any()]);

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace ModelsListRequest$ {
  /** @deprecated use `ModelsListRequest$inboundSchema` instead. */
  export const inboundSchema = ModelsListRequest$inboundSchema;
  /** @deprecated use `ModelsListRequest$outboundSchema` instead. */
  export const outboundSchema = ModelsListRequest$outboundSchema;
  /** @deprecated use `ModelsListRequest$Outbound` instead. */
  export type Outbound = ModelsListRequest$Outbound;
}

export function modelsListRequestToJSON(
  modelsListRequest: ModelsListRequest,
): string {
  return JSON.stringify(
    ModelsListRequest$outboundSchema.parse(modelsListRequest),
  );
}

export function modelsListRequestFromJSON(
  jsonString: string,
): SafeParseResult<ModelsListRequest, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => ModelsListRequest$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'ModelsListRequest' from JSON`,
  );
}

/** @internal */
export const ModelsListImage$inboundSchema: z.ZodType<
  ModelsListImage,
  z.ZodTypeDef,
  unknown
> = z.union([z.number(), z.string(), z.any()]);

/** @internal */
export type ModelsListImage$Outbound = number | string | any;

/** @internal */
export const ModelsListImage$outboundSchema: z.ZodType<
  ModelsListImage$Outbound,
  z.ZodTypeDef,
  ModelsListImage
> = z.union([z.number(), z.string(), z.any()]);

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace ModelsListImage$ {
  /** @deprecated use `ModelsListImage$inboundSchema` instead. */
  export const inboundSchema = ModelsListImage$inboundSchema;
  /** @deprecated use `ModelsListImage$outboundSchema` instead. */
  export const outboundSchema = ModelsListImage$outboundSchema;
  /** @deprecated use `ModelsListImage$Outbound` instead. */
  export type Outbound = ModelsListImage$Outbound;
}

export function modelsListImageToJSON(
  modelsListImage: ModelsListImage,
): string {
  return JSON.stringify(ModelsListImage$outboundSchema.parse(modelsListImage));
}

export function modelsListImageFromJSON(
  jsonString: string,
): SafeParseResult<ModelsListImage, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => ModelsListImage$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'ModelsListImage' from JSON`,
  );
}

/** @internal */
export const ModelsListImageOutput$inboundSchema: z.ZodType<
  ModelsListImageOutput,
  z.ZodTypeDef,
  unknown
> = z.union([z.number(), z.string(), z.any()]);

/** @internal */
export type ModelsListImageOutput$Outbound = number | string | any;

/** @internal */
export const ModelsListImageOutput$outboundSchema: z.ZodType<
  ModelsListImageOutput$Outbound,
  z.ZodTypeDef,
  ModelsListImageOutput
> = z.union([z.number(), z.string(), z.any()]);

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace ModelsListImageOutput$ {
  /** @deprecated use `ModelsListImageOutput$inboundSchema` instead. */
  export const inboundSchema = ModelsListImageOutput$inboundSchema;
  /** @deprecated use `ModelsListImageOutput$outboundSchema` instead. */
  export const outboundSchema = ModelsListImageOutput$outboundSchema;
  /** @deprecated use `ModelsListImageOutput$Outbound` instead. */
  export type Outbound = ModelsListImageOutput$Outbound;
}

export function modelsListImageOutputToJSON(
  modelsListImageOutput: ModelsListImageOutput,
): string {
  return JSON.stringify(
    ModelsListImageOutput$outboundSchema.parse(modelsListImageOutput),
  );
}

export function modelsListImageOutputFromJSON(
  jsonString: string,
): SafeParseResult<ModelsListImageOutput, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => ModelsListImageOutput$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'ModelsListImageOutput' from JSON`,
  );
}

/** @internal */
export const ModelsListAudio$inboundSchema: z.ZodType<
  ModelsListAudio,
  z.ZodTypeDef,
  unknown
> = z.union([z.number(), z.string(), z.any()]);

/** @internal */
export type ModelsListAudio$Outbound = number | string | any;

/** @internal */
export const ModelsListAudio$outboundSchema: z.ZodType<
  ModelsListAudio$Outbound,
  z.ZodTypeDef,
  ModelsListAudio
> = z.union([z.number(), z.string(), z.any()]);

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace ModelsListAudio$ {
  /** @deprecated use `ModelsListAudio$inboundSchema` instead. */
  export const inboundSchema = ModelsListAudio$inboundSchema;
  /** @deprecated use `ModelsListAudio$outboundSchema` instead. */
  export const outboundSchema = ModelsListAudio$outboundSchema;
  /** @deprecated use `ModelsListAudio$Outbound` instead. */
  export type Outbound = ModelsListAudio$Outbound;
}

export function modelsListAudioToJSON(
  modelsListAudio: ModelsListAudio,
): string {
  return JSON.stringify(ModelsListAudio$outboundSchema.parse(modelsListAudio));
}

export function modelsListAudioFromJSON(
  jsonString: string,
): SafeParseResult<ModelsListAudio, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => ModelsListAudio$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'ModelsListAudio' from JSON`,
  );
}

/** @internal */
export const ModelsListInputAudioCache$inboundSchema: z.ZodType<
  ModelsListInputAudioCache,
  z.ZodTypeDef,
  unknown
> = z.union([z.number(), z.string(), z.any()]);

/** @internal */
export type ModelsListInputAudioCache$Outbound = number | string | any;

/** @internal */
export const ModelsListInputAudioCache$outboundSchema: z.ZodType<
  ModelsListInputAudioCache$Outbound,
  z.ZodTypeDef,
  ModelsListInputAudioCache
> = z.union([z.number(), z.string(), z.any()]);

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace ModelsListInputAudioCache$ {
  /** @deprecated use `ModelsListInputAudioCache$inboundSchema` instead. */
  export const inboundSchema = ModelsListInputAudioCache$inboundSchema;
  /** @deprecated use `ModelsListInputAudioCache$outboundSchema` instead. */
  export const outboundSchema = ModelsListInputAudioCache$outboundSchema;
  /** @deprecated use `ModelsListInputAudioCache$Outbound` instead. */
  export type Outbound = ModelsListInputAudioCache$Outbound;
}

export function modelsListInputAudioCacheToJSON(
  modelsListInputAudioCache: ModelsListInputAudioCache,
): string {
  return JSON.stringify(
    ModelsListInputAudioCache$outboundSchema.parse(modelsListInputAudioCache),
  );
}

export function modelsListInputAudioCacheFromJSON(
  jsonString: string,
): SafeParseResult<ModelsListInputAudioCache, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => ModelsListInputAudioCache$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'ModelsListInputAudioCache' from JSON`,
  );
}

/** @internal */
export const ModelsListWebSearch$inboundSchema: z.ZodType<
  ModelsListWebSearch,
  z.ZodTypeDef,
  unknown
> = z.union([z.number(), z.string(), z.any()]);

/** @internal */
export type ModelsListWebSearch$Outbound = number | string | any;

/** @internal */
export const ModelsListWebSearch$outboundSchema: z.ZodType<
  ModelsListWebSearch$Outbound,
  z.ZodTypeDef,
  ModelsListWebSearch
> = z.union([z.number(), z.string(), z.any()]);

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace ModelsListWebSearch$ {
  /** @deprecated use `ModelsListWebSearch$inboundSchema` instead. */
  export const inboundSchema = ModelsListWebSearch$inboundSchema;
  /** @deprecated use `ModelsListWebSearch$outboundSchema` instead. */
  export const outboundSchema = ModelsListWebSearch$outboundSchema;
  /** @deprecated use `ModelsListWebSearch$Outbound` instead. */
  export type Outbound = ModelsListWebSearch$Outbound;
}

export function modelsListWebSearchToJSON(
  modelsListWebSearch: ModelsListWebSearch,
): string {
  return JSON.stringify(
    ModelsListWebSearch$outboundSchema.parse(modelsListWebSearch),
  );
}

export function modelsListWebSearchFromJSON(
  jsonString: string,
): SafeParseResult<ModelsListWebSearch, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => ModelsListWebSearch$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'ModelsListWebSearch' from JSON`,
  );
}

/** @internal */
export const ModelsListInternalReasoning$inboundSchema: z.ZodType<
  ModelsListInternalReasoning,
  z.ZodTypeDef,
  unknown
> = z.union([z.number(), z.string(), z.any()]);

/** @internal */
export type ModelsListInternalReasoning$Outbound = number | string | any;

/** @internal */
export const ModelsListInternalReasoning$outboundSchema: z.ZodType<
  ModelsListInternalReasoning$Outbound,
  z.ZodTypeDef,
  ModelsListInternalReasoning
> = z.union([z.number(), z.string(), z.any()]);

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace ModelsListInternalReasoning$ {
  /** @deprecated use `ModelsListInternalReasoning$inboundSchema` instead. */
  export const inboundSchema = ModelsListInternalReasoning$inboundSchema;
  /** @deprecated use `ModelsListInternalReasoning$outboundSchema` instead. */
  export const outboundSchema = ModelsListInternalReasoning$outboundSchema;
  /** @deprecated use `ModelsListInternalReasoning$Outbound` instead. */
  export type Outbound = ModelsListInternalReasoning$Outbound;
}

export function modelsListInternalReasoningToJSON(
  modelsListInternalReasoning: ModelsListInternalReasoning,
): string {
  return JSON.stringify(
    ModelsListInternalReasoning$outboundSchema.parse(
      modelsListInternalReasoning,
    ),
  );
}

export function modelsListInternalReasoningFromJSON(
  jsonString: string,
): SafeParseResult<ModelsListInternalReasoning, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => ModelsListInternalReasoning$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'ModelsListInternalReasoning' from JSON`,
  );
}

/** @internal */
export const ModelsListInputCacheRead$inboundSchema: z.ZodType<
  ModelsListInputCacheRead,
  z.ZodTypeDef,
  unknown
> = z.union([z.number(), z.string(), z.any()]);

/** @internal */
export type ModelsListInputCacheRead$Outbound = number | string | any;

/** @internal */
export const ModelsListInputCacheRead$outboundSchema: z.ZodType<
  ModelsListInputCacheRead$Outbound,
  z.ZodTypeDef,
  ModelsListInputCacheRead
> = z.union([z.number(), z.string(), z.any()]);

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace ModelsListInputCacheRead$ {
  /** @deprecated use `ModelsListInputCacheRead$inboundSchema` instead. */
  export const inboundSchema = ModelsListInputCacheRead$inboundSchema;
  /** @deprecated use `ModelsListInputCacheRead$outboundSchema` instead. */
  export const outboundSchema = ModelsListInputCacheRead$outboundSchema;
  /** @deprecated use `ModelsListInputCacheRead$Outbound` instead. */
  export type Outbound = ModelsListInputCacheRead$Outbound;
}

export function modelsListInputCacheReadToJSON(
  modelsListInputCacheRead: ModelsListInputCacheRead,
): string {
  return JSON.stringify(
    ModelsListInputCacheRead$outboundSchema.parse(modelsListInputCacheRead),
  );
}

export function modelsListInputCacheReadFromJSON(
  jsonString: string,
): SafeParseResult<ModelsListInputCacheRead, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => ModelsListInputCacheRead$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'ModelsListInputCacheRead' from JSON`,
  );
}

/** @internal */
export const ModelsListInputCacheWrite$inboundSchema: z.ZodType<
  ModelsListInputCacheWrite,
  z.ZodTypeDef,
  unknown
> = z.union([z.number(), z.string(), z.any()]);

/** @internal */
export type ModelsListInputCacheWrite$Outbound = number | string | any;

/** @internal */
export const ModelsListInputCacheWrite$outboundSchema: z.ZodType<
  ModelsListInputCacheWrite$Outbound,
  z.ZodTypeDef,
  ModelsListInputCacheWrite
> = z.union([z.number(), z.string(), z.any()]);

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace ModelsListInputCacheWrite$ {
  /** @deprecated use `ModelsListInputCacheWrite$inboundSchema` instead. */
  export const inboundSchema = ModelsListInputCacheWrite$inboundSchema;
  /** @deprecated use `ModelsListInputCacheWrite$outboundSchema` instead. */
  export const outboundSchema = ModelsListInputCacheWrite$outboundSchema;
  /** @deprecated use `ModelsListInputCacheWrite$Outbound` instead. */
  export type Outbound = ModelsListInputCacheWrite$Outbound;
}

export function modelsListInputCacheWriteToJSON(
  modelsListInputCacheWrite: ModelsListInputCacheWrite,
): string {
  return JSON.stringify(
    ModelsListInputCacheWrite$outboundSchema.parse(modelsListInputCacheWrite),
  );
}

export function modelsListInputCacheWriteFromJSON(
  jsonString: string,
): SafeParseResult<ModelsListInputCacheWrite, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => ModelsListInputCacheWrite$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'ModelsListInputCacheWrite' from JSON`,
  );
}

/** @internal */
export const ModelsListPricing$inboundSchema: z.ZodType<
  ModelsListPricing,
  z.ZodTypeDef,
  unknown
> = z.object({
  prompt: z.union([z.number(), z.string(), z.any()]).optional(),
  completion: z.union([z.number(), z.string(), z.any()]).optional(),
  request: z.union([z.number(), z.string(), z.any()]).optional(),
  image: z.union([z.number(), z.string(), z.any()]).optional(),
  image_output: z.union([z.number(), z.string(), z.any()]).optional(),
  audio: z.union([z.number(), z.string(), z.any()]).optional(),
  input_audio_cache: z.union([z.number(), z.string(), z.any()]).optional(),
  web_search: z.union([z.number(), z.string(), z.any()]).optional(),
  internal_reasoning: z.union([z.number(), z.string(), z.any()]).optional(),
  input_cache_read: z.union([z.number(), z.string(), z.any()]).optional(),
  input_cache_write: z.union([z.number(), z.string(), z.any()]).optional(),
  discount: z.number().optional(),
}).transform((v) => {
  return remap$(v, {
    "image_output": "imageOutput",
    "input_audio_cache": "inputAudioCache",
    "web_search": "webSearch",
    "internal_reasoning": "internalReasoning",
    "input_cache_read": "inputCacheRead",
    "input_cache_write": "inputCacheWrite",
  });
});

/** @internal */
export type ModelsListPricing$Outbound = {
  prompt?: number | string | any | undefined;
  completion?: number | string | any | undefined;
  request?: number | string | any | undefined;
  image?: number | string | any | undefined;
  image_output?: number | string | any | undefined;
  audio?: number | string | any | undefined;
  input_audio_cache?: number | string | any | undefined;
  web_search?: number | string | any | undefined;
  internal_reasoning?: number | string | any | undefined;
  input_cache_read?: number | string | any | undefined;
  input_cache_write?: number | string | any | undefined;
  discount?: number | undefined;
};

/** @internal */
export const ModelsListPricing$outboundSchema: z.ZodType<
  ModelsListPricing$Outbound,
  z.ZodTypeDef,
  ModelsListPricing
> = z.object({
  prompt: z.union([z.number(), z.string(), z.any()]).optional(),
  completion: z.union([z.number(), z.string(), z.any()]).optional(),
  request: z.union([z.number(), z.string(), z.any()]).optional(),
  image: z.union([z.number(), z.string(), z.any()]).optional(),
  imageOutput: z.union([z.number(), z.string(), z.any()]).optional(),
  audio: z.union([z.number(), z.string(), z.any()]).optional(),
  inputAudioCache: z.union([z.number(), z.string(), z.any()]).optional(),
  webSearch: z.union([z.number(), z.string(), z.any()]).optional(),
  internalReasoning: z.union([z.number(), z.string(), z.any()]).optional(),
  inputCacheRead: z.union([z.number(), z.string(), z.any()]).optional(),
  inputCacheWrite: z.union([z.number(), z.string(), z.any()]).optional(),
  discount: z.number().optional(),
}).transform((v) => {
  return remap$(v, {
    imageOutput: "image_output",
    inputAudioCache: "input_audio_cache",
    webSearch: "web_search",
    internalReasoning: "internal_reasoning",
    inputCacheRead: "input_cache_read",
    inputCacheWrite: "input_cache_write",
  });
});

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace ModelsListPricing$ {
  /** @deprecated use `ModelsListPricing$inboundSchema` instead. */
  export const inboundSchema = ModelsListPricing$inboundSchema;
  /** @deprecated use `ModelsListPricing$outboundSchema` instead. */
  export const outboundSchema = ModelsListPricing$outboundSchema;
  /** @deprecated use `ModelsListPricing$Outbound` instead. */
  export type Outbound = ModelsListPricing$Outbound;
}

export function modelsListPricingToJSON(
  modelsListPricing: ModelsListPricing,
): string {
  return JSON.stringify(
    ModelsListPricing$outboundSchema.parse(modelsListPricing),
  );
}

export function modelsListPricingFromJSON(
  jsonString: string,
): SafeParseResult<ModelsListPricing, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => ModelsListPricing$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'ModelsListPricing' from JSON`,
  );
}

/** @internal */
export const Tokenizer$inboundSchema: z.ZodNativeEnum<typeof Tokenizer> = z
  .nativeEnum(Tokenizer);

/** @internal */
export const Tokenizer$outboundSchema: z.ZodNativeEnum<typeof Tokenizer> =
  Tokenizer$inboundSchema;

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace Tokenizer$ {
  /** @deprecated use `Tokenizer$inboundSchema` instead. */
  export const inboundSchema = Tokenizer$inboundSchema;
  /** @deprecated use `Tokenizer$outboundSchema` instead. */
  export const outboundSchema = Tokenizer$outboundSchema;
}

/** @internal */
export const InstructType$inboundSchema: z.ZodNativeEnum<typeof InstructType> =
  z.nativeEnum(InstructType);

/** @internal */
export const InstructType$outboundSchema: z.ZodNativeEnum<typeof InstructType> =
  InstructType$inboundSchema;

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace InstructType$ {
  /** @deprecated use `InstructType$inboundSchema` instead. */
  export const inboundSchema = InstructType$inboundSchema;
  /** @deprecated use `InstructType$outboundSchema` instead. */
  export const outboundSchema = InstructType$outboundSchema;
}

/** @internal */
export const InputModality$inboundSchema: z.ZodNativeEnum<
  typeof InputModality
> = z.nativeEnum(InputModality);

/** @internal */
export const InputModality$outboundSchema: z.ZodNativeEnum<
  typeof InputModality
> = InputModality$inboundSchema;

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace InputModality$ {
  /** @deprecated use `InputModality$inboundSchema` instead. */
  export const inboundSchema = InputModality$inboundSchema;
  /** @deprecated use `InputModality$outboundSchema` instead. */
  export const outboundSchema = InputModality$outboundSchema;
}

/** @internal */
export const OutputModality$inboundSchema: z.ZodNativeEnum<
  typeof OutputModality
> = z.nativeEnum(OutputModality);

/** @internal */
export const OutputModality$outboundSchema: z.ZodNativeEnum<
  typeof OutputModality
> = OutputModality$inboundSchema;

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace OutputModality$ {
  /** @deprecated use `OutputModality$inboundSchema` instead. */
  export const inboundSchema = OutputModality$inboundSchema;
  /** @deprecated use `OutputModality$outboundSchema` instead. */
  export const outboundSchema = OutputModality$outboundSchema;
}

/** @internal */
export const Architecture$inboundSchema: z.ZodType<
  Architecture,
  z.ZodTypeDef,
  unknown
> = z.object({
  tokenizer: Tokenizer$inboundSchema.optional(),
  instruct_type: z.nullable(InstructType$inboundSchema).optional(),
  modality: z.nullable(z.string()),
  input_modalities: z.array(InputModality$inboundSchema),
  output_modalities: z.array(OutputModality$inboundSchema),
}).transform((v) => {
  return remap$(v, {
    "instruct_type": "instructType",
    "input_modalities": "inputModalities",
    "output_modalities": "outputModalities",
  });
});

/** @internal */
export type Architecture$Outbound = {
  tokenizer?: string | undefined;
  instruct_type?: string | null | undefined;
  modality: string | null;
  input_modalities: Array<string>;
  output_modalities: Array<string>;
};

/** @internal */
export const Architecture$outboundSchema: z.ZodType<
  Architecture$Outbound,
  z.ZodTypeDef,
  Architecture
> = z.object({
  tokenizer: Tokenizer$outboundSchema.optional(),
  instructType: z.nullable(InstructType$outboundSchema).optional(),
  modality: z.nullable(z.string()),
  inputModalities: z.array(InputModality$outboundSchema),
  outputModalities: z.array(OutputModality$outboundSchema),
}).transform((v) => {
  return remap$(v, {
    instructType: "instruct_type",
    inputModalities: "input_modalities",
    outputModalities: "output_modalities",
  });
});

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace Architecture$ {
  /** @deprecated use `Architecture$inboundSchema` instead. */
  export const inboundSchema = Architecture$inboundSchema;
  /** @deprecated use `Architecture$outboundSchema` instead. */
  export const outboundSchema = Architecture$outboundSchema;
  /** @deprecated use `Architecture$Outbound` instead. */
  export type Outbound = Architecture$Outbound;
}

export function architectureToJSON(architecture: Architecture): string {
  return JSON.stringify(Architecture$outboundSchema.parse(architecture));
}

export function architectureFromJSON(
  jsonString: string,
): SafeParseResult<Architecture, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => Architecture$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'Architecture' from JSON`,
  );
}

/** @internal */
export const TopProvider$inboundSchema: z.ZodType<
  TopProvider,
  z.ZodTypeDef,
  unknown
> = z.object({
  context_length: z.nullable(z.number()).optional(),
  max_completion_tokens: z.nullable(z.number()).optional(),
  is_moderated: z.boolean(),
}).transform((v) => {
  return remap$(v, {
    "context_length": "contextLength",
    "max_completion_tokens": "maxCompletionTokens",
    "is_moderated": "isModerated",
  });
});

/** @internal */
export type TopProvider$Outbound = {
  context_length?: number | null | undefined;
  max_completion_tokens?: number | null | undefined;
  is_moderated: boolean;
};

/** @internal */
export const TopProvider$outboundSchema: z.ZodType<
  TopProvider$Outbound,
  z.ZodTypeDef,
  TopProvider
> = z.object({
  contextLength: z.nullable(z.number()).optional(),
  maxCompletionTokens: z.nullable(z.number()).optional(),
  isModerated: z.boolean(),
}).transform((v) => {
  return remap$(v, {
    contextLength: "context_length",
    maxCompletionTokens: "max_completion_tokens",
    isModerated: "is_moderated",
  });
});

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace TopProvider$ {
  /** @deprecated use `TopProvider$inboundSchema` instead. */
  export const inboundSchema = TopProvider$inboundSchema;
  /** @deprecated use `TopProvider$outboundSchema` instead. */
  export const outboundSchema = TopProvider$outboundSchema;
  /** @deprecated use `TopProvider$Outbound` instead. */
  export type Outbound = TopProvider$Outbound;
}

export function topProviderToJSON(topProvider: TopProvider): string {
  return JSON.stringify(TopProvider$outboundSchema.parse(topProvider));
}

export function topProviderFromJSON(
  jsonString: string,
): SafeParseResult<TopProvider, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => TopProvider$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'TopProvider' from JSON`,
  );
}

/** @internal */
export const PerRequestLimits$inboundSchema: z.ZodType<
  PerRequestLimits,
  z.ZodTypeDef,
  unknown
> = z.object({
  prompt_tokens: z.any().optional(),
  completion_tokens: z.any().optional(),
}).transform((v) => {
  return remap$(v, {
    "prompt_tokens": "promptTokens",
    "completion_tokens": "completionTokens",
  });
});

/** @internal */
export type PerRequestLimits$Outbound = {
  prompt_tokens?: any | undefined;
  completion_tokens?: any | undefined;
};

/** @internal */
export const PerRequestLimits$outboundSchema: z.ZodType<
  PerRequestLimits$Outbound,
  z.ZodTypeDef,
  PerRequestLimits
> = z.object({
  promptTokens: z.any().optional(),
  completionTokens: z.any().optional(),
}).transform((v) => {
  return remap$(v, {
    promptTokens: "prompt_tokens",
    completionTokens: "completion_tokens",
  });
});

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace PerRequestLimits$ {
  /** @deprecated use `PerRequestLimits$inboundSchema` instead. */
  export const inboundSchema = PerRequestLimits$inboundSchema;
  /** @deprecated use `PerRequestLimits$outboundSchema` instead. */
  export const outboundSchema = PerRequestLimits$outboundSchema;
  /** @deprecated use `PerRequestLimits$Outbound` instead. */
  export type Outbound = PerRequestLimits$Outbound;
}

export function perRequestLimitsToJSON(
  perRequestLimits: PerRequestLimits,
): string {
  return JSON.stringify(
    PerRequestLimits$outboundSchema.parse(perRequestLimits),
  );
}

export function perRequestLimitsFromJSON(
  jsonString: string,
): SafeParseResult<PerRequestLimits, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => PerRequestLimits$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'PerRequestLimits' from JSON`,
  );
}

/** @internal */
export const ModelsListSupportedParameter$inboundSchema: z.ZodNativeEnum<
  typeof ModelsListSupportedParameter
> = z.nativeEnum(ModelsListSupportedParameter);

/** @internal */
export const ModelsListSupportedParameter$outboundSchema: z.ZodNativeEnum<
  typeof ModelsListSupportedParameter
> = ModelsListSupportedParameter$inboundSchema;

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace ModelsListSupportedParameter$ {
  /** @deprecated use `ModelsListSupportedParameter$inboundSchema` instead. */
  export const inboundSchema = ModelsListSupportedParameter$inboundSchema;
  /** @deprecated use `ModelsListSupportedParameter$outboundSchema` instead. */
  export const outboundSchema = ModelsListSupportedParameter$outboundSchema;
}

/** @internal */
export const DefaultParameters$inboundSchema: z.ZodType<
  DefaultParameters,
  z.ZodTypeDef,
  unknown
> = z.object({
  temperature: z.nullable(z.number()).optional(),
  top_p: z.nullable(z.number()).optional(),
  frequency_penalty: z.nullable(z.number()).optional(),
}).transform((v) => {
  return remap$(v, {
    "top_p": "topP",
    "frequency_penalty": "frequencyPenalty",
  });
});

/** @internal */
export type DefaultParameters$Outbound = {
  temperature?: number | null | undefined;
  top_p?: number | null | undefined;
  frequency_penalty?: number | null | undefined;
};

/** @internal */
export const DefaultParameters$outboundSchema: z.ZodType<
  DefaultParameters$Outbound,
  z.ZodTypeDef,
  DefaultParameters
> = z.object({
  temperature: z.nullable(z.number()).optional(),
  topP: z.nullable(z.number()).optional(),
  frequencyPenalty: z.nullable(z.number()).optional(),
}).transform((v) => {
  return remap$(v, {
    topP: "top_p",
    frequencyPenalty: "frequency_penalty",
  });
});

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace DefaultParameters$ {
  /** @deprecated use `DefaultParameters$inboundSchema` instead. */
  export const inboundSchema = DefaultParameters$inboundSchema;
  /** @deprecated use `DefaultParameters$outboundSchema` instead. */
  export const outboundSchema = DefaultParameters$outboundSchema;
  /** @deprecated use `DefaultParameters$Outbound` instead. */
  export type Outbound = DefaultParameters$Outbound;
}

export function defaultParametersToJSON(
  defaultParameters: DefaultParameters,
): string {
  return JSON.stringify(
    DefaultParameters$outboundSchema.parse(defaultParameters),
  );
}

export function defaultParametersFromJSON(
  jsonString: string,
): SafeParseResult<DefaultParameters, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => DefaultParameters$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'DefaultParameters' from JSON`,
  );
}

/** @internal */
export const ModelsList$inboundSchema: z.ZodType<
  ModelsList,
  z.ZodTypeDef,
  unknown
> = z.object({
  id: z.string(),
  canonical_slug: z.string(),
  hugging_face_id: z.nullable(z.string()).optional(),
  name: z.string(),
  created: z.number(),
  description: z.string().optional(),
  pricing: z.lazy(() => ModelsListPricing$inboundSchema),
  context_length: z.nullable(z.number()),
  architecture: z.lazy(() => Architecture$inboundSchema),
  top_provider: z.lazy(() => TopProvider$inboundSchema),
  per_request_limits: z.nullable(z.lazy(() => PerRequestLimits$inboundSchema)),
  supported_parameters: z.array(ModelsListSupportedParameter$inboundSchema),
  default_parameters: z.nullable(z.lazy(() => DefaultParameters$inboundSchema)),
}).transform((v) => {
  return remap$(v, {
    "canonical_slug": "canonicalSlug",
    "hugging_face_id": "huggingFaceId",
    "context_length": "contextLength",
    "top_provider": "topProvider",
    "per_request_limits": "perRequestLimits",
    "supported_parameters": "supportedParameters",
    "default_parameters": "defaultParameters",
  });
});

/** @internal */
export type ModelsList$Outbound = {
  id: string;
  canonical_slug: string;
  hugging_face_id?: string | null | undefined;
  name: string;
  created: number;
  description?: string | undefined;
  pricing: ModelsListPricing$Outbound;
  context_length: number | null;
  architecture: Architecture$Outbound;
  top_provider: TopProvider$Outbound;
  per_request_limits: PerRequestLimits$Outbound | null;
  supported_parameters: Array<string>;
  default_parameters: DefaultParameters$Outbound | null;
};

/** @internal */
export const ModelsList$outboundSchema: z.ZodType<
  ModelsList$Outbound,
  z.ZodTypeDef,
  ModelsList
> = z.object({
  id: z.string(),
  canonicalSlug: z.string(),
  huggingFaceId: z.nullable(z.string()).optional(),
  name: z.string(),
  created: z.number(),
  description: z.string().optional(),
  pricing: z.lazy(() => ModelsListPricing$outboundSchema),
  contextLength: z.nullable(z.number()),
  architecture: z.lazy(() => Architecture$outboundSchema),
  topProvider: z.lazy(() => TopProvider$outboundSchema),
  perRequestLimits: z.nullable(z.lazy(() => PerRequestLimits$outboundSchema)),
  supportedParameters: z.array(ModelsListSupportedParameter$outboundSchema),
  defaultParameters: z.nullable(z.lazy(() => DefaultParameters$outboundSchema)),
}).transform((v) => {
  return remap$(v, {
    canonicalSlug: "canonical_slug",
    huggingFaceId: "hugging_face_id",
    contextLength: "context_length",
    topProvider: "top_provider",
    perRequestLimits: "per_request_limits",
    supportedParameters: "supported_parameters",
    defaultParameters: "default_parameters",
  });
});

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace ModelsList$ {
  /** @deprecated use `ModelsList$inboundSchema` instead. */
  export const inboundSchema = ModelsList$inboundSchema;
  /** @deprecated use `ModelsList$outboundSchema` instead. */
  export const outboundSchema = ModelsList$outboundSchema;
  /** @deprecated use `ModelsList$Outbound` instead. */
  export type Outbound = ModelsList$Outbound;
}

export function modelsListToJSON(modelsList: ModelsList): string {
  return JSON.stringify(ModelsList$outboundSchema.parse(modelsList));
}

export function modelsListFromJSON(
  jsonString: string,
): SafeParseResult<ModelsList, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => ModelsList$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'ModelsList' from JSON`,
  );
}
