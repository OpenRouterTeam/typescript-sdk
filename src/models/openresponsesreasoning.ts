/*
 * Code generated by Speakeasy (https://speakeasy.com). DO NOT EDIT.
 */

import * as z from "zod/v4";
import { remap as remap$ } from "../lib/primitives.js";
import { ClosedEnum, OpenEnum, Unrecognized } from "../types/enums.js";
import {
  ReasoningSummaryText,
  ReasoningSummaryText$Outbound,
  ReasoningSummaryText$outboundSchema,
} from "./reasoningsummarytext.js";
import {
  ReasoningTextContent,
  ReasoningTextContent$Outbound,
  ReasoningTextContent$outboundSchema,
} from "./reasoningtextcontent.js";

export const OpenResponsesReasoningType = {
  Reasoning: "reasoning",
} as const;
export type OpenResponsesReasoningType = ClosedEnum<
  typeof OpenResponsesReasoningType
>;

export const OpenResponsesReasoningStatusInProgress = {
  InProgress: "in_progress",
} as const;
export type OpenResponsesReasoningStatusInProgress = ClosedEnum<
  typeof OpenResponsesReasoningStatusInProgress
>;

export const OpenResponsesReasoningStatusIncomplete = {
  Incomplete: "incomplete",
} as const;
export type OpenResponsesReasoningStatusIncomplete = ClosedEnum<
  typeof OpenResponsesReasoningStatusIncomplete
>;

export const OpenResponsesReasoningStatusCompleted = {
  Completed: "completed",
} as const;
export type OpenResponsesReasoningStatusCompleted = ClosedEnum<
  typeof OpenResponsesReasoningStatusCompleted
>;

export type OpenResponsesReasoningStatusUnion =
  | OpenResponsesReasoningStatusCompleted
  | OpenResponsesReasoningStatusIncomplete
  | OpenResponsesReasoningStatusInProgress;

export const OpenResponsesReasoningFormat = {
  Unknown: "unknown",
  OpenaiResponsesV1: "openai-responses-v1",
  XaiResponsesV1: "xai-responses-v1",
  AnthropicClaudeV1: "anthropic-claude-v1",
} as const;
export type OpenResponsesReasoningFormat = OpenEnum<
  typeof OpenResponsesReasoningFormat
>;

/**
 * Reasoning output item with signature and format extensions
 */
export type OpenResponsesReasoning = {
  type: OpenResponsesReasoningType;
  id: string;
  content?: Array<ReasoningTextContent> | undefined;
  summary: Array<ReasoningSummaryText>;
  encryptedContent?: string | null | undefined;
  status?:
    | OpenResponsesReasoningStatusCompleted
    | OpenResponsesReasoningStatusIncomplete
    | OpenResponsesReasoningStatusInProgress
    | undefined;
  signature?: string | null | undefined;
  format?: OpenResponsesReasoningFormat | null | undefined;
};

/** @internal */
export const OpenResponsesReasoningType$outboundSchema: z.ZodEnum<
  typeof OpenResponsesReasoningType
> = z.enum(OpenResponsesReasoningType);

/** @internal */
export const OpenResponsesReasoningStatusInProgress$outboundSchema: z.ZodEnum<
  typeof OpenResponsesReasoningStatusInProgress
> = z.enum(OpenResponsesReasoningStatusInProgress);

/** @internal */
export const OpenResponsesReasoningStatusIncomplete$outboundSchema: z.ZodEnum<
  typeof OpenResponsesReasoningStatusIncomplete
> = z.enum(OpenResponsesReasoningStatusIncomplete);

/** @internal */
export const OpenResponsesReasoningStatusCompleted$outboundSchema: z.ZodEnum<
  typeof OpenResponsesReasoningStatusCompleted
> = z.enum(OpenResponsesReasoningStatusCompleted);

/** @internal */
export type OpenResponsesReasoningStatusUnion$Outbound =
  | string
  | string
  | string;

/** @internal */
export const OpenResponsesReasoningStatusUnion$outboundSchema: z.ZodType<
  OpenResponsesReasoningStatusUnion$Outbound,
  OpenResponsesReasoningStatusUnion
> = z.union([
  OpenResponsesReasoningStatusCompleted$outboundSchema,
  OpenResponsesReasoningStatusIncomplete$outboundSchema,
  OpenResponsesReasoningStatusInProgress$outboundSchema,
]);

export function openResponsesReasoningStatusUnionToJSON(
  openResponsesReasoningStatusUnion: OpenResponsesReasoningStatusUnion,
): string {
  return JSON.stringify(
    OpenResponsesReasoningStatusUnion$outboundSchema.parse(
      openResponsesReasoningStatusUnion,
    ),
  );
}

/** @internal */
export const OpenResponsesReasoningFormat$outboundSchema: z.ZodType<
  OpenResponsesReasoningFormat,
  OpenResponsesReasoningFormat
> = z.union([
  z.enum(OpenResponsesReasoningFormat),
  z.string().and(z.custom<Unrecognized<string>>()),
]);

/** @internal */
export type OpenResponsesReasoning$Outbound = {
  type: string;
  id: string;
  content?: Array<ReasoningTextContent$Outbound> | undefined;
  summary: Array<ReasoningSummaryText$Outbound>;
  encrypted_content?: string | null | undefined;
  status?: string | string | string | undefined;
  signature?: string | null | undefined;
  format?: string | null | undefined;
};

/** @internal */
export const OpenResponsesReasoning$outboundSchema: z.ZodType<
  OpenResponsesReasoning$Outbound,
  OpenResponsesReasoning
> = z.object({
  type: OpenResponsesReasoningType$outboundSchema,
  id: z.string(),
  content: z.array(ReasoningTextContent$outboundSchema).optional(),
  summary: z.array(ReasoningSummaryText$outboundSchema),
  encryptedContent: z.nullable(z.string()).optional(),
  status: z.union([
    OpenResponsesReasoningStatusCompleted$outboundSchema,
    OpenResponsesReasoningStatusIncomplete$outboundSchema,
    OpenResponsesReasoningStatusInProgress$outboundSchema,
  ]).optional(),
  signature: z.nullable(z.string()).optional(),
  format: z.nullable(OpenResponsesReasoningFormat$outboundSchema).optional(),
}).transform((v) => {
  return remap$(v, {
    encryptedContent: "encrypted_content",
  });
});

export function openResponsesReasoningToJSON(
  openResponsesReasoning: OpenResponsesReasoning,
): string {
  return JSON.stringify(
    OpenResponsesReasoning$outboundSchema.parse(openResponsesReasoning),
  );
}
