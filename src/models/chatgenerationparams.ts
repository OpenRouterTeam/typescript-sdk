/*
 * Code generated by Speakeasy (https://speakeasy.com). DO NOT EDIT.
 */

import * as z from "zod";
import { remap as remap$ } from "../lib/primitives.js";
import { safeParse } from "../lib/schemas.js";
import { ClosedEnum } from "../types/enums.js";
import { Result as SafeParseResult } from "../types/fp.js";
import {
  ChatStreamOptions,
  ChatStreamOptions$inboundSchema,
  ChatStreamOptions$Outbound,
  ChatStreamOptions$outboundSchema,
} from "./chatstreamoptions.js";
import { SDKValidationError } from "./errors/sdkvalidationerror.js";
import {
  Message,
  Message$inboundSchema,
  Message$Outbound,
  Message$outboundSchema,
} from "./message.js";
import {
  Tool,
  Tool$inboundSchema,
  Tool$Outbound,
  Tool$outboundSchema,
} from "./tool.js";

export const Effort = {
  Minimal: "minimal",
  Low: "low",
  Medium: "medium",
  High: "high",
} as const;
export type Effort = ClosedEnum<typeof Effort>;

export const GenerateSummary = {
  Auto: "auto",
  Concise: "concise",
  Detailed: "detailed",
} as const;
export type GenerateSummary = ClosedEnum<typeof GenerateSummary>;

export const Summary = {
  Auto: "auto",
  Concise: "concise",
  Detailed: "detailed",
} as const;
export type Summary = ClosedEnum<typeof Summary>;

export type Reasoning = {
  effort?: Effort | null | undefined;
  generateSummary?: GenerateSummary | null | undefined;
  summary?: Summary | null | undefined;
};

export type ResponseFormatPython = {
  type: "python";
};

export type ResponseFormatGrammar = {
  type: "grammar";
  grammar: string;
};

export type JsonSchema = {
  name: string;
  description?: string | undefined;
  schema?: { [k: string]: any } | undefined;
  strict?: boolean | null | undefined;
};

export type ResponseFormatJSONSchema = {
  type: "json_schema";
  jsonSchema: JsonSchema;
};

export type ResponseFormatJSONObject = {
  type: "json_object";
};

export type ResponseFormatText = {
  type: "text";
};

export type ResponseFormat =
  | ResponseFormatJSONSchema
  | ResponseFormatGrammar
  | ResponseFormatText
  | ResponseFormatJSONObject
  | ResponseFormatPython;

export type Stop = string | Array<string>;

export type ChatGenerationParams = {
  messages: Array<Message>;
  model: string;
  frequencyPenalty?: number | null | undefined;
  logitBias?: { [k: string]: number } | null | undefined;
  logprobs?: boolean | null | undefined;
  topLogprobs?: number | null | undefined;
  maxCompletionTokens?: number | null | undefined;
  maxTokens?: number | null | undefined;
  metadata?: { [k: string]: string } | undefined;
  presencePenalty?: number | null | undefined;
  reasoning?: Reasoning | undefined;
  responseFormat?:
    | ResponseFormatJSONSchema
    | ResponseFormatGrammar
    | ResponseFormatText
    | ResponseFormatJSONObject
    | ResponseFormatPython
    | undefined;
  seed?: number | null | undefined;
  stop?: string | Array<string> | null | undefined;
  stream?: boolean | null | undefined;
  streamOptions?: ChatStreamOptions | null | undefined;
  temperature?: number | null | undefined;
  toolChoice?: any | undefined;
  tools?: Array<Tool> | undefined;
  topP?: number | null | undefined;
  user?: string | undefined;
};

/** @internal */
export const Effort$inboundSchema: z.ZodNativeEnum<typeof Effort> = z
  .nativeEnum(Effort);

/** @internal */
export const Effort$outboundSchema: z.ZodNativeEnum<typeof Effort> =
  Effort$inboundSchema;

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace Effort$ {
  /** @deprecated use `Effort$inboundSchema` instead. */
  export const inboundSchema = Effort$inboundSchema;
  /** @deprecated use `Effort$outboundSchema` instead. */
  export const outboundSchema = Effort$outboundSchema;
}

/** @internal */
export const GenerateSummary$inboundSchema: z.ZodNativeEnum<
  typeof GenerateSummary
> = z.nativeEnum(GenerateSummary);

/** @internal */
export const GenerateSummary$outboundSchema: z.ZodNativeEnum<
  typeof GenerateSummary
> = GenerateSummary$inboundSchema;

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace GenerateSummary$ {
  /** @deprecated use `GenerateSummary$inboundSchema` instead. */
  export const inboundSchema = GenerateSummary$inboundSchema;
  /** @deprecated use `GenerateSummary$outboundSchema` instead. */
  export const outboundSchema = GenerateSummary$outboundSchema;
}

/** @internal */
export const Summary$inboundSchema: z.ZodNativeEnum<typeof Summary> = z
  .nativeEnum(Summary);

/** @internal */
export const Summary$outboundSchema: z.ZodNativeEnum<typeof Summary> =
  Summary$inboundSchema;

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace Summary$ {
  /** @deprecated use `Summary$inboundSchema` instead. */
  export const inboundSchema = Summary$inboundSchema;
  /** @deprecated use `Summary$outboundSchema` instead. */
  export const outboundSchema = Summary$outboundSchema;
}

/** @internal */
export const Reasoning$inboundSchema: z.ZodType<
  Reasoning,
  z.ZodTypeDef,
  unknown
> = z.object({
  effort: z.nullable(Effort$inboundSchema).optional(),
  generate_summary: z.nullable(GenerateSummary$inboundSchema).optional(),
  summary: z.nullable(Summary$inboundSchema).optional(),
}).transform((v) => {
  return remap$(v, {
    "generate_summary": "generateSummary",
  });
});

/** @internal */
export type Reasoning$Outbound = {
  effort?: string | null | undefined;
  generate_summary?: string | null | undefined;
  summary?: string | null | undefined;
};

/** @internal */
export const Reasoning$outboundSchema: z.ZodType<
  Reasoning$Outbound,
  z.ZodTypeDef,
  Reasoning
> = z.object({
  effort: z.nullable(Effort$outboundSchema).optional(),
  generateSummary: z.nullable(GenerateSummary$outboundSchema).optional(),
  summary: z.nullable(Summary$outboundSchema).optional(),
}).transform((v) => {
  return remap$(v, {
    generateSummary: "generate_summary",
  });
});

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace Reasoning$ {
  /** @deprecated use `Reasoning$inboundSchema` instead. */
  export const inboundSchema = Reasoning$inboundSchema;
  /** @deprecated use `Reasoning$outboundSchema` instead. */
  export const outboundSchema = Reasoning$outboundSchema;
  /** @deprecated use `Reasoning$Outbound` instead. */
  export type Outbound = Reasoning$Outbound;
}

export function reasoningToJSON(reasoning: Reasoning): string {
  return JSON.stringify(Reasoning$outboundSchema.parse(reasoning));
}

export function reasoningFromJSON(
  jsonString: string,
): SafeParseResult<Reasoning, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => Reasoning$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'Reasoning' from JSON`,
  );
}

/** @internal */
export const ResponseFormatPython$inboundSchema: z.ZodType<
  ResponseFormatPython,
  z.ZodTypeDef,
  unknown
> = z.object({
  type: z.literal("python"),
});

/** @internal */
export type ResponseFormatPython$Outbound = {
  type: "python";
};

/** @internal */
export const ResponseFormatPython$outboundSchema: z.ZodType<
  ResponseFormatPython$Outbound,
  z.ZodTypeDef,
  ResponseFormatPython
> = z.object({
  type: z.literal("python"),
});

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace ResponseFormatPython$ {
  /** @deprecated use `ResponseFormatPython$inboundSchema` instead. */
  export const inboundSchema = ResponseFormatPython$inboundSchema;
  /** @deprecated use `ResponseFormatPython$outboundSchema` instead. */
  export const outboundSchema = ResponseFormatPython$outboundSchema;
  /** @deprecated use `ResponseFormatPython$Outbound` instead. */
  export type Outbound = ResponseFormatPython$Outbound;
}

export function responseFormatPythonToJSON(
  responseFormatPython: ResponseFormatPython,
): string {
  return JSON.stringify(
    ResponseFormatPython$outboundSchema.parse(responseFormatPython),
  );
}

export function responseFormatPythonFromJSON(
  jsonString: string,
): SafeParseResult<ResponseFormatPython, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => ResponseFormatPython$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'ResponseFormatPython' from JSON`,
  );
}

/** @internal */
export const ResponseFormatGrammar$inboundSchema: z.ZodType<
  ResponseFormatGrammar,
  z.ZodTypeDef,
  unknown
> = z.object({
  type: z.literal("grammar"),
  grammar: z.string(),
});

/** @internal */
export type ResponseFormatGrammar$Outbound = {
  type: "grammar";
  grammar: string;
};

/** @internal */
export const ResponseFormatGrammar$outboundSchema: z.ZodType<
  ResponseFormatGrammar$Outbound,
  z.ZodTypeDef,
  ResponseFormatGrammar
> = z.object({
  type: z.literal("grammar"),
  grammar: z.string(),
});

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace ResponseFormatGrammar$ {
  /** @deprecated use `ResponseFormatGrammar$inboundSchema` instead. */
  export const inboundSchema = ResponseFormatGrammar$inboundSchema;
  /** @deprecated use `ResponseFormatGrammar$outboundSchema` instead. */
  export const outboundSchema = ResponseFormatGrammar$outboundSchema;
  /** @deprecated use `ResponseFormatGrammar$Outbound` instead. */
  export type Outbound = ResponseFormatGrammar$Outbound;
}

export function responseFormatGrammarToJSON(
  responseFormatGrammar: ResponseFormatGrammar,
): string {
  return JSON.stringify(
    ResponseFormatGrammar$outboundSchema.parse(responseFormatGrammar),
  );
}

export function responseFormatGrammarFromJSON(
  jsonString: string,
): SafeParseResult<ResponseFormatGrammar, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => ResponseFormatGrammar$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'ResponseFormatGrammar' from JSON`,
  );
}

/** @internal */
export const JsonSchema$inboundSchema: z.ZodType<
  JsonSchema,
  z.ZodTypeDef,
  unknown
> = z.object({
  name: z.string(),
  description: z.string().optional(),
  schema: z.record(z.any()).optional(),
  strict: z.nullable(z.boolean()).optional(),
});

/** @internal */
export type JsonSchema$Outbound = {
  name: string;
  description?: string | undefined;
  schema?: { [k: string]: any } | undefined;
  strict?: boolean | null | undefined;
};

/** @internal */
export const JsonSchema$outboundSchema: z.ZodType<
  JsonSchema$Outbound,
  z.ZodTypeDef,
  JsonSchema
> = z.object({
  name: z.string(),
  description: z.string().optional(),
  schema: z.record(z.any()).optional(),
  strict: z.nullable(z.boolean()).optional(),
});

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace JsonSchema$ {
  /** @deprecated use `JsonSchema$inboundSchema` instead. */
  export const inboundSchema = JsonSchema$inboundSchema;
  /** @deprecated use `JsonSchema$outboundSchema` instead. */
  export const outboundSchema = JsonSchema$outboundSchema;
  /** @deprecated use `JsonSchema$Outbound` instead. */
  export type Outbound = JsonSchema$Outbound;
}

export function jsonSchemaToJSON(jsonSchema: JsonSchema): string {
  return JSON.stringify(JsonSchema$outboundSchema.parse(jsonSchema));
}

export function jsonSchemaFromJSON(
  jsonString: string,
): SafeParseResult<JsonSchema, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => JsonSchema$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'JsonSchema' from JSON`,
  );
}

/** @internal */
export const ResponseFormatJSONSchema$inboundSchema: z.ZodType<
  ResponseFormatJSONSchema,
  z.ZodTypeDef,
  unknown
> = z.object({
  type: z.literal("json_schema"),
  json_schema: z.lazy(() => JsonSchema$inboundSchema),
}).transform((v) => {
  return remap$(v, {
    "json_schema": "jsonSchema",
  });
});

/** @internal */
export type ResponseFormatJSONSchema$Outbound = {
  type: "json_schema";
  json_schema: JsonSchema$Outbound;
};

/** @internal */
export const ResponseFormatJSONSchema$outboundSchema: z.ZodType<
  ResponseFormatJSONSchema$Outbound,
  z.ZodTypeDef,
  ResponseFormatJSONSchema
> = z.object({
  type: z.literal("json_schema"),
  jsonSchema: z.lazy(() => JsonSchema$outboundSchema),
}).transform((v) => {
  return remap$(v, {
    jsonSchema: "json_schema",
  });
});

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace ResponseFormatJSONSchema$ {
  /** @deprecated use `ResponseFormatJSONSchema$inboundSchema` instead. */
  export const inboundSchema = ResponseFormatJSONSchema$inboundSchema;
  /** @deprecated use `ResponseFormatJSONSchema$outboundSchema` instead. */
  export const outboundSchema = ResponseFormatJSONSchema$outboundSchema;
  /** @deprecated use `ResponseFormatJSONSchema$Outbound` instead. */
  export type Outbound = ResponseFormatJSONSchema$Outbound;
}

export function responseFormatJSONSchemaToJSON(
  responseFormatJSONSchema: ResponseFormatJSONSchema,
): string {
  return JSON.stringify(
    ResponseFormatJSONSchema$outboundSchema.parse(responseFormatJSONSchema),
  );
}

export function responseFormatJSONSchemaFromJSON(
  jsonString: string,
): SafeParseResult<ResponseFormatJSONSchema, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => ResponseFormatJSONSchema$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'ResponseFormatJSONSchema' from JSON`,
  );
}

/** @internal */
export const ResponseFormatJSONObject$inboundSchema: z.ZodType<
  ResponseFormatJSONObject,
  z.ZodTypeDef,
  unknown
> = z.object({
  type: z.literal("json_object"),
});

/** @internal */
export type ResponseFormatJSONObject$Outbound = {
  type: "json_object";
};

/** @internal */
export const ResponseFormatJSONObject$outboundSchema: z.ZodType<
  ResponseFormatJSONObject$Outbound,
  z.ZodTypeDef,
  ResponseFormatJSONObject
> = z.object({
  type: z.literal("json_object"),
});

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace ResponseFormatJSONObject$ {
  /** @deprecated use `ResponseFormatJSONObject$inboundSchema` instead. */
  export const inboundSchema = ResponseFormatJSONObject$inboundSchema;
  /** @deprecated use `ResponseFormatJSONObject$outboundSchema` instead. */
  export const outboundSchema = ResponseFormatJSONObject$outboundSchema;
  /** @deprecated use `ResponseFormatJSONObject$Outbound` instead. */
  export type Outbound = ResponseFormatJSONObject$Outbound;
}

export function responseFormatJSONObjectToJSON(
  responseFormatJSONObject: ResponseFormatJSONObject,
): string {
  return JSON.stringify(
    ResponseFormatJSONObject$outboundSchema.parse(responseFormatJSONObject),
  );
}

export function responseFormatJSONObjectFromJSON(
  jsonString: string,
): SafeParseResult<ResponseFormatJSONObject, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => ResponseFormatJSONObject$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'ResponseFormatJSONObject' from JSON`,
  );
}

/** @internal */
export const ResponseFormatText$inboundSchema: z.ZodType<
  ResponseFormatText,
  z.ZodTypeDef,
  unknown
> = z.object({
  type: z.literal("text"),
});

/** @internal */
export type ResponseFormatText$Outbound = {
  type: "text";
};

/** @internal */
export const ResponseFormatText$outboundSchema: z.ZodType<
  ResponseFormatText$Outbound,
  z.ZodTypeDef,
  ResponseFormatText
> = z.object({
  type: z.literal("text"),
});

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace ResponseFormatText$ {
  /** @deprecated use `ResponseFormatText$inboundSchema` instead. */
  export const inboundSchema = ResponseFormatText$inboundSchema;
  /** @deprecated use `ResponseFormatText$outboundSchema` instead. */
  export const outboundSchema = ResponseFormatText$outboundSchema;
  /** @deprecated use `ResponseFormatText$Outbound` instead. */
  export type Outbound = ResponseFormatText$Outbound;
}

export function responseFormatTextToJSON(
  responseFormatText: ResponseFormatText,
): string {
  return JSON.stringify(
    ResponseFormatText$outboundSchema.parse(responseFormatText),
  );
}

export function responseFormatTextFromJSON(
  jsonString: string,
): SafeParseResult<ResponseFormatText, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => ResponseFormatText$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'ResponseFormatText' from JSON`,
  );
}

/** @internal */
export const ResponseFormat$inboundSchema: z.ZodType<
  ResponseFormat,
  z.ZodTypeDef,
  unknown
> = z.union([
  z.lazy(() => ResponseFormatJSONSchema$inboundSchema),
  z.lazy(() => ResponseFormatGrammar$inboundSchema),
  z.lazy(() => ResponseFormatText$inboundSchema),
  z.lazy(() => ResponseFormatJSONObject$inboundSchema),
  z.lazy(() => ResponseFormatPython$inboundSchema),
]);

/** @internal */
export type ResponseFormat$Outbound =
  | ResponseFormatJSONSchema$Outbound
  | ResponseFormatGrammar$Outbound
  | ResponseFormatText$Outbound
  | ResponseFormatJSONObject$Outbound
  | ResponseFormatPython$Outbound;

/** @internal */
export const ResponseFormat$outboundSchema: z.ZodType<
  ResponseFormat$Outbound,
  z.ZodTypeDef,
  ResponseFormat
> = z.union([
  z.lazy(() => ResponseFormatJSONSchema$outboundSchema),
  z.lazy(() => ResponseFormatGrammar$outboundSchema),
  z.lazy(() => ResponseFormatText$outboundSchema),
  z.lazy(() => ResponseFormatJSONObject$outboundSchema),
  z.lazy(() => ResponseFormatPython$outboundSchema),
]);

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace ResponseFormat$ {
  /** @deprecated use `ResponseFormat$inboundSchema` instead. */
  export const inboundSchema = ResponseFormat$inboundSchema;
  /** @deprecated use `ResponseFormat$outboundSchema` instead. */
  export const outboundSchema = ResponseFormat$outboundSchema;
  /** @deprecated use `ResponseFormat$Outbound` instead. */
  export type Outbound = ResponseFormat$Outbound;
}

export function responseFormatToJSON(responseFormat: ResponseFormat): string {
  return JSON.stringify(ResponseFormat$outboundSchema.parse(responseFormat));
}

export function responseFormatFromJSON(
  jsonString: string,
): SafeParseResult<ResponseFormat, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => ResponseFormat$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'ResponseFormat' from JSON`,
  );
}

/** @internal */
export const Stop$inboundSchema: z.ZodType<Stop, z.ZodTypeDef, unknown> = z
  .union([z.string(), z.array(z.string())]);

/** @internal */
export type Stop$Outbound = string | Array<string>;

/** @internal */
export const Stop$outboundSchema: z.ZodType<Stop$Outbound, z.ZodTypeDef, Stop> =
  z.union([z.string(), z.array(z.string())]);

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace Stop$ {
  /** @deprecated use `Stop$inboundSchema` instead. */
  export const inboundSchema = Stop$inboundSchema;
  /** @deprecated use `Stop$outboundSchema` instead. */
  export const outboundSchema = Stop$outboundSchema;
  /** @deprecated use `Stop$Outbound` instead. */
  export type Outbound = Stop$Outbound;
}

export function stopToJSON(stop: Stop): string {
  return JSON.stringify(Stop$outboundSchema.parse(stop));
}

export function stopFromJSON(
  jsonString: string,
): SafeParseResult<Stop, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => Stop$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'Stop' from JSON`,
  );
}

/** @internal */
export const ChatGenerationParams$inboundSchema: z.ZodType<
  ChatGenerationParams,
  z.ZodTypeDef,
  unknown
> = z.object({
  messages: z.array(Message$inboundSchema),
  model: z.string(),
  frequency_penalty: z.nullable(z.number()).optional(),
  logit_bias: z.nullable(z.record(z.number())).optional(),
  logprobs: z.nullable(z.boolean()).optional(),
  top_logprobs: z.nullable(z.number()).optional(),
  max_completion_tokens: z.nullable(z.number()).optional(),
  max_tokens: z.nullable(z.number()).optional(),
  metadata: z.record(z.string()).optional(),
  presence_penalty: z.nullable(z.number()).optional(),
  reasoning: z.lazy(() => Reasoning$inboundSchema).optional(),
  response_format: z.union([
    z.lazy(() => ResponseFormatJSONSchema$inboundSchema),
    z.lazy(() => ResponseFormatGrammar$inboundSchema),
    z.lazy(() => ResponseFormatText$inboundSchema),
    z.lazy(() => ResponseFormatJSONObject$inboundSchema),
    z.lazy(() => ResponseFormatPython$inboundSchema),
  ]).optional(),
  seed: z.nullable(z.number().int()).optional(),
  stop: z.nullable(z.union([z.string(), z.array(z.string())])).optional(),
  stream: z.nullable(z.boolean().default(false)),
  stream_options: z.nullable(ChatStreamOptions$inboundSchema).optional(),
  temperature: z.nullable(z.number().default(1)),
  tool_choice: z.any().optional(),
  tools: z.array(Tool$inboundSchema).optional(),
  top_p: z.nullable(z.number().default(1)),
  user: z.string().optional(),
}).transform((v) => {
  return remap$(v, {
    "frequency_penalty": "frequencyPenalty",
    "logit_bias": "logitBias",
    "top_logprobs": "topLogprobs",
    "max_completion_tokens": "maxCompletionTokens",
    "max_tokens": "maxTokens",
    "presence_penalty": "presencePenalty",
    "response_format": "responseFormat",
    "stream_options": "streamOptions",
    "tool_choice": "toolChoice",
    "top_p": "topP",
  });
});

/** @internal */
export type ChatGenerationParams$Outbound = {
  messages: Array<Message$Outbound>;
  model: string;
  frequency_penalty?: number | null | undefined;
  logit_bias?: { [k: string]: number } | null | undefined;
  logprobs?: boolean | null | undefined;
  top_logprobs?: number | null | undefined;
  max_completion_tokens?: number | null | undefined;
  max_tokens?: number | null | undefined;
  metadata?: { [k: string]: string } | undefined;
  presence_penalty?: number | null | undefined;
  reasoning?: Reasoning$Outbound | undefined;
  response_format?:
    | ResponseFormatJSONSchema$Outbound
    | ResponseFormatGrammar$Outbound
    | ResponseFormatText$Outbound
    | ResponseFormatJSONObject$Outbound
    | ResponseFormatPython$Outbound
    | undefined;
  seed?: number | null | undefined;
  stop?: string | Array<string> | null | undefined;
  stream: boolean | null;
  stream_options?: ChatStreamOptions$Outbound | null | undefined;
  temperature: number | null;
  tool_choice?: any | undefined;
  tools?: Array<Tool$Outbound> | undefined;
  top_p: number | null;
  user?: string | undefined;
};

/** @internal */
export const ChatGenerationParams$outboundSchema: z.ZodType<
  ChatGenerationParams$Outbound,
  z.ZodTypeDef,
  ChatGenerationParams
> = z.object({
  messages: z.array(Message$outboundSchema),
  model: z.string(),
  frequencyPenalty: z.nullable(z.number()).optional(),
  logitBias: z.nullable(z.record(z.number())).optional(),
  logprobs: z.nullable(z.boolean()).optional(),
  topLogprobs: z.nullable(z.number()).optional(),
  maxCompletionTokens: z.nullable(z.number()).optional(),
  maxTokens: z.nullable(z.number()).optional(),
  metadata: z.record(z.string()).optional(),
  presencePenalty: z.nullable(z.number()).optional(),
  reasoning: z.lazy(() => Reasoning$outboundSchema).optional(),
  responseFormat: z.union([
    z.lazy(() => ResponseFormatJSONSchema$outboundSchema),
    z.lazy(() => ResponseFormatGrammar$outboundSchema),
    z.lazy(() => ResponseFormatText$outboundSchema),
    z.lazy(() => ResponseFormatJSONObject$outboundSchema),
    z.lazy(() => ResponseFormatPython$outboundSchema),
  ]).optional(),
  seed: z.nullable(z.number().int()).optional(),
  stop: z.nullable(z.union([z.string(), z.array(z.string())])).optional(),
  stream: z.nullable(z.boolean().default(false)),
  streamOptions: z.nullable(ChatStreamOptions$outboundSchema).optional(),
  temperature: z.nullable(z.number().default(1)),
  toolChoice: z.any().optional(),
  tools: z.array(Tool$outboundSchema).optional(),
  topP: z.nullable(z.number().default(1)),
  user: z.string().optional(),
}).transform((v) => {
  return remap$(v, {
    frequencyPenalty: "frequency_penalty",
    logitBias: "logit_bias",
    topLogprobs: "top_logprobs",
    maxCompletionTokens: "max_completion_tokens",
    maxTokens: "max_tokens",
    presencePenalty: "presence_penalty",
    responseFormat: "response_format",
    streamOptions: "stream_options",
    toolChoice: "tool_choice",
    topP: "top_p",
  });
});

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace ChatGenerationParams$ {
  /** @deprecated use `ChatGenerationParams$inboundSchema` instead. */
  export const inboundSchema = ChatGenerationParams$inboundSchema;
  /** @deprecated use `ChatGenerationParams$outboundSchema` instead. */
  export const outboundSchema = ChatGenerationParams$outboundSchema;
  /** @deprecated use `ChatGenerationParams$Outbound` instead. */
  export type Outbound = ChatGenerationParams$Outbound;
}

export function chatGenerationParamsToJSON(
  chatGenerationParams: ChatGenerationParams,
): string {
  return JSON.stringify(
    ChatGenerationParams$outboundSchema.parse(chatGenerationParams),
  );
}

export function chatGenerationParamsFromJSON(
  jsonString: string,
): SafeParseResult<ChatGenerationParams, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => ChatGenerationParams$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'ChatGenerationParams' from JSON`,
  );
}
