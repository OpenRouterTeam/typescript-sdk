/*
 * Code generated by Speakeasy (https://speakeasy.com). DO NOT EDIT.
 */

import * as z from "zod";
import { remap as remap$ } from "../lib/primitives.js";
import { safeParse } from "../lib/schemas.js";
import { Result as SafeParseResult } from "../types/fp.js";
import {
  DefaultParameters,
  DefaultParameters$inboundSchema,
  DefaultParameters$Outbound,
  DefaultParameters$outboundSchema,
} from "./defaultparameters.js";
import { SDKValidationError } from "./errors/sdkvalidationerror.js";
import {
  ModelArchitecture,
  ModelArchitecture$inboundSchema,
  ModelArchitecture$Outbound,
  ModelArchitecture$outboundSchema,
} from "./modelarchitecture.js";
import {
  Parameter,
  Parameter$inboundSchema,
  Parameter$outboundSchema,
} from "./parameter.js";
import {
  TopProviderInfo,
  TopProviderInfo$inboundSchema,
  TopProviderInfo$Outbound,
  TopProviderInfo$outboundSchema,
} from "./topproviderinfo.js";

export type ModelPrompt = number | string | any;

export type ModelCompletion = number | string | any;

export type ModelRequest = number | string | any;

export type ModelImage = number | string | any;

export type ModelImageOutput = number | string | any;

export type ModelAudio = number | string | any;

export type ModelInputAudioCache = number | string | any;

export type ModelWebSearch = number | string | any;

export type ModelInternalReasoning = number | string | any;

export type ModelInputCacheRead = number | string | any;

export type ModelInputCacheWrite = number | string | any;

/**
 * Pricing information for the model
 */
export type ModelPricing = {
  prompt?: number | string | any | undefined;
  completion?: number | string | any | undefined;
  request?: number | string | any | undefined;
  image?: number | string | any | undefined;
  imageOutput?: number | string | any | undefined;
  audio?: number | string | any | undefined;
  inputAudioCache?: number | string | any | undefined;
  webSearch?: number | string | any | undefined;
  internalReasoning?: number | string | any | undefined;
  inputCacheRead?: number | string | any | undefined;
  inputCacheWrite?: number | string | any | undefined;
  discount?: number | undefined;
};

/**
 * Per-request token limits
 */
export type PerRequestLimits = {
  /**
   * Maximum prompt tokens per request
   */
  promptTokens?: any | undefined;
  /**
   * Maximum completion tokens per request
   */
  completionTokens?: any | undefined;
};

/**
 * Information about an AI model available on OpenRouter
 */
export type Model = {
  /**
   * Unique identifier for the model
   */
  id: string;
  /**
   * Canonical slug for the model
   */
  canonicalSlug: string;
  /**
   * Hugging Face model identifier, if applicable
   */
  huggingFaceId?: string | null | undefined;
  /**
   * Display name of the model
   */
  name: string;
  /**
   * Unix timestamp of when the model was created
   */
  created: number;
  /**
   * Description of the model
   */
  description?: string | undefined;
  /**
   * Pricing information for the model
   */
  pricing: ModelPricing;
  /**
   * Maximum context length in tokens
   */
  contextLength: number | null;
  /**
   * Model architecture information
   */
  architecture: ModelArchitecture;
  /**
   * Information about the top provider for this model
   */
  topProvider: TopProviderInfo;
  /**
   * Per-request token limits
   */
  perRequestLimits: PerRequestLimits | null;
  /**
   * List of supported parameters for this model
   */
  supportedParameters: Array<Parameter>;
  /**
   * Default parameters for this model
   */
  defaultParameters: DefaultParameters | null;
};

/** @internal */
export const ModelPrompt$inboundSchema: z.ZodType<
  ModelPrompt,
  z.ZodTypeDef,
  unknown
> = z.union([z.number(), z.string(), z.any()]);

/** @internal */
export type ModelPrompt$Outbound = number | string | any;

/** @internal */
export const ModelPrompt$outboundSchema: z.ZodType<
  ModelPrompt$Outbound,
  z.ZodTypeDef,
  ModelPrompt
> = z.union([z.number(), z.string(), z.any()]);

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace ModelPrompt$ {
  /** @deprecated use `ModelPrompt$inboundSchema` instead. */
  export const inboundSchema = ModelPrompt$inboundSchema;
  /** @deprecated use `ModelPrompt$outboundSchema` instead. */
  export const outboundSchema = ModelPrompt$outboundSchema;
  /** @deprecated use `ModelPrompt$Outbound` instead. */
  export type Outbound = ModelPrompt$Outbound;
}

export function modelPromptToJSON(modelPrompt: ModelPrompt): string {
  return JSON.stringify(ModelPrompt$outboundSchema.parse(modelPrompt));
}

export function modelPromptFromJSON(
  jsonString: string,
): SafeParseResult<ModelPrompt, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => ModelPrompt$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'ModelPrompt' from JSON`,
  );
}

/** @internal */
export const ModelCompletion$inboundSchema: z.ZodType<
  ModelCompletion,
  z.ZodTypeDef,
  unknown
> = z.union([z.number(), z.string(), z.any()]);

/** @internal */
export type ModelCompletion$Outbound = number | string | any;

/** @internal */
export const ModelCompletion$outboundSchema: z.ZodType<
  ModelCompletion$Outbound,
  z.ZodTypeDef,
  ModelCompletion
> = z.union([z.number(), z.string(), z.any()]);

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace ModelCompletion$ {
  /** @deprecated use `ModelCompletion$inboundSchema` instead. */
  export const inboundSchema = ModelCompletion$inboundSchema;
  /** @deprecated use `ModelCompletion$outboundSchema` instead. */
  export const outboundSchema = ModelCompletion$outboundSchema;
  /** @deprecated use `ModelCompletion$Outbound` instead. */
  export type Outbound = ModelCompletion$Outbound;
}

export function modelCompletionToJSON(
  modelCompletion: ModelCompletion,
): string {
  return JSON.stringify(ModelCompletion$outboundSchema.parse(modelCompletion));
}

export function modelCompletionFromJSON(
  jsonString: string,
): SafeParseResult<ModelCompletion, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => ModelCompletion$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'ModelCompletion' from JSON`,
  );
}

/** @internal */
export const ModelRequest$inboundSchema: z.ZodType<
  ModelRequest,
  z.ZodTypeDef,
  unknown
> = z.union([z.number(), z.string(), z.any()]);

/** @internal */
export type ModelRequest$Outbound = number | string | any;

/** @internal */
export const ModelRequest$outboundSchema: z.ZodType<
  ModelRequest$Outbound,
  z.ZodTypeDef,
  ModelRequest
> = z.union([z.number(), z.string(), z.any()]);

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace ModelRequest$ {
  /** @deprecated use `ModelRequest$inboundSchema` instead. */
  export const inboundSchema = ModelRequest$inboundSchema;
  /** @deprecated use `ModelRequest$outboundSchema` instead. */
  export const outboundSchema = ModelRequest$outboundSchema;
  /** @deprecated use `ModelRequest$Outbound` instead. */
  export type Outbound = ModelRequest$Outbound;
}

export function modelRequestToJSON(modelRequest: ModelRequest): string {
  return JSON.stringify(ModelRequest$outboundSchema.parse(modelRequest));
}

export function modelRequestFromJSON(
  jsonString: string,
): SafeParseResult<ModelRequest, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => ModelRequest$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'ModelRequest' from JSON`,
  );
}

/** @internal */
export const ModelImage$inboundSchema: z.ZodType<
  ModelImage,
  z.ZodTypeDef,
  unknown
> = z.union([z.number(), z.string(), z.any()]);

/** @internal */
export type ModelImage$Outbound = number | string | any;

/** @internal */
export const ModelImage$outboundSchema: z.ZodType<
  ModelImage$Outbound,
  z.ZodTypeDef,
  ModelImage
> = z.union([z.number(), z.string(), z.any()]);

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace ModelImage$ {
  /** @deprecated use `ModelImage$inboundSchema` instead. */
  export const inboundSchema = ModelImage$inboundSchema;
  /** @deprecated use `ModelImage$outboundSchema` instead. */
  export const outboundSchema = ModelImage$outboundSchema;
  /** @deprecated use `ModelImage$Outbound` instead. */
  export type Outbound = ModelImage$Outbound;
}

export function modelImageToJSON(modelImage: ModelImage): string {
  return JSON.stringify(ModelImage$outboundSchema.parse(modelImage));
}

export function modelImageFromJSON(
  jsonString: string,
): SafeParseResult<ModelImage, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => ModelImage$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'ModelImage' from JSON`,
  );
}

/** @internal */
export const ModelImageOutput$inboundSchema: z.ZodType<
  ModelImageOutput,
  z.ZodTypeDef,
  unknown
> = z.union([z.number(), z.string(), z.any()]);

/** @internal */
export type ModelImageOutput$Outbound = number | string | any;

/** @internal */
export const ModelImageOutput$outboundSchema: z.ZodType<
  ModelImageOutput$Outbound,
  z.ZodTypeDef,
  ModelImageOutput
> = z.union([z.number(), z.string(), z.any()]);

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace ModelImageOutput$ {
  /** @deprecated use `ModelImageOutput$inboundSchema` instead. */
  export const inboundSchema = ModelImageOutput$inboundSchema;
  /** @deprecated use `ModelImageOutput$outboundSchema` instead. */
  export const outboundSchema = ModelImageOutput$outboundSchema;
  /** @deprecated use `ModelImageOutput$Outbound` instead. */
  export type Outbound = ModelImageOutput$Outbound;
}

export function modelImageOutputToJSON(
  modelImageOutput: ModelImageOutput,
): string {
  return JSON.stringify(
    ModelImageOutput$outboundSchema.parse(modelImageOutput),
  );
}

export function modelImageOutputFromJSON(
  jsonString: string,
): SafeParseResult<ModelImageOutput, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => ModelImageOutput$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'ModelImageOutput' from JSON`,
  );
}

/** @internal */
export const ModelAudio$inboundSchema: z.ZodType<
  ModelAudio,
  z.ZodTypeDef,
  unknown
> = z.union([z.number(), z.string(), z.any()]);

/** @internal */
export type ModelAudio$Outbound = number | string | any;

/** @internal */
export const ModelAudio$outboundSchema: z.ZodType<
  ModelAudio$Outbound,
  z.ZodTypeDef,
  ModelAudio
> = z.union([z.number(), z.string(), z.any()]);

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace ModelAudio$ {
  /** @deprecated use `ModelAudio$inboundSchema` instead. */
  export const inboundSchema = ModelAudio$inboundSchema;
  /** @deprecated use `ModelAudio$outboundSchema` instead. */
  export const outboundSchema = ModelAudio$outboundSchema;
  /** @deprecated use `ModelAudio$Outbound` instead. */
  export type Outbound = ModelAudio$Outbound;
}

export function modelAudioToJSON(modelAudio: ModelAudio): string {
  return JSON.stringify(ModelAudio$outboundSchema.parse(modelAudio));
}

export function modelAudioFromJSON(
  jsonString: string,
): SafeParseResult<ModelAudio, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => ModelAudio$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'ModelAudio' from JSON`,
  );
}

/** @internal */
export const ModelInputAudioCache$inboundSchema: z.ZodType<
  ModelInputAudioCache,
  z.ZodTypeDef,
  unknown
> = z.union([z.number(), z.string(), z.any()]);

/** @internal */
export type ModelInputAudioCache$Outbound = number | string | any;

/** @internal */
export const ModelInputAudioCache$outboundSchema: z.ZodType<
  ModelInputAudioCache$Outbound,
  z.ZodTypeDef,
  ModelInputAudioCache
> = z.union([z.number(), z.string(), z.any()]);

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace ModelInputAudioCache$ {
  /** @deprecated use `ModelInputAudioCache$inboundSchema` instead. */
  export const inboundSchema = ModelInputAudioCache$inboundSchema;
  /** @deprecated use `ModelInputAudioCache$outboundSchema` instead. */
  export const outboundSchema = ModelInputAudioCache$outboundSchema;
  /** @deprecated use `ModelInputAudioCache$Outbound` instead. */
  export type Outbound = ModelInputAudioCache$Outbound;
}

export function modelInputAudioCacheToJSON(
  modelInputAudioCache: ModelInputAudioCache,
): string {
  return JSON.stringify(
    ModelInputAudioCache$outboundSchema.parse(modelInputAudioCache),
  );
}

export function modelInputAudioCacheFromJSON(
  jsonString: string,
): SafeParseResult<ModelInputAudioCache, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => ModelInputAudioCache$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'ModelInputAudioCache' from JSON`,
  );
}

/** @internal */
export const ModelWebSearch$inboundSchema: z.ZodType<
  ModelWebSearch,
  z.ZodTypeDef,
  unknown
> = z.union([z.number(), z.string(), z.any()]);

/** @internal */
export type ModelWebSearch$Outbound = number | string | any;

/** @internal */
export const ModelWebSearch$outboundSchema: z.ZodType<
  ModelWebSearch$Outbound,
  z.ZodTypeDef,
  ModelWebSearch
> = z.union([z.number(), z.string(), z.any()]);

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace ModelWebSearch$ {
  /** @deprecated use `ModelWebSearch$inboundSchema` instead. */
  export const inboundSchema = ModelWebSearch$inboundSchema;
  /** @deprecated use `ModelWebSearch$outboundSchema` instead. */
  export const outboundSchema = ModelWebSearch$outboundSchema;
  /** @deprecated use `ModelWebSearch$Outbound` instead. */
  export type Outbound = ModelWebSearch$Outbound;
}

export function modelWebSearchToJSON(modelWebSearch: ModelWebSearch): string {
  return JSON.stringify(ModelWebSearch$outboundSchema.parse(modelWebSearch));
}

export function modelWebSearchFromJSON(
  jsonString: string,
): SafeParseResult<ModelWebSearch, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => ModelWebSearch$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'ModelWebSearch' from JSON`,
  );
}

/** @internal */
export const ModelInternalReasoning$inboundSchema: z.ZodType<
  ModelInternalReasoning,
  z.ZodTypeDef,
  unknown
> = z.union([z.number(), z.string(), z.any()]);

/** @internal */
export type ModelInternalReasoning$Outbound = number | string | any;

/** @internal */
export const ModelInternalReasoning$outboundSchema: z.ZodType<
  ModelInternalReasoning$Outbound,
  z.ZodTypeDef,
  ModelInternalReasoning
> = z.union([z.number(), z.string(), z.any()]);

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace ModelInternalReasoning$ {
  /** @deprecated use `ModelInternalReasoning$inboundSchema` instead. */
  export const inboundSchema = ModelInternalReasoning$inboundSchema;
  /** @deprecated use `ModelInternalReasoning$outboundSchema` instead. */
  export const outboundSchema = ModelInternalReasoning$outboundSchema;
  /** @deprecated use `ModelInternalReasoning$Outbound` instead. */
  export type Outbound = ModelInternalReasoning$Outbound;
}

export function modelInternalReasoningToJSON(
  modelInternalReasoning: ModelInternalReasoning,
): string {
  return JSON.stringify(
    ModelInternalReasoning$outboundSchema.parse(modelInternalReasoning),
  );
}

export function modelInternalReasoningFromJSON(
  jsonString: string,
): SafeParseResult<ModelInternalReasoning, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => ModelInternalReasoning$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'ModelInternalReasoning' from JSON`,
  );
}

/** @internal */
export const ModelInputCacheRead$inboundSchema: z.ZodType<
  ModelInputCacheRead,
  z.ZodTypeDef,
  unknown
> = z.union([z.number(), z.string(), z.any()]);

/** @internal */
export type ModelInputCacheRead$Outbound = number | string | any;

/** @internal */
export const ModelInputCacheRead$outboundSchema: z.ZodType<
  ModelInputCacheRead$Outbound,
  z.ZodTypeDef,
  ModelInputCacheRead
> = z.union([z.number(), z.string(), z.any()]);

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace ModelInputCacheRead$ {
  /** @deprecated use `ModelInputCacheRead$inboundSchema` instead. */
  export const inboundSchema = ModelInputCacheRead$inboundSchema;
  /** @deprecated use `ModelInputCacheRead$outboundSchema` instead. */
  export const outboundSchema = ModelInputCacheRead$outboundSchema;
  /** @deprecated use `ModelInputCacheRead$Outbound` instead. */
  export type Outbound = ModelInputCacheRead$Outbound;
}

export function modelInputCacheReadToJSON(
  modelInputCacheRead: ModelInputCacheRead,
): string {
  return JSON.stringify(
    ModelInputCacheRead$outboundSchema.parse(modelInputCacheRead),
  );
}

export function modelInputCacheReadFromJSON(
  jsonString: string,
): SafeParseResult<ModelInputCacheRead, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => ModelInputCacheRead$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'ModelInputCacheRead' from JSON`,
  );
}

/** @internal */
export const ModelInputCacheWrite$inboundSchema: z.ZodType<
  ModelInputCacheWrite,
  z.ZodTypeDef,
  unknown
> = z.union([z.number(), z.string(), z.any()]);

/** @internal */
export type ModelInputCacheWrite$Outbound = number | string | any;

/** @internal */
export const ModelInputCacheWrite$outboundSchema: z.ZodType<
  ModelInputCacheWrite$Outbound,
  z.ZodTypeDef,
  ModelInputCacheWrite
> = z.union([z.number(), z.string(), z.any()]);

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace ModelInputCacheWrite$ {
  /** @deprecated use `ModelInputCacheWrite$inboundSchema` instead. */
  export const inboundSchema = ModelInputCacheWrite$inboundSchema;
  /** @deprecated use `ModelInputCacheWrite$outboundSchema` instead. */
  export const outboundSchema = ModelInputCacheWrite$outboundSchema;
  /** @deprecated use `ModelInputCacheWrite$Outbound` instead. */
  export type Outbound = ModelInputCacheWrite$Outbound;
}

export function modelInputCacheWriteToJSON(
  modelInputCacheWrite: ModelInputCacheWrite,
): string {
  return JSON.stringify(
    ModelInputCacheWrite$outboundSchema.parse(modelInputCacheWrite),
  );
}

export function modelInputCacheWriteFromJSON(
  jsonString: string,
): SafeParseResult<ModelInputCacheWrite, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => ModelInputCacheWrite$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'ModelInputCacheWrite' from JSON`,
  );
}

/** @internal */
export const ModelPricing$inboundSchema: z.ZodType<
  ModelPricing,
  z.ZodTypeDef,
  unknown
> = z.object({
  prompt: z.union([z.number(), z.string(), z.any()]).optional(),
  completion: z.union([z.number(), z.string(), z.any()]).optional(),
  request: z.union([z.number(), z.string(), z.any()]).optional(),
  image: z.union([z.number(), z.string(), z.any()]).optional(),
  image_output: z.union([z.number(), z.string(), z.any()]).optional(),
  audio: z.union([z.number(), z.string(), z.any()]).optional(),
  input_audio_cache: z.union([z.number(), z.string(), z.any()]).optional(),
  web_search: z.union([z.number(), z.string(), z.any()]).optional(),
  internal_reasoning: z.union([z.number(), z.string(), z.any()]).optional(),
  input_cache_read: z.union([z.number(), z.string(), z.any()]).optional(),
  input_cache_write: z.union([z.number(), z.string(), z.any()]).optional(),
  discount: z.number().optional(),
}).transform((v) => {
  return remap$(v, {
    "image_output": "imageOutput",
    "input_audio_cache": "inputAudioCache",
    "web_search": "webSearch",
    "internal_reasoning": "internalReasoning",
    "input_cache_read": "inputCacheRead",
    "input_cache_write": "inputCacheWrite",
  });
});

/** @internal */
export type ModelPricing$Outbound = {
  prompt?: number | string | any | undefined;
  completion?: number | string | any | undefined;
  request?: number | string | any | undefined;
  image?: number | string | any | undefined;
  image_output?: number | string | any | undefined;
  audio?: number | string | any | undefined;
  input_audio_cache?: number | string | any | undefined;
  web_search?: number | string | any | undefined;
  internal_reasoning?: number | string | any | undefined;
  input_cache_read?: number | string | any | undefined;
  input_cache_write?: number | string | any | undefined;
  discount?: number | undefined;
};

/** @internal */
export const ModelPricing$outboundSchema: z.ZodType<
  ModelPricing$Outbound,
  z.ZodTypeDef,
  ModelPricing
> = z.object({
  prompt: z.union([z.number(), z.string(), z.any()]).optional(),
  completion: z.union([z.number(), z.string(), z.any()]).optional(),
  request: z.union([z.number(), z.string(), z.any()]).optional(),
  image: z.union([z.number(), z.string(), z.any()]).optional(),
  imageOutput: z.union([z.number(), z.string(), z.any()]).optional(),
  audio: z.union([z.number(), z.string(), z.any()]).optional(),
  inputAudioCache: z.union([z.number(), z.string(), z.any()]).optional(),
  webSearch: z.union([z.number(), z.string(), z.any()]).optional(),
  internalReasoning: z.union([z.number(), z.string(), z.any()]).optional(),
  inputCacheRead: z.union([z.number(), z.string(), z.any()]).optional(),
  inputCacheWrite: z.union([z.number(), z.string(), z.any()]).optional(),
  discount: z.number().optional(),
}).transform((v) => {
  return remap$(v, {
    imageOutput: "image_output",
    inputAudioCache: "input_audio_cache",
    webSearch: "web_search",
    internalReasoning: "internal_reasoning",
    inputCacheRead: "input_cache_read",
    inputCacheWrite: "input_cache_write",
  });
});

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace ModelPricing$ {
  /** @deprecated use `ModelPricing$inboundSchema` instead. */
  export const inboundSchema = ModelPricing$inboundSchema;
  /** @deprecated use `ModelPricing$outboundSchema` instead. */
  export const outboundSchema = ModelPricing$outboundSchema;
  /** @deprecated use `ModelPricing$Outbound` instead. */
  export type Outbound = ModelPricing$Outbound;
}

export function modelPricingToJSON(modelPricing: ModelPricing): string {
  return JSON.stringify(ModelPricing$outboundSchema.parse(modelPricing));
}

export function modelPricingFromJSON(
  jsonString: string,
): SafeParseResult<ModelPricing, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => ModelPricing$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'ModelPricing' from JSON`,
  );
}

/** @internal */
export const PerRequestLimits$inboundSchema: z.ZodType<
  PerRequestLimits,
  z.ZodTypeDef,
  unknown
> = z.object({
  prompt_tokens: z.any().optional(),
  completion_tokens: z.any().optional(),
}).transform((v) => {
  return remap$(v, {
    "prompt_tokens": "promptTokens",
    "completion_tokens": "completionTokens",
  });
});

/** @internal */
export type PerRequestLimits$Outbound = {
  prompt_tokens?: any | undefined;
  completion_tokens?: any | undefined;
};

/** @internal */
export const PerRequestLimits$outboundSchema: z.ZodType<
  PerRequestLimits$Outbound,
  z.ZodTypeDef,
  PerRequestLimits
> = z.object({
  promptTokens: z.any().optional(),
  completionTokens: z.any().optional(),
}).transform((v) => {
  return remap$(v, {
    promptTokens: "prompt_tokens",
    completionTokens: "completion_tokens",
  });
});

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace PerRequestLimits$ {
  /** @deprecated use `PerRequestLimits$inboundSchema` instead. */
  export const inboundSchema = PerRequestLimits$inboundSchema;
  /** @deprecated use `PerRequestLimits$outboundSchema` instead. */
  export const outboundSchema = PerRequestLimits$outboundSchema;
  /** @deprecated use `PerRequestLimits$Outbound` instead. */
  export type Outbound = PerRequestLimits$Outbound;
}

export function perRequestLimitsToJSON(
  perRequestLimits: PerRequestLimits,
): string {
  return JSON.stringify(
    PerRequestLimits$outboundSchema.parse(perRequestLimits),
  );
}

export function perRequestLimitsFromJSON(
  jsonString: string,
): SafeParseResult<PerRequestLimits, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => PerRequestLimits$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'PerRequestLimits' from JSON`,
  );
}

/** @internal */
export const Model$inboundSchema: z.ZodType<Model, z.ZodTypeDef, unknown> = z
  .object({
    id: z.string(),
    canonical_slug: z.string(),
    hugging_face_id: z.nullable(z.string()).optional(),
    name: z.string(),
    created: z.number(),
    description: z.string().optional(),
    pricing: z.lazy(() => ModelPricing$inboundSchema),
    context_length: z.nullable(z.number()),
    architecture: ModelArchitecture$inboundSchema,
    top_provider: TopProviderInfo$inboundSchema,
    per_request_limits: z.nullable(
      z.lazy(() => PerRequestLimits$inboundSchema),
    ),
    supported_parameters: z.array(Parameter$inboundSchema),
    default_parameters: z.nullable(DefaultParameters$inboundSchema),
  }).transform((v) => {
    return remap$(v, {
      "canonical_slug": "canonicalSlug",
      "hugging_face_id": "huggingFaceId",
      "context_length": "contextLength",
      "top_provider": "topProvider",
      "per_request_limits": "perRequestLimits",
      "supported_parameters": "supportedParameters",
      "default_parameters": "defaultParameters",
    });
  });

/** @internal */
export type Model$Outbound = {
  id: string;
  canonical_slug: string;
  hugging_face_id?: string | null | undefined;
  name: string;
  created: number;
  description?: string | undefined;
  pricing: ModelPricing$Outbound;
  context_length: number | null;
  architecture: ModelArchitecture$Outbound;
  top_provider: TopProviderInfo$Outbound;
  per_request_limits: PerRequestLimits$Outbound | null;
  supported_parameters: Array<string>;
  default_parameters: DefaultParameters$Outbound | null;
};

/** @internal */
export const Model$outboundSchema: z.ZodType<
  Model$Outbound,
  z.ZodTypeDef,
  Model
> = z.object({
  id: z.string(),
  canonicalSlug: z.string(),
  huggingFaceId: z.nullable(z.string()).optional(),
  name: z.string(),
  created: z.number(),
  description: z.string().optional(),
  pricing: z.lazy(() => ModelPricing$outboundSchema),
  contextLength: z.nullable(z.number()),
  architecture: ModelArchitecture$outboundSchema,
  topProvider: TopProviderInfo$outboundSchema,
  perRequestLimits: z.nullable(z.lazy(() => PerRequestLimits$outboundSchema)),
  supportedParameters: z.array(Parameter$outboundSchema),
  defaultParameters: z.nullable(DefaultParameters$outboundSchema),
}).transform((v) => {
  return remap$(v, {
    canonicalSlug: "canonical_slug",
    huggingFaceId: "hugging_face_id",
    contextLength: "context_length",
    topProvider: "top_provider",
    perRequestLimits: "per_request_limits",
    supportedParameters: "supported_parameters",
    defaultParameters: "default_parameters",
  });
});

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace Model$ {
  /** @deprecated use `Model$inboundSchema` instead. */
  export const inboundSchema = Model$inboundSchema;
  /** @deprecated use `Model$outboundSchema` instead. */
  export const outboundSchema = Model$outboundSchema;
  /** @deprecated use `Model$Outbound` instead. */
  export type Outbound = Model$Outbound;
}

export function modelToJSON(model: Model): string {
  return JSON.stringify(Model$outboundSchema.parse(model));
}

export function modelFromJSON(
  jsonString: string,
): SafeParseResult<Model, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => Model$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'Model' from JSON`,
  );
}
