/*
 * Code generated by Speakeasy (https://speakeasy.com). DO NOT EDIT.
 */

import * as z from "zod/v4";
import { remap as remap$ } from "../lib/primitives.js";
import * as openEnums from "../types/enums.js";
import { OpenEnum } from "../types/enums.js";
import {
  ResponseFormatJSONSchema,
  ResponseFormatJSONSchema$Outbound,
  ResponseFormatJSONSchema$outboundSchema,
} from "./responseformatjsonschema.js";
import {
  ResponseFormatTextGrammar,
  ResponseFormatTextGrammar$Outbound,
  ResponseFormatTextGrammar$outboundSchema,
} from "./responseformattextgrammar.js";
import {
  Schema0,
  Schema0$Outbound,
  Schema0$outboundSchema,
} from "./schema0.js";

export const CompletionCreateParamsPdfEngine = {
  MistralOcr: "mistral-ocr",
  PdfText: "pdf-text",
  Native: "native",
} as const;
export type CompletionCreateParamsPdfEngine = OpenEnum<
  typeof CompletionCreateParamsPdfEngine
>;

export type CompletionCreateParamsPdf = {
  engine?: CompletionCreateParamsPdfEngine | undefined;
};

export type CompletionCreateParamsPluginFileParser = {
  id: "file-parser";
  maxFiles?: number | undefined;
  pdf?: CompletionCreateParamsPdf | undefined;
};

export const CompletionCreateParamsEngine = {
  Native: "native",
  Exa: "exa",
} as const;
export type CompletionCreateParamsEngine = OpenEnum<
  typeof CompletionCreateParamsEngine
>;

export type CompletionCreateParamsPluginWeb = {
  id: "web";
  maxResults?: number | undefined;
  searchPrompt?: string | undefined;
  engine?: CompletionCreateParamsEngine | undefined;
};

export type CompletionCreateParamsPluginModeration = {
  id: "moderation";
};

export type CompletionCreateParamsPluginUnion =
  | CompletionCreateParamsPluginModeration
  | CompletionCreateParamsPluginWeb
  | CompletionCreateParamsPluginFileParser;

export const CompletionCreateParamsDataCollection = {
  Deny: "deny",
  Allow: "allow",
} as const;
export type CompletionCreateParamsDataCollection = OpenEnum<
  typeof CompletionCreateParamsDataCollection
>;

export const CompletionCreateParamsQuantizations = {
  Int4: "int4",
  Int8: "int8",
  Fp4: "fp4",
  Fp6: "fp6",
  Fp8: "fp8",
  Fp16: "fp16",
  Bf16: "bf16",
  Fp32: "fp32",
  Unknown: "unknown",
} as const;
export type CompletionCreateParamsQuantizations = OpenEnum<
  typeof CompletionCreateParamsQuantizations
>;

export const CompletionCreateParamsSort = {
  Price: "price",
  Throughput: "throughput",
  Latency: "latency",
} as const;
export type CompletionCreateParamsSort = OpenEnum<
  typeof CompletionCreateParamsSort
>;

/**
 * The object specifying the maximum price you want to pay for this request. USD price per million tokens, for prompt and completion.
 */
export type CompletionCreateParamsMaxPrice = {
  prompt?: any | undefined;
  completion?: any | undefined;
  image?: any | undefined;
  audio?: any | undefined;
  request?: any | undefined;
};

export type CompletionCreateParamsProvider = {
  /**
   * Whether to allow backup providers to serve requests
   *
   * @remarks
   * - true: (default) when the primary provider (or your custom providers in "order") is unavailable, use the next best provider.
   * - false: use only the primary/custom provider, and return the upstream error if it's unavailable.
   */
  allowFallbacks?: boolean | null | undefined;
  /**
   * Whether to filter providers to only those that support the parameters you've provided. If this setting is omitted or set to false, then providers will receive only the parameters they support, and ignore the rest.
   */
  requireParameters?: boolean | null | undefined;
  /**
   * Data collection setting. If no available model provider meets the requirement, your request will return an error.
   *
   * @remarks
   * - allow: (default) allow providers which store user data non-transiently and may train on it
   *
   * - deny: use only providers which do not collect user data.
   */
  dataCollection?: CompletionCreateParamsDataCollection | null | undefined;
  zdr?: boolean | null | undefined;
  enforceDistillableText?: boolean | null | undefined;
  /**
   * An ordered list of provider slugs. The router will attempt to use the first provider in the subset of this list that supports your requested model, and fall back to the next if it is unavailable. If no providers are available, the request will fail with an error message.
   */
  order?: Array<Schema0> | null | undefined;
  /**
   * List of provider slugs to allow. If provided, this list is merged with your account-wide allowed provider settings for this request.
   */
  only?: Array<Schema0> | null | undefined;
  /**
   * List of provider slugs to ignore. If provided, this list is merged with your account-wide ignored provider settings for this request.
   */
  ignore?: Array<Schema0> | null | undefined;
  /**
   * A list of quantization levels to filter the provider by.
   */
  quantizations?: Array<CompletionCreateParamsQuantizations> | null | undefined;
  /**
   * The sorting strategy to use for this request, if "order" is not specified. When set, no load balancing is performed.
   */
  sort?: CompletionCreateParamsSort | null | undefined;
  /**
   * The object specifying the maximum price you want to pay for this request. USD price per million tokens, for prompt and completion.
   */
  maxPrice?: CompletionCreateParamsMaxPrice | undefined;
};

export type Prompt =
  | string
  | Array<string>
  | Array<number>
  | Array<Array<number>>;

export type CompletionCreateParamsStop = string | Array<string>;

export type StreamOptions = {
  includeUsage?: boolean | null | undefined;
};

export type CompletionCreateParamsResponseFormatPython = {
  type: "python";
};

export type CompletionCreateParamsResponseFormatJSONObject = {
  type: "json_object";
};

export type CompletionCreateParamsResponseFormatText = {
  type: "text";
};

export type CompletionCreateParamsResponseFormatUnion =
  | ResponseFormatJSONSchema
  | ResponseFormatTextGrammar
  | CompletionCreateParamsResponseFormatText
  | CompletionCreateParamsResponseFormatJSONObject
  | CompletionCreateParamsResponseFormatPython;

export type CompletionCreateParams = {
  model?: string | undefined;
  models?: Array<string> | undefined;
  plugins?:
    | Array<
      | CompletionCreateParamsPluginModeration
      | CompletionCreateParamsPluginWeb
      | CompletionCreateParamsPluginFileParser
    >
    | undefined;
  provider?: CompletionCreateParamsProvider | null | undefined;
  prompt: string | Array<string> | Array<number> | Array<Array<number>>;
  bestOf?: number | null | undefined;
  echo?: boolean | null | undefined;
  frequencyPenalty?: number | null | undefined;
  logitBias?: { [k: string]: number } | null | undefined;
  logprobs?: number | null | undefined;
  maxTokens?: number | null | undefined;
  n?: number | null | undefined;
  presencePenalty?: number | null | undefined;
  seed?: number | null | undefined;
  stop?: string | Array<string> | null | undefined;
  stream?: boolean | undefined;
  streamOptions?: StreamOptions | null | undefined;
  suffix?: string | null | undefined;
  temperature?: number | null | undefined;
  topP?: number | null | undefined;
  user?: string | undefined;
  metadata?: { [k: string]: string } | null | undefined;
  responseFormat?:
    | ResponseFormatJSONSchema
    | ResponseFormatTextGrammar
    | CompletionCreateParamsResponseFormatText
    | CompletionCreateParamsResponseFormatJSONObject
    | CompletionCreateParamsResponseFormatPython
    | null
    | undefined;
};

/** @internal */
export const CompletionCreateParamsPdfEngine$outboundSchema: z.ZodType<
  string,
  CompletionCreateParamsPdfEngine
> = openEnums.outboundSchema(CompletionCreateParamsPdfEngine);

/** @internal */
export type CompletionCreateParamsPdf$Outbound = {
  engine?: string | undefined;
};

/** @internal */
export const CompletionCreateParamsPdf$outboundSchema: z.ZodType<
  CompletionCreateParamsPdf$Outbound,
  CompletionCreateParamsPdf
> = z.object({
  engine: CompletionCreateParamsPdfEngine$outboundSchema.optional(),
});

export function completionCreateParamsPdfToJSON(
  completionCreateParamsPdf: CompletionCreateParamsPdf,
): string {
  return JSON.stringify(
    CompletionCreateParamsPdf$outboundSchema.parse(completionCreateParamsPdf),
  );
}

/** @internal */
export type CompletionCreateParamsPluginFileParser$Outbound = {
  id: "file-parser";
  max_files?: number | undefined;
  pdf?: CompletionCreateParamsPdf$Outbound | undefined;
};

/** @internal */
export const CompletionCreateParamsPluginFileParser$outboundSchema: z.ZodType<
  CompletionCreateParamsPluginFileParser$Outbound,
  CompletionCreateParamsPluginFileParser
> = z.object({
  id: z.literal("file-parser"),
  maxFiles: z.number().optional(),
  pdf: z.lazy(() => CompletionCreateParamsPdf$outboundSchema).optional(),
}).transform((v) => {
  return remap$(v, {
    maxFiles: "max_files",
  });
});

export function completionCreateParamsPluginFileParserToJSON(
  completionCreateParamsPluginFileParser:
    CompletionCreateParamsPluginFileParser,
): string {
  return JSON.stringify(
    CompletionCreateParamsPluginFileParser$outboundSchema.parse(
      completionCreateParamsPluginFileParser,
    ),
  );
}

/** @internal */
export const CompletionCreateParamsEngine$outboundSchema: z.ZodType<
  string,
  CompletionCreateParamsEngine
> = openEnums.outboundSchema(CompletionCreateParamsEngine);

/** @internal */
export type CompletionCreateParamsPluginWeb$Outbound = {
  id: "web";
  max_results?: number | undefined;
  search_prompt?: string | undefined;
  engine?: string | undefined;
};

/** @internal */
export const CompletionCreateParamsPluginWeb$outboundSchema: z.ZodType<
  CompletionCreateParamsPluginWeb$Outbound,
  CompletionCreateParamsPluginWeb
> = z.object({
  id: z.literal("web"),
  maxResults: z.number().optional(),
  searchPrompt: z.string().optional(),
  engine: CompletionCreateParamsEngine$outboundSchema.optional(),
}).transform((v) => {
  return remap$(v, {
    maxResults: "max_results",
    searchPrompt: "search_prompt",
  });
});

export function completionCreateParamsPluginWebToJSON(
  completionCreateParamsPluginWeb: CompletionCreateParamsPluginWeb,
): string {
  return JSON.stringify(
    CompletionCreateParamsPluginWeb$outboundSchema.parse(
      completionCreateParamsPluginWeb,
    ),
  );
}

/** @internal */
export type CompletionCreateParamsPluginModeration$Outbound = {
  id: "moderation";
};

/** @internal */
export const CompletionCreateParamsPluginModeration$outboundSchema: z.ZodType<
  CompletionCreateParamsPluginModeration$Outbound,
  CompletionCreateParamsPluginModeration
> = z.object({
  id: z.literal("moderation"),
});

export function completionCreateParamsPluginModerationToJSON(
  completionCreateParamsPluginModeration:
    CompletionCreateParamsPluginModeration,
): string {
  return JSON.stringify(
    CompletionCreateParamsPluginModeration$outboundSchema.parse(
      completionCreateParamsPluginModeration,
    ),
  );
}

/** @internal */
export type CompletionCreateParamsPluginUnion$Outbound =
  | CompletionCreateParamsPluginModeration$Outbound
  | CompletionCreateParamsPluginWeb$Outbound
  | CompletionCreateParamsPluginFileParser$Outbound;

/** @internal */
export const CompletionCreateParamsPluginUnion$outboundSchema: z.ZodType<
  CompletionCreateParamsPluginUnion$Outbound,
  CompletionCreateParamsPluginUnion
> = z.union([
  z.lazy(() => CompletionCreateParamsPluginModeration$outboundSchema),
  z.lazy(() => CompletionCreateParamsPluginWeb$outboundSchema),
  z.lazy(() => CompletionCreateParamsPluginFileParser$outboundSchema),
]);

export function completionCreateParamsPluginUnionToJSON(
  completionCreateParamsPluginUnion: CompletionCreateParamsPluginUnion,
): string {
  return JSON.stringify(
    CompletionCreateParamsPluginUnion$outboundSchema.parse(
      completionCreateParamsPluginUnion,
    ),
  );
}

/** @internal */
export const CompletionCreateParamsDataCollection$outboundSchema: z.ZodType<
  string,
  CompletionCreateParamsDataCollection
> = openEnums.outboundSchema(CompletionCreateParamsDataCollection);

/** @internal */
export const CompletionCreateParamsQuantizations$outboundSchema: z.ZodType<
  string,
  CompletionCreateParamsQuantizations
> = openEnums.outboundSchema(CompletionCreateParamsQuantizations);

/** @internal */
export const CompletionCreateParamsSort$outboundSchema: z.ZodType<
  string,
  CompletionCreateParamsSort
> = openEnums.outboundSchema(CompletionCreateParamsSort);

/** @internal */
export type CompletionCreateParamsMaxPrice$Outbound = {
  prompt?: any | undefined;
  completion?: any | undefined;
  image?: any | undefined;
  audio?: any | undefined;
  request?: any | undefined;
};

/** @internal */
export const CompletionCreateParamsMaxPrice$outboundSchema: z.ZodType<
  CompletionCreateParamsMaxPrice$Outbound,
  CompletionCreateParamsMaxPrice
> = z.object({
  prompt: z.any().optional(),
  completion: z.any().optional(),
  image: z.any().optional(),
  audio: z.any().optional(),
  request: z.any().optional(),
});

export function completionCreateParamsMaxPriceToJSON(
  completionCreateParamsMaxPrice: CompletionCreateParamsMaxPrice,
): string {
  return JSON.stringify(
    CompletionCreateParamsMaxPrice$outboundSchema.parse(
      completionCreateParamsMaxPrice,
    ),
  );
}

/** @internal */
export type CompletionCreateParamsProvider$Outbound = {
  allow_fallbacks?: boolean | null | undefined;
  require_parameters?: boolean | null | undefined;
  data_collection?: string | null | undefined;
  zdr?: boolean | null | undefined;
  enforce_distillable_text?: boolean | null | undefined;
  order?: Array<Schema0$Outbound> | null | undefined;
  only?: Array<Schema0$Outbound> | null | undefined;
  ignore?: Array<Schema0$Outbound> | null | undefined;
  quantizations?: Array<string> | null | undefined;
  sort?: string | null | undefined;
  max_price?: CompletionCreateParamsMaxPrice$Outbound | undefined;
};

/** @internal */
export const CompletionCreateParamsProvider$outboundSchema: z.ZodType<
  CompletionCreateParamsProvider$Outbound,
  CompletionCreateParamsProvider
> = z.object({
  allowFallbacks: z.nullable(z.boolean()).optional(),
  requireParameters: z.nullable(z.boolean()).optional(),
  dataCollection: z.nullable(
    CompletionCreateParamsDataCollection$outboundSchema,
  ).optional(),
  zdr: z.nullable(z.boolean()).optional(),
  enforceDistillableText: z.nullable(z.boolean()).optional(),
  order: z.nullable(z.array(Schema0$outboundSchema)).optional(),
  only: z.nullable(z.array(Schema0$outboundSchema)).optional(),
  ignore: z.nullable(z.array(Schema0$outboundSchema)).optional(),
  quantizations: z.nullable(
    z.array(CompletionCreateParamsQuantizations$outboundSchema),
  ).optional(),
  sort: z.nullable(CompletionCreateParamsSort$outboundSchema).optional(),
  maxPrice: z.lazy(() => CompletionCreateParamsMaxPrice$outboundSchema)
    .optional(),
}).transform((v) => {
  return remap$(v, {
    allowFallbacks: "allow_fallbacks",
    requireParameters: "require_parameters",
    dataCollection: "data_collection",
    enforceDistillableText: "enforce_distillable_text",
    maxPrice: "max_price",
  });
});

export function completionCreateParamsProviderToJSON(
  completionCreateParamsProvider: CompletionCreateParamsProvider,
): string {
  return JSON.stringify(
    CompletionCreateParamsProvider$outboundSchema.parse(
      completionCreateParamsProvider,
    ),
  );
}

/** @internal */
export type Prompt$Outbound =
  | string
  | Array<string>
  | Array<number>
  | Array<Array<number>>;

/** @internal */
export const Prompt$outboundSchema: z.ZodType<Prompt$Outbound, Prompt> = z
  .union([
    z.string(),
    z.array(z.string()),
    z.array(z.number()),
    z.array(z.array(z.number())),
  ]);

export function promptToJSON(prompt: Prompt): string {
  return JSON.stringify(Prompt$outboundSchema.parse(prompt));
}

/** @internal */
export type CompletionCreateParamsStop$Outbound = string | Array<string>;

/** @internal */
export const CompletionCreateParamsStop$outboundSchema: z.ZodType<
  CompletionCreateParamsStop$Outbound,
  CompletionCreateParamsStop
> = z.union([z.string(), z.array(z.string())]);

export function completionCreateParamsStopToJSON(
  completionCreateParamsStop: CompletionCreateParamsStop,
): string {
  return JSON.stringify(
    CompletionCreateParamsStop$outboundSchema.parse(completionCreateParamsStop),
  );
}

/** @internal */
export type StreamOptions$Outbound = {
  include_usage?: boolean | null | undefined;
};

/** @internal */
export const StreamOptions$outboundSchema: z.ZodType<
  StreamOptions$Outbound,
  StreamOptions
> = z.object({
  includeUsage: z.nullable(z.boolean()).optional(),
}).transform((v) => {
  return remap$(v, {
    includeUsage: "include_usage",
  });
});

export function streamOptionsToJSON(streamOptions: StreamOptions): string {
  return JSON.stringify(StreamOptions$outboundSchema.parse(streamOptions));
}

/** @internal */
export type CompletionCreateParamsResponseFormatPython$Outbound = {
  type: "python";
};

/** @internal */
export const CompletionCreateParamsResponseFormatPython$outboundSchema:
  z.ZodType<
    CompletionCreateParamsResponseFormatPython$Outbound,
    CompletionCreateParamsResponseFormatPython
  > = z.object({
    type: z.literal("python"),
  });

export function completionCreateParamsResponseFormatPythonToJSON(
  completionCreateParamsResponseFormatPython:
    CompletionCreateParamsResponseFormatPython,
): string {
  return JSON.stringify(
    CompletionCreateParamsResponseFormatPython$outboundSchema.parse(
      completionCreateParamsResponseFormatPython,
    ),
  );
}

/** @internal */
export type CompletionCreateParamsResponseFormatJSONObject$Outbound = {
  type: "json_object";
};

/** @internal */
export const CompletionCreateParamsResponseFormatJSONObject$outboundSchema:
  z.ZodType<
    CompletionCreateParamsResponseFormatJSONObject$Outbound,
    CompletionCreateParamsResponseFormatJSONObject
  > = z.object({
    type: z.literal("json_object"),
  });

export function completionCreateParamsResponseFormatJSONObjectToJSON(
  completionCreateParamsResponseFormatJSONObject:
    CompletionCreateParamsResponseFormatJSONObject,
): string {
  return JSON.stringify(
    CompletionCreateParamsResponseFormatJSONObject$outboundSchema.parse(
      completionCreateParamsResponseFormatJSONObject,
    ),
  );
}

/** @internal */
export type CompletionCreateParamsResponseFormatText$Outbound = {
  type: "text";
};

/** @internal */
export const CompletionCreateParamsResponseFormatText$outboundSchema: z.ZodType<
  CompletionCreateParamsResponseFormatText$Outbound,
  CompletionCreateParamsResponseFormatText
> = z.object({
  type: z.literal("text"),
});

export function completionCreateParamsResponseFormatTextToJSON(
  completionCreateParamsResponseFormatText:
    CompletionCreateParamsResponseFormatText,
): string {
  return JSON.stringify(
    CompletionCreateParamsResponseFormatText$outboundSchema.parse(
      completionCreateParamsResponseFormatText,
    ),
  );
}

/** @internal */
export type CompletionCreateParamsResponseFormatUnion$Outbound =
  | ResponseFormatJSONSchema$Outbound
  | ResponseFormatTextGrammar$Outbound
  | CompletionCreateParamsResponseFormatText$Outbound
  | CompletionCreateParamsResponseFormatJSONObject$Outbound
  | CompletionCreateParamsResponseFormatPython$Outbound;

/** @internal */
export const CompletionCreateParamsResponseFormatUnion$outboundSchema:
  z.ZodType<
    CompletionCreateParamsResponseFormatUnion$Outbound,
    CompletionCreateParamsResponseFormatUnion
  > = z.union([
    ResponseFormatJSONSchema$outboundSchema,
    ResponseFormatTextGrammar$outboundSchema,
    z.lazy(() => CompletionCreateParamsResponseFormatText$outboundSchema),
    z.lazy(() => CompletionCreateParamsResponseFormatJSONObject$outboundSchema),
    z.lazy(() => CompletionCreateParamsResponseFormatPython$outboundSchema),
  ]);

export function completionCreateParamsResponseFormatUnionToJSON(
  completionCreateParamsResponseFormatUnion:
    CompletionCreateParamsResponseFormatUnion,
): string {
  return JSON.stringify(
    CompletionCreateParamsResponseFormatUnion$outboundSchema.parse(
      completionCreateParamsResponseFormatUnion,
    ),
  );
}

/** @internal */
export type CompletionCreateParams$Outbound = {
  model?: string | undefined;
  models?: Array<string> | undefined;
  plugins?:
    | Array<
      | CompletionCreateParamsPluginModeration$Outbound
      | CompletionCreateParamsPluginWeb$Outbound
      | CompletionCreateParamsPluginFileParser$Outbound
    >
    | undefined;
  provider?: CompletionCreateParamsProvider$Outbound | null | undefined;
  prompt: string | Array<string> | Array<number> | Array<Array<number>>;
  best_of?: number | null | undefined;
  echo?: boolean | null | undefined;
  frequency_penalty?: number | null | undefined;
  logit_bias?: { [k: string]: number } | null | undefined;
  logprobs?: number | null | undefined;
  max_tokens?: number | null | undefined;
  n?: number | null | undefined;
  presence_penalty?: number | null | undefined;
  seed?: number | null | undefined;
  stop?: string | Array<string> | null | undefined;
  stream: boolean;
  stream_options?: StreamOptions$Outbound | null | undefined;
  suffix?: string | null | undefined;
  temperature?: number | null | undefined;
  top_p?: number | null | undefined;
  user?: string | undefined;
  metadata?: { [k: string]: string } | null | undefined;
  response_format?:
    | ResponseFormatJSONSchema$Outbound
    | ResponseFormatTextGrammar$Outbound
    | CompletionCreateParamsResponseFormatText$Outbound
    | CompletionCreateParamsResponseFormatJSONObject$Outbound
    | CompletionCreateParamsResponseFormatPython$Outbound
    | null
    | undefined;
};

/** @internal */
export const CompletionCreateParams$outboundSchema: z.ZodType<
  CompletionCreateParams$Outbound,
  CompletionCreateParams
> = z.object({
  model: z.string().optional(),
  models: z.array(z.string()).optional(),
  plugins: z.array(
    z.union([
      z.lazy(() => CompletionCreateParamsPluginModeration$outboundSchema),
      z.lazy(() => CompletionCreateParamsPluginWeb$outboundSchema),
      z.lazy(() => CompletionCreateParamsPluginFileParser$outboundSchema),
    ]),
  ).optional(),
  provider: z.nullable(
    z.lazy(() => CompletionCreateParamsProvider$outboundSchema),
  ).optional(),
  prompt: z.union([
    z.string(),
    z.array(z.string()),
    z.array(z.number()),
    z.array(z.array(z.number())),
  ]),
  bestOf: z.nullable(z.int()).optional(),
  echo: z.nullable(z.boolean()).optional(),
  frequencyPenalty: z.nullable(z.number()).optional(),
  logitBias: z.nullable(z.record(z.string(), z.number())).optional(),
  logprobs: z.nullable(z.int()).optional(),
  maxTokens: z.nullable(z.int()).optional(),
  n: z.nullable(z.int()).optional(),
  presencePenalty: z.nullable(z.number()).optional(),
  seed: z.nullable(z.int()).optional(),
  stop: z.nullable(z.union([z.string(), z.array(z.string())])).optional(),
  stream: z.boolean().default(false),
  streamOptions: z.nullable(z.lazy(() => StreamOptions$outboundSchema))
    .optional(),
  suffix: z.nullable(z.string()).optional(),
  temperature: z.nullable(z.number()).optional(),
  topP: z.nullable(z.number()).optional(),
  user: z.string().optional(),
  metadata: z.nullable(z.record(z.string(), z.string())).optional(),
  responseFormat: z.nullable(
    z.union([
      ResponseFormatJSONSchema$outboundSchema,
      ResponseFormatTextGrammar$outboundSchema,
      z.lazy(() => CompletionCreateParamsResponseFormatText$outboundSchema),
      z.lazy(() =>
        CompletionCreateParamsResponseFormatJSONObject$outboundSchema
      ),
      z.lazy(() => CompletionCreateParamsResponseFormatPython$outboundSchema),
    ]),
  ).optional(),
}).transform((v) => {
  return remap$(v, {
    bestOf: "best_of",
    frequencyPenalty: "frequency_penalty",
    logitBias: "logit_bias",
    maxTokens: "max_tokens",
    presencePenalty: "presence_penalty",
    streamOptions: "stream_options",
    topP: "top_p",
    responseFormat: "response_format",
  });
});

export function completionCreateParamsToJSON(
  completionCreateParams: CompletionCreateParams,
): string {
  return JSON.stringify(
    CompletionCreateParams$outboundSchema.parse(completionCreateParams),
  );
}
