/*
 * Code generated by Speakeasy (https://speakeasy.com). DO NOT EDIT.
 */

import * as z from "zod";
import { remap as remap$ } from "../lib/primitives.js";
import { safeParse } from "../lib/schemas.js";
import {
  catchUnrecognizedEnum,
  ClosedEnum,
  OpenEnum,
  Unrecognized,
} from "../types/enums.js";
import { Result as SafeParseResult } from "../types/fp.js";
import { SDKValidationError } from "./errors/sdkvalidationerror.js";
import {
  OpenResponsesInput,
  OpenResponsesInput$inboundSchema,
  OpenResponsesInput$Outbound,
  OpenResponsesInput$outboundSchema,
} from "./openresponsesinput.js";
import {
  OpenResponsesPrompt,
  OpenResponsesPrompt$inboundSchema,
  OpenResponsesPrompt$Outbound,
  OpenResponsesPrompt$outboundSchema,
} from "./openresponsesprompt.js";
import {
  OpenResponsesReasoningConfig,
  OpenResponsesReasoningConfig$inboundSchema,
  OpenResponsesReasoningConfig$Outbound,
  OpenResponsesReasoningConfig$outboundSchema,
} from "./openresponsesreasoningconfig.js";
import {
  OpenResponsesTextConfig,
  OpenResponsesTextConfig$inboundSchema,
  OpenResponsesTextConfig$Outbound,
  OpenResponsesTextConfig$outboundSchema,
} from "./openresponsestextconfig.js";
import {
  OpenResponsesToolChoice,
  OpenResponsesToolChoice$inboundSchema,
  OpenResponsesToolChoice$Outbound,
  OpenResponsesToolChoice$outboundSchema,
} from "./openresponsestoolchoice.js";
import {
  OpenResponsesToolUnion,
  OpenResponsesToolUnion$inboundSchema,
  OpenResponsesToolUnion$Outbound,
  OpenResponsesToolUnion$outboundSchema,
} from "./openresponsestoolunion.js";
import {
  ResponsesErrorField,
  ResponsesErrorField$inboundSchema,
  ResponsesErrorField$Outbound,
  ResponsesErrorField$outboundSchema,
} from "./responseserrorfield.js";
import {
  ResponsesOutputItem,
  ResponsesOutputItem$inboundSchema,
  ResponsesOutputItem$Outbound,
  ResponsesOutputItem$outboundSchema,
} from "./responsesoutputitem.js";
import {
  ResponsesUsage,
  ResponsesUsage$inboundSchema,
  ResponsesUsage$Outbound,
  ResponsesUsage$outboundSchema,
} from "./responsesusage.js";

export const ObjectT = {
  Response: "response",
} as const;
export type ObjectT = ClosedEnum<typeof ObjectT>;

export const OpenResponsesNonStreamingResponseStatus = {
  Completed: "completed",
  Incomplete: "incomplete",
  InProgress: "in_progress",
  Failed: "failed",
  Cancelled: "cancelled",
  Queued: "queued",
} as const;
export type OpenResponsesNonStreamingResponseStatus = OpenEnum<
  typeof OpenResponsesNonStreamingResponseStatus
>;

export const Reason = {
  MaxOutputTokens: "max_output_tokens",
  ContentFilter: "content_filter",
} as const;
export type Reason = OpenEnum<typeof Reason>;

export type IncompleteDetails = {
  reason?: Reason | undefined;
};

export const ServiceTier = {
  Auto: "auto",
  Default: "default",
  Flex: "flex",
  Priority: "priority",
  Scale: "scale",
} as const;
export type ServiceTier = OpenEnum<typeof ServiceTier>;

export const Truncation = {
  Auto: "auto",
  Disabled: "disabled",
} as const;
export type Truncation = OpenEnum<typeof Truncation>;

/**
 * Complete non-streaming response from the Responses API
 */
export type OpenResponsesNonStreamingResponse = {
  id?: string | undefined;
  object: ObjectT;
  createdAt: number;
  model: string;
  status?: OpenResponsesNonStreamingResponseStatus | undefined;
  output: Array<ResponsesOutputItem>;
  user?: string | null | undefined;
  outputText?: string | undefined;
  promptCacheKey?: string | null | undefined;
  safetyIdentifier?: string | null | undefined;
  /**
   * Error information returned from the API
   */
  error: ResponsesErrorField | null;
  incompleteDetails: IncompleteDetails | null;
  /**
   * Token usage information for the response
   */
  usage?: ResponsesUsage | undefined;
  maxToolCalls?: number | null | undefined;
  topLogprobs?: number | undefined;
  maxOutputTokens?: number | null | undefined;
  temperature: number | null;
  topP: number | null;
  /**
   * Input for a response request - can be a string or array of items
   */
  instructions?: OpenResponsesInput | null | undefined;
  /**
   * Metadata key-value pairs for the request. Keys must be ≤64 characters and cannot contain brackets. Values must be ≤512 characters. Maximum 16 pairs allowed.
   */
  metadata: { [k: string]: string } | null;
  tools: Array<OpenResponsesToolUnion>;
  /**
   * Controls which tool the model should call
   */
  toolChoice: OpenResponsesToolChoice;
  parallelToolCalls: boolean;
  /**
   * Prompt template with variables for the response
   */
  prompt?: OpenResponsesPrompt | null | undefined;
  background?: boolean | null | undefined;
  previousResponseId?: string | null | undefined;
  /**
   * Configuration for reasoning mode in the response
   */
  reasoning?: OpenResponsesReasoningConfig | null | undefined;
  serviceTier?: ServiceTier | null | undefined;
  store?: boolean | undefined;
  truncation?: Truncation | null | undefined;
  /**
   * Text output configuration including format and verbosity
   */
  text?: OpenResponsesTextConfig | undefined;
};

/** @internal */
export const ObjectT$inboundSchema: z.ZodNativeEnum<typeof ObjectT> = z
  .nativeEnum(ObjectT);

/** @internal */
export const ObjectT$outboundSchema: z.ZodNativeEnum<typeof ObjectT> =
  ObjectT$inboundSchema;

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace ObjectT$ {
  /** @deprecated use `ObjectT$inboundSchema` instead. */
  export const inboundSchema = ObjectT$inboundSchema;
  /** @deprecated use `ObjectT$outboundSchema` instead. */
  export const outboundSchema = ObjectT$outboundSchema;
}

/** @internal */
export const OpenResponsesNonStreamingResponseStatus$inboundSchema: z.ZodType<
  OpenResponsesNonStreamingResponseStatus,
  z.ZodTypeDef,
  unknown
> = z
  .union([
    z.nativeEnum(OpenResponsesNonStreamingResponseStatus),
    z.string().transform(catchUnrecognizedEnum),
  ]);

/** @internal */
export const OpenResponsesNonStreamingResponseStatus$outboundSchema: z.ZodType<
  OpenResponsesNonStreamingResponseStatus,
  z.ZodTypeDef,
  OpenResponsesNonStreamingResponseStatus
> = z.union([
  z.nativeEnum(OpenResponsesNonStreamingResponseStatus),
  z.string().and(z.custom<Unrecognized<string>>()),
]);

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace OpenResponsesNonStreamingResponseStatus$ {
  /** @deprecated use `OpenResponsesNonStreamingResponseStatus$inboundSchema` instead. */
  export const inboundSchema =
    OpenResponsesNonStreamingResponseStatus$inboundSchema;
  /** @deprecated use `OpenResponsesNonStreamingResponseStatus$outboundSchema` instead. */
  export const outboundSchema =
    OpenResponsesNonStreamingResponseStatus$outboundSchema;
}

/** @internal */
export const Reason$inboundSchema: z.ZodType<Reason, z.ZodTypeDef, unknown> = z
  .union([
    z.nativeEnum(Reason),
    z.string().transform(catchUnrecognizedEnum),
  ]);

/** @internal */
export const Reason$outboundSchema: z.ZodType<Reason, z.ZodTypeDef, Reason> = z
  .union([
    z.nativeEnum(Reason),
    z.string().and(z.custom<Unrecognized<string>>()),
  ]);

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace Reason$ {
  /** @deprecated use `Reason$inboundSchema` instead. */
  export const inboundSchema = Reason$inboundSchema;
  /** @deprecated use `Reason$outboundSchema` instead. */
  export const outboundSchema = Reason$outboundSchema;
}

/** @internal */
export const IncompleteDetails$inboundSchema: z.ZodType<
  IncompleteDetails,
  z.ZodTypeDef,
  unknown
> = z.object({
  reason: Reason$inboundSchema.optional(),
});

/** @internal */
export type IncompleteDetails$Outbound = {
  reason?: string | undefined;
};

/** @internal */
export const IncompleteDetails$outboundSchema: z.ZodType<
  IncompleteDetails$Outbound,
  z.ZodTypeDef,
  IncompleteDetails
> = z.object({
  reason: Reason$outboundSchema.optional(),
});

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace IncompleteDetails$ {
  /** @deprecated use `IncompleteDetails$inboundSchema` instead. */
  export const inboundSchema = IncompleteDetails$inboundSchema;
  /** @deprecated use `IncompleteDetails$outboundSchema` instead. */
  export const outboundSchema = IncompleteDetails$outboundSchema;
  /** @deprecated use `IncompleteDetails$Outbound` instead. */
  export type Outbound = IncompleteDetails$Outbound;
}

export function incompleteDetailsToJSON(
  incompleteDetails: IncompleteDetails,
): string {
  return JSON.stringify(
    IncompleteDetails$outboundSchema.parse(incompleteDetails),
  );
}

export function incompleteDetailsFromJSON(
  jsonString: string,
): SafeParseResult<IncompleteDetails, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => IncompleteDetails$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'IncompleteDetails' from JSON`,
  );
}

/** @internal */
export const ServiceTier$inboundSchema: z.ZodType<
  ServiceTier,
  z.ZodTypeDef,
  unknown
> = z
  .union([
    z.nativeEnum(ServiceTier),
    z.string().transform(catchUnrecognizedEnum),
  ]);

/** @internal */
export const ServiceTier$outboundSchema: z.ZodType<
  ServiceTier,
  z.ZodTypeDef,
  ServiceTier
> = z.union([
  z.nativeEnum(ServiceTier),
  z.string().and(z.custom<Unrecognized<string>>()),
]);

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace ServiceTier$ {
  /** @deprecated use `ServiceTier$inboundSchema` instead. */
  export const inboundSchema = ServiceTier$inboundSchema;
  /** @deprecated use `ServiceTier$outboundSchema` instead. */
  export const outboundSchema = ServiceTier$outboundSchema;
}

/** @internal */
export const Truncation$inboundSchema: z.ZodType<
  Truncation,
  z.ZodTypeDef,
  unknown
> = z
  .union([
    z.nativeEnum(Truncation),
    z.string().transform(catchUnrecognizedEnum),
  ]);

/** @internal */
export const Truncation$outboundSchema: z.ZodType<
  Truncation,
  z.ZodTypeDef,
  Truncation
> = z.union([
  z.nativeEnum(Truncation),
  z.string().and(z.custom<Unrecognized<string>>()),
]);

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace Truncation$ {
  /** @deprecated use `Truncation$inboundSchema` instead. */
  export const inboundSchema = Truncation$inboundSchema;
  /** @deprecated use `Truncation$outboundSchema` instead. */
  export const outboundSchema = Truncation$outboundSchema;
}

/** @internal */
export const OpenResponsesNonStreamingResponse$inboundSchema: z.ZodType<
  OpenResponsesNonStreamingResponse,
  z.ZodTypeDef,
  unknown
> = z.object({
  id: z.string().optional(),
  object: ObjectT$inboundSchema,
  created_at: z.number(),
  model: z.string(),
  status: OpenResponsesNonStreamingResponseStatus$inboundSchema.optional(),
  output: z.array(ResponsesOutputItem$inboundSchema),
  user: z.nullable(z.string()).optional(),
  output_text: z.string().optional(),
  prompt_cache_key: z.nullable(z.string()).optional(),
  safety_identifier: z.nullable(z.string()).optional(),
  error: z.nullable(ResponsesErrorField$inboundSchema),
  incomplete_details: z.nullable(z.lazy(() => IncompleteDetails$inboundSchema)),
  usage: ResponsesUsage$inboundSchema.optional(),
  max_tool_calls: z.nullable(z.number()).optional(),
  top_logprobs: z.number().optional(),
  max_output_tokens: z.nullable(z.number()).optional(),
  temperature: z.nullable(z.number()),
  top_p: z.nullable(z.number()),
  instructions: z.nullable(OpenResponsesInput$inboundSchema).optional(),
  metadata: z.nullable(z.record(z.string())),
  tools: z.array(OpenResponsesToolUnion$inboundSchema),
  tool_choice: OpenResponsesToolChoice$inboundSchema,
  parallel_tool_calls: z.boolean(),
  prompt: z.nullable(OpenResponsesPrompt$inboundSchema).optional(),
  background: z.nullable(z.boolean()).optional(),
  previous_response_id: z.nullable(z.string()).optional(),
  reasoning: z.nullable(OpenResponsesReasoningConfig$inboundSchema).optional(),
  service_tier: z.nullable(ServiceTier$inboundSchema).optional(),
  store: z.boolean().optional(),
  truncation: z.nullable(Truncation$inboundSchema).optional(),
  text: OpenResponsesTextConfig$inboundSchema.optional(),
}).transform((v) => {
  return remap$(v, {
    "created_at": "createdAt",
    "output_text": "outputText",
    "prompt_cache_key": "promptCacheKey",
    "safety_identifier": "safetyIdentifier",
    "incomplete_details": "incompleteDetails",
    "max_tool_calls": "maxToolCalls",
    "top_logprobs": "topLogprobs",
    "max_output_tokens": "maxOutputTokens",
    "top_p": "topP",
    "tool_choice": "toolChoice",
    "parallel_tool_calls": "parallelToolCalls",
    "previous_response_id": "previousResponseId",
    "service_tier": "serviceTier",
  });
});

/** @internal */
export type OpenResponsesNonStreamingResponse$Outbound = {
  id?: string | undefined;
  object: string;
  created_at: number;
  model: string;
  status?: string | undefined;
  output: Array<ResponsesOutputItem$Outbound>;
  user?: string | null | undefined;
  output_text?: string | undefined;
  prompt_cache_key?: string | null | undefined;
  safety_identifier?: string | null | undefined;
  error: ResponsesErrorField$Outbound | null;
  incomplete_details: IncompleteDetails$Outbound | null;
  usage?: ResponsesUsage$Outbound | undefined;
  max_tool_calls?: number | null | undefined;
  top_logprobs?: number | undefined;
  max_output_tokens?: number | null | undefined;
  temperature: number | null;
  top_p: number | null;
  instructions?: OpenResponsesInput$Outbound | null | undefined;
  metadata: { [k: string]: string } | null;
  tools: Array<OpenResponsesToolUnion$Outbound>;
  tool_choice: OpenResponsesToolChoice$Outbound;
  parallel_tool_calls: boolean;
  prompt?: OpenResponsesPrompt$Outbound | null | undefined;
  background?: boolean | null | undefined;
  previous_response_id?: string | null | undefined;
  reasoning?: OpenResponsesReasoningConfig$Outbound | null | undefined;
  service_tier?: string | null | undefined;
  store?: boolean | undefined;
  truncation?: string | null | undefined;
  text?: OpenResponsesTextConfig$Outbound | undefined;
};

/** @internal */
export const OpenResponsesNonStreamingResponse$outboundSchema: z.ZodType<
  OpenResponsesNonStreamingResponse$Outbound,
  z.ZodTypeDef,
  OpenResponsesNonStreamingResponse
> = z.object({
  id: z.string().optional(),
  object: ObjectT$outboundSchema,
  createdAt: z.number(),
  model: z.string(),
  status: OpenResponsesNonStreamingResponseStatus$outboundSchema.optional(),
  output: z.array(ResponsesOutputItem$outboundSchema),
  user: z.nullable(z.string()).optional(),
  outputText: z.string().optional(),
  promptCacheKey: z.nullable(z.string()).optional(),
  safetyIdentifier: z.nullable(z.string()).optional(),
  error: z.nullable(ResponsesErrorField$outboundSchema),
  incompleteDetails: z.nullable(z.lazy(() => IncompleteDetails$outboundSchema)),
  usage: ResponsesUsage$outboundSchema.optional(),
  maxToolCalls: z.nullable(z.number()).optional(),
  topLogprobs: z.number().optional(),
  maxOutputTokens: z.nullable(z.number()).optional(),
  temperature: z.nullable(z.number()),
  topP: z.nullable(z.number()),
  instructions: z.nullable(OpenResponsesInput$outboundSchema).optional(),
  metadata: z.nullable(z.record(z.string())),
  tools: z.array(OpenResponsesToolUnion$outboundSchema),
  toolChoice: OpenResponsesToolChoice$outboundSchema,
  parallelToolCalls: z.boolean(),
  prompt: z.nullable(OpenResponsesPrompt$outboundSchema).optional(),
  background: z.nullable(z.boolean()).optional(),
  previousResponseId: z.nullable(z.string()).optional(),
  reasoning: z.nullable(OpenResponsesReasoningConfig$outboundSchema).optional(),
  serviceTier: z.nullable(ServiceTier$outboundSchema).optional(),
  store: z.boolean().optional(),
  truncation: z.nullable(Truncation$outboundSchema).optional(),
  text: OpenResponsesTextConfig$outboundSchema.optional(),
}).transform((v) => {
  return remap$(v, {
    createdAt: "created_at",
    outputText: "output_text",
    promptCacheKey: "prompt_cache_key",
    safetyIdentifier: "safety_identifier",
    incompleteDetails: "incomplete_details",
    maxToolCalls: "max_tool_calls",
    topLogprobs: "top_logprobs",
    maxOutputTokens: "max_output_tokens",
    topP: "top_p",
    toolChoice: "tool_choice",
    parallelToolCalls: "parallel_tool_calls",
    previousResponseId: "previous_response_id",
    serviceTier: "service_tier",
  });
});

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace OpenResponsesNonStreamingResponse$ {
  /** @deprecated use `OpenResponsesNonStreamingResponse$inboundSchema` instead. */
  export const inboundSchema = OpenResponsesNonStreamingResponse$inboundSchema;
  /** @deprecated use `OpenResponsesNonStreamingResponse$outboundSchema` instead. */
  export const outboundSchema =
    OpenResponsesNonStreamingResponse$outboundSchema;
  /** @deprecated use `OpenResponsesNonStreamingResponse$Outbound` instead. */
  export type Outbound = OpenResponsesNonStreamingResponse$Outbound;
}

export function openResponsesNonStreamingResponseToJSON(
  openResponsesNonStreamingResponse: OpenResponsesNonStreamingResponse,
): string {
  return JSON.stringify(
    OpenResponsesNonStreamingResponse$outboundSchema.parse(
      openResponsesNonStreamingResponse,
    ),
  );
}

export function openResponsesNonStreamingResponseFromJSON(
  jsonString: string,
): SafeParseResult<OpenResponsesNonStreamingResponse, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => OpenResponsesNonStreamingResponse$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'OpenResponsesNonStreamingResponse' from JSON`,
  );
}
