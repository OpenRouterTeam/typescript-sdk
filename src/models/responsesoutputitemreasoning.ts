/*
 * Code generated by Speakeasy (https://speakeasy.com). DO NOT EDIT.
 * @generated-id: 191f7f61ea84
 */

import type { ClosedEnum } from '../types/enums.js';
import type { Result as SafeParseResult } from '../types/fp.js';
import type { SDKValidationError } from './errors/sdkvalidationerror.js';
import type {
  ReasoningSummaryText,
  ReasoningSummaryText$Outbound,
} from './reasoningsummarytext.js';
import type {
  ReasoningTextContent,
  ReasoningTextContent$Outbound,
} from './reasoningtextcontent.js';

import * as z from 'zod/v4';
import { remap as remap$ } from '../lib/primitives.js';
import { safeParse } from '../lib/schemas.js';
import {
  ReasoningSummaryText$inboundSchema,
  ReasoningSummaryText$outboundSchema,
} from './reasoningsummarytext.js';
import {
  ReasoningTextContent$inboundSchema,
  ReasoningTextContent$outboundSchema,
} from './reasoningtextcontent.js';

export const ResponsesOutputItemReasoningType = {
  Reasoning: 'reasoning',
} as const;
export type ResponsesOutputItemReasoningType = ClosedEnum<typeof ResponsesOutputItemReasoningType>;

export const ResponsesOutputItemReasoningStatusInProgress = {
  InProgress: 'in_progress',
} as const;
export type ResponsesOutputItemReasoningStatusInProgress = ClosedEnum<
  typeof ResponsesOutputItemReasoningStatusInProgress
>;

export const ResponsesOutputItemReasoningStatusIncomplete = {
  Incomplete: 'incomplete',
} as const;
export type ResponsesOutputItemReasoningStatusIncomplete = ClosedEnum<
  typeof ResponsesOutputItemReasoningStatusIncomplete
>;

export const ResponsesOutputItemReasoningStatusCompleted = {
  Completed: 'completed',
} as const;
export type ResponsesOutputItemReasoningStatusCompleted = ClosedEnum<
  typeof ResponsesOutputItemReasoningStatusCompleted
>;

export type ResponsesOutputItemReasoningStatusUnion =
  | ResponsesOutputItemReasoningStatusCompleted
  | ResponsesOutputItemReasoningStatusIncomplete
  | ResponsesOutputItemReasoningStatusInProgress;

/**
 * An output item containing reasoning
 */
export type ResponsesOutputItemReasoning = {
  type: ResponsesOutputItemReasoningType;
  id: string;
  content?: Array<ReasoningTextContent> | undefined;
  summary: Array<ReasoningSummaryText>;
  encryptedContent?: string | null | undefined;
  status?:
    | ResponsesOutputItemReasoningStatusCompleted
    | ResponsesOutputItemReasoningStatusIncomplete
    | ResponsesOutputItemReasoningStatusInProgress
    | undefined;
};

/** @internal */
export const ResponsesOutputItemReasoningType$inboundSchema: z.ZodEnum<
  typeof ResponsesOutputItemReasoningType
> = z.enum(ResponsesOutputItemReasoningType);
/** @internal */
export const ResponsesOutputItemReasoningType$outboundSchema: z.ZodEnum<
  typeof ResponsesOutputItemReasoningType
> = ResponsesOutputItemReasoningType$inboundSchema;

/** @internal */
export const ResponsesOutputItemReasoningStatusInProgress$inboundSchema: z.ZodEnum<
  typeof ResponsesOutputItemReasoningStatusInProgress
> = z.enum(ResponsesOutputItemReasoningStatusInProgress);
/** @internal */
export const ResponsesOutputItemReasoningStatusInProgress$outboundSchema: z.ZodEnum<
  typeof ResponsesOutputItemReasoningStatusInProgress
> = ResponsesOutputItemReasoningStatusInProgress$inboundSchema;

/** @internal */
export const ResponsesOutputItemReasoningStatusIncomplete$inboundSchema: z.ZodEnum<
  typeof ResponsesOutputItemReasoningStatusIncomplete
> = z.enum(ResponsesOutputItemReasoningStatusIncomplete);
/** @internal */
export const ResponsesOutputItemReasoningStatusIncomplete$outboundSchema: z.ZodEnum<
  typeof ResponsesOutputItemReasoningStatusIncomplete
> = ResponsesOutputItemReasoningStatusIncomplete$inboundSchema;

/** @internal */
export const ResponsesOutputItemReasoningStatusCompleted$inboundSchema: z.ZodEnum<
  typeof ResponsesOutputItemReasoningStatusCompleted
> = z.enum(ResponsesOutputItemReasoningStatusCompleted);
/** @internal */
export const ResponsesOutputItemReasoningStatusCompleted$outboundSchema: z.ZodEnum<
  typeof ResponsesOutputItemReasoningStatusCompleted
> = ResponsesOutputItemReasoningStatusCompleted$inboundSchema;

/** @internal */
export const ResponsesOutputItemReasoningStatusUnion$inboundSchema: z.ZodType<
  ResponsesOutputItemReasoningStatusUnion,
  unknown
> = z.union([
  ResponsesOutputItemReasoningStatusCompleted$inboundSchema,
  ResponsesOutputItemReasoningStatusIncomplete$inboundSchema,
  ResponsesOutputItemReasoningStatusInProgress$inboundSchema,
]);
/** @internal */
export type ResponsesOutputItemReasoningStatusUnion$Outbound = string | string | string;

/** @internal */
export const ResponsesOutputItemReasoningStatusUnion$outboundSchema: z.ZodType<
  ResponsesOutputItemReasoningStatusUnion$Outbound,
  ResponsesOutputItemReasoningStatusUnion
> = z.union([
  ResponsesOutputItemReasoningStatusCompleted$outboundSchema,
  ResponsesOutputItemReasoningStatusIncomplete$outboundSchema,
  ResponsesOutputItemReasoningStatusInProgress$outboundSchema,
]);

export function responsesOutputItemReasoningStatusUnionToJSON(
  responsesOutputItemReasoningStatusUnion: ResponsesOutputItemReasoningStatusUnion,
): string {
  return JSON.stringify(
    ResponsesOutputItemReasoningStatusUnion$outboundSchema.parse(
      responsesOutputItemReasoningStatusUnion,
    ),
  );
}
export function responsesOutputItemReasoningStatusUnionFromJSON(
  jsonString: string,
): SafeParseResult<ResponsesOutputItemReasoningStatusUnion, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => ResponsesOutputItemReasoningStatusUnion$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'ResponsesOutputItemReasoningStatusUnion' from JSON`,
  );
}

/** @internal */
export const ResponsesOutputItemReasoning$inboundSchema: z.ZodType<
  ResponsesOutputItemReasoning,
  unknown
> = z
  .object({
    type: ResponsesOutputItemReasoningType$inboundSchema,
    id: z.string(),
    content: z.array(ReasoningTextContent$inboundSchema).optional(),
    summary: z.array(ReasoningSummaryText$inboundSchema),
    encrypted_content: z.nullable(z.string()).optional(),
    status: z
      .union([
        ResponsesOutputItemReasoningStatusCompleted$inboundSchema,
        ResponsesOutputItemReasoningStatusIncomplete$inboundSchema,
        ResponsesOutputItemReasoningStatusInProgress$inboundSchema,
      ])
      .optional(),
  })
  .transform((v) => {
    return remap$(v, {
      encrypted_content: 'encryptedContent',
    });
  });
/** @internal */
export type ResponsesOutputItemReasoning$Outbound = {
  type: string;
  id: string;
  content?: Array<ReasoningTextContent$Outbound> | undefined;
  summary: Array<ReasoningSummaryText$Outbound>;
  encrypted_content?: string | null | undefined;
  status?: string | string | string | undefined;
};

/** @internal */
export const ResponsesOutputItemReasoning$outboundSchema: z.ZodType<
  ResponsesOutputItemReasoning$Outbound,
  ResponsesOutputItemReasoning
> = z
  .object({
    type: ResponsesOutputItemReasoningType$outboundSchema,
    id: z.string(),
    content: z.array(ReasoningTextContent$outboundSchema).optional(),
    summary: z.array(ReasoningSummaryText$outboundSchema),
    encryptedContent: z.nullable(z.string()).optional(),
    status: z
      .union([
        ResponsesOutputItemReasoningStatusCompleted$outboundSchema,
        ResponsesOutputItemReasoningStatusIncomplete$outboundSchema,
        ResponsesOutputItemReasoningStatusInProgress$outboundSchema,
      ])
      .optional(),
  })
  .transform((v) => {
    return remap$(v, {
      encryptedContent: 'encrypted_content',
    });
  });

export function responsesOutputItemReasoningToJSON(
  responsesOutputItemReasoning: ResponsesOutputItemReasoning,
): string {
  return JSON.stringify(
    ResponsesOutputItemReasoning$outboundSchema.parse(responsesOutputItemReasoning),
  );
}
export function responsesOutputItemReasoningFromJSON(
  jsonString: string,
): SafeParseResult<ResponsesOutputItemReasoning, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => ResponsesOutputItemReasoning$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'ResponsesOutputItemReasoning' from JSON`,
  );
}
