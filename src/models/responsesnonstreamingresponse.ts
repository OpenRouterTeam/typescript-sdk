/*
 * Code generated by Speakeasy (https://speakeasy.com). DO NOT EDIT.
 */

import * as z from "zod";
import { remap as remap$ } from "../lib/primitives.js";
import { safeParse } from "../lib/schemas.js";
import { ClosedEnum } from "../types/enums.js";
import { Result as SafeParseResult } from "../types/fp.js";
import { SDKValidationError } from "./errors/sdkvalidationerror.js";
import {
  ResponseInputItem,
  ResponseInputItem$inboundSchema,
  ResponseInputItem$Outbound,
  ResponseInputItem$outboundSchema,
} from "./responseinputitem.js";
import {
  ResponsePrompt,
  ResponsePrompt$inboundSchema,
  ResponsePrompt$Outbound,
  ResponsePrompt$outboundSchema,
} from "./responseprompt.js";
import {
  ResponseReasoningConfig,
  ResponseReasoningConfig$inboundSchema,
  ResponseReasoningConfig$Outbound,
  ResponseReasoningConfig$outboundSchema,
} from "./responsereasoningconfig.js";
import {
  ResponsesIncompleteDetails,
  ResponsesIncompleteDetails$inboundSchema,
  ResponsesIncompleteDetails$Outbound,
  ResponsesIncompleteDetails$outboundSchema,
} from "./responsesincompletedetails.js";
import {
  ResponsesOutputItem,
  ResponsesOutputItem$inboundSchema,
  ResponsesOutputItem$Outbound,
  ResponsesOutputItem$outboundSchema,
} from "./responsesoutputitem.js";
import {
  ResponsesUsage,
  ResponsesUsage$inboundSchema,
  ResponsesUsage$Outbound,
  ResponsesUsage$outboundSchema,
} from "./responsesusage.js";
import {
  ResponseTextConfig,
  ResponseTextConfig$inboundSchema,
  ResponseTextConfig$Outbound,
  ResponseTextConfig$outboundSchema,
} from "./responsetextconfig.js";
import {
  Tool,
  Tool$inboundSchema,
  Tool$Outbound,
  Tool$outboundSchema,
} from "./tool.js";
import {
  ToolChoiceUnion,
  ToolChoiceUnion$inboundSchema,
  ToolChoiceUnion$Outbound,
  ToolChoiceUnion$outboundSchema,
} from "./toolchoiceunion.js";

export const ObjectT = {
  Response: "response",
} as const;
export type ObjectT = ClosedEnum<typeof ObjectT>;

export const ResponsesNonStreamingResponseStatus = {
  Completed: "completed",
  Incomplete: "incomplete",
  InProgress: "in_progress",
  Failed: "failed",
  Cancelled: "cancelled",
  Queued: "queued",
} as const;
export type ResponsesNonStreamingResponseStatus = ClosedEnum<
  typeof ResponsesNonStreamingResponseStatus
>;

export const ResponsesNonStreamingResponseCode = {
  ServerError: "server_error",
  RateLimitExceeded: "rate_limit_exceeded",
  InvalidPrompt: "invalid_prompt",
} as const;
export type ResponsesNonStreamingResponseCode = ClosedEnum<
  typeof ResponsesNonStreamingResponseCode
>;

export type ResponsesNonStreamingResponseError = {
  code: ResponsesNonStreamingResponseCode;
  message: string;
};

export type Instructions = string | Array<ResponseInputItem> | any;

export const ServiceTier = {
  Auto: "auto",
  Default: "default",
  Flex: "flex",
  Priority: "priority",
  Scale: "scale",
} as const;
export type ServiceTier = ClosedEnum<typeof ServiceTier>;

export const Truncation = {
  Auto: "auto",
  Disabled: "disabled",
} as const;
export type Truncation = ClosedEnum<typeof Truncation>;

/**
 * Non-streaming response from Responses API
 */
export type ResponsesNonStreamingResponse = {
  id: string;
  object: ObjectT;
  createdAt: number;
  model: string;
  status?: ResponsesNonStreamingResponseStatus | undefined;
  output: Array<ResponsesOutputItem>;
  user?: string | null | undefined;
  outputText?: string | undefined;
  promptCacheKey?: string | null | undefined;
  safetyIdentifier?: string | null | undefined;
  error: ResponsesNonStreamingResponseError | null;
  /**
   * Details about why response was incomplete
   */
  incompleteDetails: ResponsesIncompleteDetails | null;
  /**
   * Token usage statistics for Responses API
   */
  usage?: ResponsesUsage | undefined;
  maxToolCalls?: number | null | undefined;
  topLogprobs?: number | undefined;
  maxOutputTokens?: number | null | undefined;
  temperature: number | null;
  topP: number | null;
  instructions?: string | Array<ResponseInputItem> | any | null | undefined;
  /**
   * Metadata for Responses API requests (max 16 pairs, keys ≤64 chars, values ≤512 chars)
   */
  metadata: { [k: string]: string } | null;
  tools: Array<Tool>;
  /**
   * Tool choice configuration
   */
  toolChoice: ToolChoiceUnion;
  parallelToolCalls: boolean;
  /**
   * Prompt configuration with variables
   */
  prompt?: ResponsePrompt | null | undefined;
  background?: boolean | null | undefined;
  previousResponseId?: string | null | undefined;
  /**
   * Reasoning configuration for Responses API
   */
  reasoning?: ResponseReasoningConfig | null | undefined;
  serviceTier?: ServiceTier | null | undefined;
  store?: boolean | undefined;
  truncation?: Truncation | null | undefined;
  /**
   * Text configuration for Responses API
   */
  text?: ResponseTextConfig | undefined;
};

/** @internal */
export const ObjectT$inboundSchema: z.ZodNativeEnum<typeof ObjectT> = z
  .nativeEnum(ObjectT);

/** @internal */
export const ObjectT$outboundSchema: z.ZodNativeEnum<typeof ObjectT> =
  ObjectT$inboundSchema;

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace ObjectT$ {
  /** @deprecated use `ObjectT$inboundSchema` instead. */
  export const inboundSchema = ObjectT$inboundSchema;
  /** @deprecated use `ObjectT$outboundSchema` instead. */
  export const outboundSchema = ObjectT$outboundSchema;
}

/** @internal */
export const ResponsesNonStreamingResponseStatus$inboundSchema: z.ZodNativeEnum<
  typeof ResponsesNonStreamingResponseStatus
> = z.nativeEnum(ResponsesNonStreamingResponseStatus);

/** @internal */
export const ResponsesNonStreamingResponseStatus$outboundSchema:
  z.ZodNativeEnum<typeof ResponsesNonStreamingResponseStatus> =
    ResponsesNonStreamingResponseStatus$inboundSchema;

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace ResponsesNonStreamingResponseStatus$ {
  /** @deprecated use `ResponsesNonStreamingResponseStatus$inboundSchema` instead. */
  export const inboundSchema =
    ResponsesNonStreamingResponseStatus$inboundSchema;
  /** @deprecated use `ResponsesNonStreamingResponseStatus$outboundSchema` instead. */
  export const outboundSchema =
    ResponsesNonStreamingResponseStatus$outboundSchema;
}

/** @internal */
export const ResponsesNonStreamingResponseCode$inboundSchema: z.ZodNativeEnum<
  typeof ResponsesNonStreamingResponseCode
> = z.nativeEnum(ResponsesNonStreamingResponseCode);

/** @internal */
export const ResponsesNonStreamingResponseCode$outboundSchema: z.ZodNativeEnum<
  typeof ResponsesNonStreamingResponseCode
> = ResponsesNonStreamingResponseCode$inboundSchema;

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace ResponsesNonStreamingResponseCode$ {
  /** @deprecated use `ResponsesNonStreamingResponseCode$inboundSchema` instead. */
  export const inboundSchema = ResponsesNonStreamingResponseCode$inboundSchema;
  /** @deprecated use `ResponsesNonStreamingResponseCode$outboundSchema` instead. */
  export const outboundSchema =
    ResponsesNonStreamingResponseCode$outboundSchema;
}

/** @internal */
export const ResponsesNonStreamingResponseError$inboundSchema: z.ZodType<
  ResponsesNonStreamingResponseError,
  z.ZodTypeDef,
  unknown
> = z.object({
  code: ResponsesNonStreamingResponseCode$inboundSchema,
  message: z.string(),
});

/** @internal */
export type ResponsesNonStreamingResponseError$Outbound = {
  code: string;
  message: string;
};

/** @internal */
export const ResponsesNonStreamingResponseError$outboundSchema: z.ZodType<
  ResponsesNonStreamingResponseError$Outbound,
  z.ZodTypeDef,
  ResponsesNonStreamingResponseError
> = z.object({
  code: ResponsesNonStreamingResponseCode$outboundSchema,
  message: z.string(),
});

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace ResponsesNonStreamingResponseError$ {
  /** @deprecated use `ResponsesNonStreamingResponseError$inboundSchema` instead. */
  export const inboundSchema = ResponsesNonStreamingResponseError$inboundSchema;
  /** @deprecated use `ResponsesNonStreamingResponseError$outboundSchema` instead. */
  export const outboundSchema =
    ResponsesNonStreamingResponseError$outboundSchema;
  /** @deprecated use `ResponsesNonStreamingResponseError$Outbound` instead. */
  export type Outbound = ResponsesNonStreamingResponseError$Outbound;
}

export function responsesNonStreamingResponseErrorToJSON(
  responsesNonStreamingResponseError: ResponsesNonStreamingResponseError,
): string {
  return JSON.stringify(
    ResponsesNonStreamingResponseError$outboundSchema.parse(
      responsesNonStreamingResponseError,
    ),
  );
}

export function responsesNonStreamingResponseErrorFromJSON(
  jsonString: string,
): SafeParseResult<ResponsesNonStreamingResponseError, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) =>
      ResponsesNonStreamingResponseError$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'ResponsesNonStreamingResponseError' from JSON`,
  );
}

/** @internal */
export const Instructions$inboundSchema: z.ZodType<
  Instructions,
  z.ZodTypeDef,
  unknown
> = z.union([z.string(), z.array(ResponseInputItem$inboundSchema), z.any()]);

/** @internal */
export type Instructions$Outbound =
  | string
  | Array<ResponseInputItem$Outbound>
  | any;

/** @internal */
export const Instructions$outboundSchema: z.ZodType<
  Instructions$Outbound,
  z.ZodTypeDef,
  Instructions
> = z.union([z.string(), z.array(ResponseInputItem$outboundSchema), z.any()]);

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace Instructions$ {
  /** @deprecated use `Instructions$inboundSchema` instead. */
  export const inboundSchema = Instructions$inboundSchema;
  /** @deprecated use `Instructions$outboundSchema` instead. */
  export const outboundSchema = Instructions$outboundSchema;
  /** @deprecated use `Instructions$Outbound` instead. */
  export type Outbound = Instructions$Outbound;
}

export function instructionsToJSON(instructions: Instructions): string {
  return JSON.stringify(Instructions$outboundSchema.parse(instructions));
}

export function instructionsFromJSON(
  jsonString: string,
): SafeParseResult<Instructions, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => Instructions$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'Instructions' from JSON`,
  );
}

/** @internal */
export const ServiceTier$inboundSchema: z.ZodNativeEnum<typeof ServiceTier> = z
  .nativeEnum(ServiceTier);

/** @internal */
export const ServiceTier$outboundSchema: z.ZodNativeEnum<typeof ServiceTier> =
  ServiceTier$inboundSchema;

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace ServiceTier$ {
  /** @deprecated use `ServiceTier$inboundSchema` instead. */
  export const inboundSchema = ServiceTier$inboundSchema;
  /** @deprecated use `ServiceTier$outboundSchema` instead. */
  export const outboundSchema = ServiceTier$outboundSchema;
}

/** @internal */
export const Truncation$inboundSchema: z.ZodNativeEnum<typeof Truncation> = z
  .nativeEnum(Truncation);

/** @internal */
export const Truncation$outboundSchema: z.ZodNativeEnum<typeof Truncation> =
  Truncation$inboundSchema;

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace Truncation$ {
  /** @deprecated use `Truncation$inboundSchema` instead. */
  export const inboundSchema = Truncation$inboundSchema;
  /** @deprecated use `Truncation$outboundSchema` instead. */
  export const outboundSchema = Truncation$outboundSchema;
}

/** @internal */
export const ResponsesNonStreamingResponse$inboundSchema: z.ZodType<
  ResponsesNonStreamingResponse,
  z.ZodTypeDef,
  unknown
> = z.object({
  id: z.string(),
  object: ObjectT$inboundSchema,
  created_at: z.number(),
  model: z.string(),
  status: ResponsesNonStreamingResponseStatus$inboundSchema.optional(),
  output: z.array(ResponsesOutputItem$inboundSchema),
  user: z.nullable(z.string()).optional(),
  output_text: z.string().optional(),
  prompt_cache_key: z.nullable(z.string()).optional(),
  safety_identifier: z.nullable(z.string()).optional(),
  error: z.nullable(
    z.lazy(() => ResponsesNonStreamingResponseError$inboundSchema),
  ),
  incomplete_details: z.nullable(ResponsesIncompleteDetails$inboundSchema),
  usage: ResponsesUsage$inboundSchema.optional(),
  max_tool_calls: z.nullable(z.number()).optional(),
  top_logprobs: z.number().optional(),
  max_output_tokens: z.nullable(z.number()).optional(),
  temperature: z.nullable(z.number()),
  top_p: z.nullable(z.number()),
  instructions: z.nullable(
    z.union([z.string(), z.array(ResponseInputItem$inboundSchema), z.any()]),
  ).optional(),
  metadata: z.nullable(z.record(z.string())),
  tools: z.array(Tool$inboundSchema),
  tool_choice: ToolChoiceUnion$inboundSchema,
  parallel_tool_calls: z.boolean(),
  prompt: z.nullable(ResponsePrompt$inboundSchema).optional(),
  background: z.nullable(z.boolean()).optional(),
  previous_response_id: z.nullable(z.string()).optional(),
  reasoning: z.nullable(ResponseReasoningConfig$inboundSchema).optional(),
  service_tier: z.nullable(ServiceTier$inboundSchema).optional(),
  store: z.boolean().optional(),
  truncation: z.nullable(Truncation$inboundSchema).optional(),
  text: ResponseTextConfig$inboundSchema.optional(),
}).transform((v) => {
  return remap$(v, {
    "created_at": "createdAt",
    "output_text": "outputText",
    "prompt_cache_key": "promptCacheKey",
    "safety_identifier": "safetyIdentifier",
    "incomplete_details": "incompleteDetails",
    "max_tool_calls": "maxToolCalls",
    "top_logprobs": "topLogprobs",
    "max_output_tokens": "maxOutputTokens",
    "top_p": "topP",
    "tool_choice": "toolChoice",
    "parallel_tool_calls": "parallelToolCalls",
    "previous_response_id": "previousResponseId",
    "service_tier": "serviceTier",
  });
});

/** @internal */
export type ResponsesNonStreamingResponse$Outbound = {
  id: string;
  object: string;
  created_at: number;
  model: string;
  status?: string | undefined;
  output: Array<ResponsesOutputItem$Outbound>;
  user?: string | null | undefined;
  output_text?: string | undefined;
  prompt_cache_key?: string | null | undefined;
  safety_identifier?: string | null | undefined;
  error: ResponsesNonStreamingResponseError$Outbound | null;
  incomplete_details: ResponsesIncompleteDetails$Outbound | null;
  usage?: ResponsesUsage$Outbound | undefined;
  max_tool_calls?: number | null | undefined;
  top_logprobs?: number | undefined;
  max_output_tokens?: number | null | undefined;
  temperature: number | null;
  top_p: number | null;
  instructions?:
    | string
    | Array<ResponseInputItem$Outbound>
    | any
    | null
    | undefined;
  metadata: { [k: string]: string } | null;
  tools: Array<Tool$Outbound>;
  tool_choice: ToolChoiceUnion$Outbound;
  parallel_tool_calls: boolean;
  prompt?: ResponsePrompt$Outbound | null | undefined;
  background?: boolean | null | undefined;
  previous_response_id?: string | null | undefined;
  reasoning?: ResponseReasoningConfig$Outbound | null | undefined;
  service_tier?: string | null | undefined;
  store?: boolean | undefined;
  truncation?: string | null | undefined;
  text?: ResponseTextConfig$Outbound | undefined;
};

/** @internal */
export const ResponsesNonStreamingResponse$outboundSchema: z.ZodType<
  ResponsesNonStreamingResponse$Outbound,
  z.ZodTypeDef,
  ResponsesNonStreamingResponse
> = z.object({
  id: z.string(),
  object: ObjectT$outboundSchema,
  createdAt: z.number(),
  model: z.string(),
  status: ResponsesNonStreamingResponseStatus$outboundSchema.optional(),
  output: z.array(ResponsesOutputItem$outboundSchema),
  user: z.nullable(z.string()).optional(),
  outputText: z.string().optional(),
  promptCacheKey: z.nullable(z.string()).optional(),
  safetyIdentifier: z.nullable(z.string()).optional(),
  error: z.nullable(
    z.lazy(() => ResponsesNonStreamingResponseError$outboundSchema),
  ),
  incompleteDetails: z.nullable(ResponsesIncompleteDetails$outboundSchema),
  usage: ResponsesUsage$outboundSchema.optional(),
  maxToolCalls: z.nullable(z.number()).optional(),
  topLogprobs: z.number().optional(),
  maxOutputTokens: z.nullable(z.number()).optional(),
  temperature: z.nullable(z.number()),
  topP: z.nullable(z.number()),
  instructions: z.nullable(
    z.union([z.string(), z.array(ResponseInputItem$outboundSchema), z.any()]),
  ).optional(),
  metadata: z.nullable(z.record(z.string())),
  tools: z.array(Tool$outboundSchema),
  toolChoice: ToolChoiceUnion$outboundSchema,
  parallelToolCalls: z.boolean(),
  prompt: z.nullable(ResponsePrompt$outboundSchema).optional(),
  background: z.nullable(z.boolean()).optional(),
  previousResponseId: z.nullable(z.string()).optional(),
  reasoning: z.nullable(ResponseReasoningConfig$outboundSchema).optional(),
  serviceTier: z.nullable(ServiceTier$outboundSchema).optional(),
  store: z.boolean().optional(),
  truncation: z.nullable(Truncation$outboundSchema).optional(),
  text: ResponseTextConfig$outboundSchema.optional(),
}).transform((v) => {
  return remap$(v, {
    createdAt: "created_at",
    outputText: "output_text",
    promptCacheKey: "prompt_cache_key",
    safetyIdentifier: "safety_identifier",
    incompleteDetails: "incomplete_details",
    maxToolCalls: "max_tool_calls",
    topLogprobs: "top_logprobs",
    maxOutputTokens: "max_output_tokens",
    topP: "top_p",
    toolChoice: "tool_choice",
    parallelToolCalls: "parallel_tool_calls",
    previousResponseId: "previous_response_id",
    serviceTier: "service_tier",
  });
});

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace ResponsesNonStreamingResponse$ {
  /** @deprecated use `ResponsesNonStreamingResponse$inboundSchema` instead. */
  export const inboundSchema = ResponsesNonStreamingResponse$inboundSchema;
  /** @deprecated use `ResponsesNonStreamingResponse$outboundSchema` instead. */
  export const outboundSchema = ResponsesNonStreamingResponse$outboundSchema;
  /** @deprecated use `ResponsesNonStreamingResponse$Outbound` instead. */
  export type Outbound = ResponsesNonStreamingResponse$Outbound;
}

export function responsesNonStreamingResponseToJSON(
  responsesNonStreamingResponse: ResponsesNonStreamingResponse,
): string {
  return JSON.stringify(
    ResponsesNonStreamingResponse$outboundSchema.parse(
      responsesNonStreamingResponse,
    ),
  );
}

export function responsesNonStreamingResponseFromJSON(
  jsonString: string,
): SafeParseResult<ResponsesNonStreamingResponse, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => ResponsesNonStreamingResponse$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'ResponsesNonStreamingResponse' from JSON`,
  );
}
