/*
 * Code generated by Speakeasy (https://speakeasy.com). DO NOT EDIT.
 */

import dotenv from "dotenv";

dotenv.config();

/**
 * Example demonstrating multi-turn conversations using Claude-style messages
 * with the anthropic-compat helper functions.
 *
 * This example shows how to:
 * 1. Use Claude-style message format (ClaudeMessageParam)
 * 2. Convert between Claude format and OpenResponses format
 * 3. Build a 3-turn conversation carrying message history forward
 *
 * To run this example from the examples directory with Bun:
 * bun run anthropic-reasoning.example.ts
 */

import type { ClaudeMessageParam } from "../src/models/claude-message.js";
import {
  OpenRouter,
  fromClaudeMessages,
  toClaudeMessage,
} from "../src/index.js";

if (!process.env["OPENROUTER_API_KEY"]) {
  throw new Error("Missing OPENROUTER_API_KEY environment variable");
}

const openRouter = new OpenRouter({
  apiKey: process.env["OPENROUTER_API_KEY"] ?? "",
});

async function multiTurnClaudeConversation() {
  const model = "anthropic/claude-sonnet-4";

  // Initialize message history with Claude-style message format
  const messages: ClaudeMessageParam[] = [
    {
      role: "user",
      content: "What are the key differences between functional and object-oriented programming?",
    },
  ];

  console.log("=== Turn 1 ===");
  console.log("User:", messages[0].content);
  console.log();

  // First turn - convert Claude messages to OpenResponses format
  const result1 = await openRouter.callModel({
    model,
    input: fromClaudeMessages(messages),
  });

  // Get the response and convert back to Claude format
  const response1 = await result1.getResponse();
  const claudeMessage1 = toClaudeMessage(response1);

  // Extract text content from Claude message
  const content1 = extractTextContent(claudeMessage1.content);
  console.log("Assistant:", content1);
  console.log();

  // Add assistant response to history (as Claude-style message)
  messages.push({
    role: "assistant",
    content: content1,
  });

  // Add next user message
  messages.push({
    role: "user",
    content: "Can you show me an example of how the same problem would be solved differently in each paradigm?",
  });

  console.log("=== Turn 2 ===");
  console.log("User:", messages[messages.length - 1].content);
  console.log();

  // Second turn
  const result2 = await openRouter.callModel({
    model,
    input: fromClaudeMessages(messages),
  });

  const response2 = await result2.getResponse();
  const claudeMessage2 = toClaudeMessage(response2);
  const content2 = extractTextContent(claudeMessage2.content);
  console.log("Assistant:", content2);
  console.log();

  // Add to history
  messages.push({
    role: "assistant",
    content: content2,
  });

  messages.push({
    role: "user",
    content: "Which paradigm would you recommend for building a large-scale web application and why?",
  });

  console.log("=== Turn 3 ===");
  console.log("User:", messages[messages.length - 1].content);
  console.log();

  // Third turn
  const result3 = await openRouter.callModel({
    model,
    input: fromClaudeMessages(messages),
  });

  const response3 = await result3.getResponse();
  const claudeMessage3 = toClaudeMessage(response3);
  const content3 = extractTextContent(claudeMessage3.content);
  console.log("Assistant:", content3);
  console.log();

  // Final message history
  messages.push({
    role: "assistant",
    content: content3,
  });

  console.log("=== Conversation Complete ===");
  console.log(`Total messages in history: ${messages.length}`);

  // Show the final Claude message structure
  console.log("\n=== Final Claude Message Structure ===");
  console.log("Stop reason:", claudeMessage3.stop_reason);
  console.log("Model:", claudeMessage3.model);
  console.log("Usage:", claudeMessage3.usage);
}

/**
 * Helper to extract text content from Claude message content blocks
 */
function extractTextContent(
  content: Array<{ type: string; text?: string }>
): string {
  return content
    .filter((block) => block.type === "text" && block.text)
    .map((block) => block.text)
    .join("");
}

async function main() {
  try {
    await multiTurnClaudeConversation();
  } catch (error) {
    console.error("Error:", error);
  }
}

main();
